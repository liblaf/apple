{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Explore the docs \u00bb</p> <p> </p> <p>Changelog \u00b7 Report Bug \u00b7 Request Feature</p> <p></p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83e\uddee Finite Element Simulation: Provides tools for simulating deformable objects using tetrahedral and triangular meshes with support for various elasticity models;</li> <li>\ud83d\udd04 Differentiable Physics: Enables gradient-based optimization through automatic differentiation using JAX and Warp integration;</li> <li>\u26a1 Efficient Optimization: Implements advanced algorithms like Preconditioned Nonlinear Conjugate Gradient (PNCG) for real-time physics simulations;</li> <li>\ud83c\udfaf Elasticity Models: Features multiple material models including ARAP (As-Rigid-As-Possible) and active muscle simulation capabilities;</li> <li>\ud83d\udcca Meshing &amp; Visualization: Integrates with PyVista for mesh processing and visualization, supporting both surface and volumetric meshes;</li> <li>\ud83e\udde9 Modular Design: Offers a clean architecture with separated components for energies, optimizers, and geometry handling;</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>To install <code>liblaf-apple</code>, run the following command:</p> <pre><code>uv add liblaf-apple\n</code></pre>"},{"location":"#local-development","title":"\u2328\ufe0f Local Development","text":"<p>You can use Github Codespaces for online development:</p> <p></p> <p>Or clone it for local development:</p> <pre><code>gh repo clone liblaf/apple\ncd apple\nmise run install\n</code></pre>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions of all types are more than welcome, if you are interested in contributing code, feel free to check out our GitHub Issues to get stuck in to show us what you\u2019re made of.</p> <p></p> <p></p>"},{"location":"#more-projects","title":"\ud83d\udd17 More Projects","text":"<ul> <li>\ud83c\udf47 Grapes - Supercharge your Python with rich logging, precise timing, and seamless serialization.</li> <li>\ud83c\udf49 Melon - A comprehensive Python library for 3D mesh processing with advanced I/O capabilities, proximity analysis, and integration with external mesh processing tools.</li> <li>\ud83c\udf4a Tangerine - Squeeze dynamic content into your files with Tangerine\u2019s template magic.</li> <li>\ud83c\udf4b\u200d\ud83d\udfe9 Lime - AI-powered Git commit assistant and repository documentation generator</li> <li>\ud83c\udf4e Apple - A JAX and Warp library for differentiable physics simulation, featuring elastic energy models and finite element methods.</li> <li>\ud83c\udf52 Cherries - Sweet experiment tracking with Comet, DVC, and Git integration.</li> </ul>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>Copyright \u00a9 2025 liblaf.  This project is MIT licensed.</p>"},{"location":"reference/liblaf/apple/","title":"apple","text":""},{"location":"reference/liblaf/apple/#liblaf.apple","title":"liblaf.apple","text":"<p>Modules:</p> <ul> <li> <code>jax</code>           \u2013            </li> <li> <code>sim</code>           \u2013            </li> <li> <code>warp</code>           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>__version__</code>               (<code>str</code>)           \u2013            </li> <li> <code>__version_tuple__</code>               (<code>tuple[int | str, ...]</code>)           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> <li> <code>version_tuple</code>               (<code>tuple[int | str, ...]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/#liblaf.apple.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__: str = '0.4.1.dev32+g5cb4a7687'\n</code></pre>"},{"location":"reference/liblaf/apple/#liblaf.apple.__version_tuple__","title":"__version_tuple__  <code>module-attribute</code>","text":"<pre><code>__version_tuple__: tuple[int | str, ...] = (\n    0,\n    4,\n    1,\n    \"dev32\",\n    \"g5cb4a7687\",\n)\n</code></pre>"},{"location":"reference/liblaf/apple/#liblaf.apple.version","title":"version  <code>module-attribute</code>","text":"<pre><code>version: str = '0.4.1.dev32+g5cb4a7687'\n</code></pre>"},{"location":"reference/liblaf/apple/#liblaf.apple.version_tuple","title":"version_tuple  <code>module-attribute</code>","text":"<pre><code>version_tuple: tuple[int | str, ...] = (\n    0,\n    4,\n    1,\n    \"dev32\",\n    \"g5cb4a7687\",\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/","title":"jax","text":""},{"location":"reference/liblaf/apple/jax/#liblaf.apple.jax","title":"liblaf.apple.jax","text":"<p>Modules:</p> <ul> <li> <code>math</code>           \u2013            </li> <li> <code>optim</code>           \u2013            </li> <li> <code>sim</code>           \u2013            </li> <li> <code>testing</code>           \u2013            </li> <li> <code>tree</code>           \u2013            </li> <li> <code>typing</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/math/","title":"math","text":""},{"location":"reference/liblaf/apple/jax/math/#liblaf.apple.jax.math","title":"liblaf.apple.jax.math","text":"<p>Functions:</p> <ul> <li> <code>asarray</code>             \u2013              </li> <li> <code>fro_norm_square</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>polar_rv</code>             \u2013              </li> <li> <code>svd_rv</code>             \u2013              </li> <li> <code>tree_dot</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/math/#liblaf.apple.jax.math.asarray","title":"asarray","text":"<pre><code>asarray(a: ArrayLike, *args, **kwargs) -&gt; Array\n</code></pre> Source code in <code>src/liblaf/apple/jax/math/_asarray.py</code> <pre><code>@grapes.clone_param_spec(jnp.asarray)\ndef asarray(a: ArrayLike, *args, **kwargs) -&gt; Array:\n    return jnp.asarray(a, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/math/#liblaf.apple.jax.math.fro_norm_square","title":"fro_norm_square","text":"<pre><code>fro_norm_square(\n    a: Float[Array, \"*batch I I\"],\n) -&gt; Float[Array, \"*batch\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/math/_norm.py</code> <pre><code>def fro_norm_square(a: Float[Array, \"*batch I I\"]) -&gt; Float[Array, \"*batch\"]:\n    return jnp.sum(jnp.square(a), axis=(-2, -1))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/math/#liblaf.apple.jax.math.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(\n    func: Callable[..., Scalar],\n    x: PyTree,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n) -&gt; PyTree\n</code></pre> Source code in <code>src/liblaf/apple/jax/math/_autodiff.py</code> <pre><code>def hess_diag(\n    func: Callable[..., Scalar],\n    x: PyTree,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n) -&gt; PyTree:\n    x_flat: Float[Array, \" I\"]\n    unflatten: Callable[[Float[Array, \" I\"]], PyTree]\n    x_flat, unflatten = tree.flatten(x)\n\n    def compute(v_flat: Float[Array, \" I\"]) -&gt; Float[Array, \" I\"]:\n        v: PyTree = unflatten(v_flat)\n        Hv: PyTree = hess_prod(func, x, v, args, kwargs)\n        return jnp.vdot(v, Hv)\n\n    vs: Float[Array, \"I I\"] = jnp.identity(x_flat.size)\n    diag_flat: Float[Array, \" I\"] = jax.vmap(compute)(vs)\n    diag: PyTree = unflatten(diag_flat)\n    return diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/math/#liblaf.apple.jax.math.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(\n    func: Callable[..., Scalar],\n    x: PyTree,\n    p: PyTree,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n) -&gt; PyTree\n</code></pre> Source code in <code>src/liblaf/apple/jax/math/_autodiff.py</code> <pre><code>def hess_prod(\n    func: Callable[..., Scalar],\n    x: PyTree,\n    p: PyTree,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n) -&gt; PyTree:\n    x_flat: Float[Array, \" I\"]\n    unflatten: Callable[[Float[Array, \" I\"]], PyTree]\n    x_flat, unflatten = tree.flatten(x)\n    p_flat: Float[Array, \" I\"]\n    p_flat, _ = tree.flatten(p)\n\n    def fun(x: Float[Array, \" I\"]) -&gt; Scalar:\n        return func(unflatten(x), *args, **kwargs)\n\n    prod_flat: Float[Array, \" I\"]\n    _, prod_flat = jax.jvp(jax.grad(fun), (x_flat,), (p_flat,))\n    prod: PyTree = unflatten(prod_flat)\n    return prod\n</code></pre>"},{"location":"reference/liblaf/apple/jax/math/#liblaf.apple.jax.math.polar_rv","title":"polar_rv","text":"<pre><code>polar_rv(\n    a: Float[Array, \"*batch I I\"],\n) -&gt; tuple[\n    Float[Array, \"*batch I I\"], Float[Array, \"*batch I I\"]\n]\n</code></pre> Source code in <code>src/liblaf/apple/jax/math/_rotation.py</code> <pre><code>def polar_rv(\n    a: Float[Array, \"*batch I I\"],\n) -&gt; tuple[Float[Array, \"*batch I I\"], Float[Array, \"*batch I I\"]]:\n    u: Float[Array, \"*batch I I\"]\n    s: Float[Array, \"*batch I\"]\n    vh: Float[Array, \"*batch I I\"]\n    u, s, vh = svd_rv(a)\n    R: Float[Array, \"*batch I I\"] = einops.einsum(u, vh, \"... i j, ... j k -&gt; ... i k\")\n    S: Float[Array, \"*batch I I\"] = einops.einsum(\n        vh, s, vh, \"... j i, ... j, ... j k -&gt; ... i k\"\n    )\n    R = jax.lax.stop_gradient(R)\n    S = jax.lax.stop_gradient(S)\n    return R, S\n</code></pre>"},{"location":"reference/liblaf/apple/jax/math/#liblaf.apple.jax.math.svd_rv","title":"svd_rv","text":"<pre><code>svd_rv(\n    a: Float[Array, \"*batch I I\"],\n) -&gt; tuple[\n    Float[Array, \"*batch I I\"],\n    Float[Array, \"*batch I\"],\n    Float[Array, \"*batch I I\"],\n]\n</code></pre> Source code in <code>src/liblaf/apple/jax/math/_rotation.py</code> <pre><code>def svd_rv(\n    a: Float[Array, \"*batch I I\"],\n) -&gt; tuple[\n    Float[Array, \"*batch I I\"], Float[Array, \"*batch I\"], Float[Array, \"*batch I I\"]\n]:\n    u: Float[Array, \"*batch I I\"]\n    s: Float[Array, \"*batch I\"]\n    vh: Float[Array, \"*batch I I\"]\n    u, s, vh = jnp.linalg.svd(a, full_matrices=False)\n    det_u: Float[Array, \"*batch\"] = jnp.linalg.det(u)\n    det_v: Float[Array, \"*batch\"] = jnp.linalg.det(vh)\n    u = u.at[..., :, -1].multiply(jnp.where(det_u &lt; 0, -1, 1)[..., jnp.newaxis])\n    vh = vh.at[..., -1, :].multiply(jnp.where(det_v &lt; 0, -1, 1)[..., jnp.newaxis])\n    s = s.at[..., -1].multiply(jnp.where(det_u * det_v &lt; 0, -1, 1))\n    return u, s, vh\n</code></pre>"},{"location":"reference/liblaf/apple/jax/math/#liblaf.apple.jax.math.tree_dot","title":"tree_dot","text":"<pre><code>tree_dot(a: PyTree, b: PyTree) -&gt; Float[Array, '']\n</code></pre> Source code in <code>src/liblaf/apple/jax/math/_tree.py</code> <pre><code>def tree_dot(a: PyTree, b: PyTree) -&gt; Float[Array, \"\"]:\n    a_leaves: list[Any] = jax.tree.leaves(a)\n    b_leaves: list[Any] = jax.tree.leaves(b)\n    outputs: list[Float[Array, \"\"]] = []\n    for a_leaf, b_leaf in zip(a_leaves, b_leaves, strict=True):\n        if eqx.is_array(a_leaf):\n            outputs.append(jnp.vdot(a_leaf, b_leaf))\n    return jnp.sum(jnp.asarray(outputs))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/","title":"optim","text":""},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim","title":"liblaf.apple.jax.optim","text":"<p>Classes:</p> <ul> <li> <code>Minimizer</code>           \u2013            </li> <li> <code>MinimizerPNCG</code>           \u2013            <p>Preconditioned Nonlinear Conjugate Gradient Method.</p> </li> <li> <code>MinimizerScipy</code>           \u2013            </li> <li> <code>Objective</code>           \u2013            </li> <li> <code>Solution</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Minimizer","title":"Minimizer","text":"<p>               Bases: <code>ABC</code></p> <p>Parameters:</p> <ul> <li> <code>jit</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>timer</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>minimize</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>jit</code>               (<code>bool</code>)           \u2013            </li> <li> <code>timer</code>               (<code>bool</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Minimizer.jit","title":"jit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jit: bool = field(default=True)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Minimizer.timer","title":"timer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timer: bool = field(default=True)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Minimizer.minimize","title":"minimize","text":"<pre><code>minimize(\n    x0: PyTree,\n    *,\n    fun: Callable | None = None,\n    jac: Callable | None = None,\n    hess: Callable | None = None,\n    hessp: Callable | None = None,\n    hess_diag: Callable | None = None,\n    hess_quad: Callable | None = None,\n    fun_and_jac: Callable | None = None,\n    jac_and_hess_diag: Callable | None = None,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    bounds: Any = None,\n    callback: Callable | None = None,\n) -&gt; Solution\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_minimizer.py</code> <pre><code>def minimize(\n    self,\n    x0: PyTree,\n    *,\n    fun: Callable | None = None,\n    jac: Callable | None = None,\n    hess: Callable | None = None,\n    hessp: Callable | None = None,\n    hess_diag: Callable | None = None,\n    hess_quad: Callable | None = None,\n    fun_and_jac: Callable | None = None,\n    jac_and_hess_diag: Callable | None = None,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    bounds: Any = None,\n    callback: Callable | None = None,\n) -&gt; Solution:\n    objective: Objective = Objective(\n        fun=fun,\n        jac=jac,\n        hess=hess,\n        hessp=hessp,\n        hess_diag=hess_diag,\n        hess_quad=hess_quad,\n        fun_and_jac=fun_and_jac,\n        jac_and_hess_diag=jac_and_hess_diag,\n    )\n    if self.jit:\n        objective = objective.jit()\n    if self.timer:\n        objective = objective.timer()\n    with grapes.timer(name=str(self)) as timer:\n        solution: Solution = self._minimize_impl(\n            objective=objective,\n            x0=x0,\n            args=args,\n            kwargs=kwargs,\n            bounds=bounds,\n            callback=callback,\n        )\n    solution[\"time\"] = timer.elapsed()\n    for field in attrs.fields(type(objective)):\n        fn: Callable | None = getattr(objective, field.name)\n        if fn is None:\n            continue\n        timer: grapes.BaseTimer | None = grapes.get_timer(fn, None)\n        if timer is None:\n            continue\n        if len(timer) == 0:\n            continue\n        timer.log_summary()\n    return solution\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG","title":"MinimizerPNCG","text":"<p>               Bases: <code>Minimizer</code></p> <p>Preconditioned Nonlinear Conjugate Gradient Method.</p> References <ol> <li>Xing Shen, Runyuan Cai, Mengxiao Bi, and Tangjie Lv. 2024. Preconditioned Nonlinear Conjugate Gradient Method for Real-time Interior-point Hyperelasticity. In ACM SIGGRAPH 2024 Conference Papers (SIGGRAPH \u201824). Association for Computing Machinery, New York, NY, USA, Article 96, 1\u201311. https://doi.org/10.1145/3641519.3657490</li> </ol> <p>Parameters:</p> <ul> <li> <code>jit</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>timer</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>atol</code>               (<code>float</code>, default:                   <code>1e-15</code> )           \u2013            </li> <li> <code>d_hat</code>               (<code>float</code>, default:                   <code>inf</code> )           \u2013            </li> <li> <code>maxiter</code>               (<code>int</code>, default:                   <code>150</code> )           \u2013            </li> <li> <code>rtol</code>               (<code>float</code>, default:                   <code>5e-05</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>compute_alpha</code>             \u2013              </li> <li> <code>compute_beta</code>             \u2013              </li> <li> <code>minimize</code>             \u2013              </li> <li> <code>step</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>atol</code>               (<code>float</code>)           \u2013            </li> <li> <code>d_hat</code>               (<code>float</code>)           \u2013            </li> <li> <code>jit</code>               (<code>bool</code>)           \u2013            </li> <li> <code>maxiter</code>               (<code>int</code>)           \u2013            </li> <li> <code>rtol</code>               (<code>float</code>)           \u2013            </li> <li> <code>timer</code>               (<code>bool</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.atol","title":"atol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>atol: float = field(default=1e-15)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.d_hat","title":"d_hat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>d_hat: float = field(default=inf)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.jit","title":"jit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jit: bool = field(default=True)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.maxiter","title":"maxiter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maxiter: int = field(default=150)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.rtol","title":"rtol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rtol: float = field(default=5e-05)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.timer","title":"timer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timer: bool = field(default=True)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.compute_alpha","title":"compute_alpha","text":"<pre><code>compute_alpha(g: Vector, p: Vector, pHp: Scalar) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_pncg.py</code> <pre><code>@eqx.filter_jit\ndef compute_alpha(self, g: Vector, p: Vector, pHp: Scalar) -&gt; Scalar:\n    alpha_1: Scalar = self.d_hat / (2.0 * jnp.linalg.norm(p, ord=jnp.inf))\n    alpha_2: Scalar = -jnp.vdot(g, p) / pHp\n    alpha: Scalar = jnp.minimum(alpha_1, alpha_2)\n    alpha = jnp.nan_to_num(alpha)\n    return alpha\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.compute_beta","title":"compute_beta","text":"<pre><code>compute_beta(\n    g_prev: Vector, g: Vector, p: Vector, P: Vector\n) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_pncg.py</code> <pre><code>@eqx.filter_jit\ndef compute_beta(self, g_prev: Vector, g: Vector, p: Vector, P: Vector) -&gt; Scalar:\n    y: Vector = g - g_prev\n    yTp: Scalar = jnp.vdot(y, p)\n    Py: Vector = P * y\n    beta: Scalar = jnp.vdot(g, Py) / yTp - (jnp.vdot(y, Py) / yTp) * (\n        jnp.vdot(p, g) / yTp\n    )\n    return beta\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.minimize","title":"minimize","text":"<pre><code>minimize(\n    x0: PyTree,\n    *,\n    fun: Callable | None = None,\n    jac: Callable | None = None,\n    hess: Callable | None = None,\n    hessp: Callable | None = None,\n    hess_diag: Callable | None = None,\n    hess_quad: Callable | None = None,\n    fun_and_jac: Callable | None = None,\n    jac_and_hess_diag: Callable | None = None,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    bounds: Any = None,\n    callback: Callable | None = None,\n) -&gt; Solution\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_minimizer.py</code> <pre><code>def minimize(\n    self,\n    x0: PyTree,\n    *,\n    fun: Callable | None = None,\n    jac: Callable | None = None,\n    hess: Callable | None = None,\n    hessp: Callable | None = None,\n    hess_diag: Callable | None = None,\n    hess_quad: Callable | None = None,\n    fun_and_jac: Callable | None = None,\n    jac_and_hess_diag: Callable | None = None,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    bounds: Any = None,\n    callback: Callable | None = None,\n) -&gt; Solution:\n    objective: Objective = Objective(\n        fun=fun,\n        jac=jac,\n        hess=hess,\n        hessp=hessp,\n        hess_diag=hess_diag,\n        hess_quad=hess_quad,\n        fun_and_jac=fun_and_jac,\n        jac_and_hess_diag=jac_and_hess_diag,\n    )\n    if self.jit:\n        objective = objective.jit()\n    if self.timer:\n        objective = objective.timer()\n    with grapes.timer(name=str(self)) as timer:\n        solution: Solution = self._minimize_impl(\n            objective=objective,\n            x0=x0,\n            args=args,\n            kwargs=kwargs,\n            bounds=bounds,\n            callback=callback,\n        )\n    solution[\"time\"] = timer.elapsed()\n    for field in attrs.fields(type(objective)):\n        fn: Callable | None = getattr(objective, field.name)\n        if fn is None:\n            continue\n        timer: grapes.BaseTimer | None = grapes.get_timer(fn, None)\n        if timer is None:\n            continue\n        if len(timer) == 0:\n            continue\n        timer.log_summary()\n    return solution\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerPNCG.step","title":"step","text":"<pre><code>step(\n    jac_and_hess_diag: Callable[..., tuple[Vector, Vector]],\n    hess_quad: Callable[..., Scalar],\n    state: State,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n) -&gt; State\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_pncg.py</code> <pre><code>def step(\n    self,\n    jac_and_hess_diag: Callable[..., tuple[Vector, Vector]],\n    hess_quad: Callable[..., Scalar],\n    state: State,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n) -&gt; State:\n    x: Vector = state.x\n    g: Vector\n    hess_diag: Vector\n    g, hess_diag = jac_and_hess_diag(x, *args, **kwargs)\n    P: Vector = jnp.reciprocal(hess_diag)\n    p: Vector\n    if state.p is None:  # first iteration\n        beta: Scalar = 0.0\n        p = -P * g\n    else:\n        beta: Scalar = self.compute_beta(g_prev=state.g, g=g, p=state.p, P=P)\n        p = -P * g + beta * state.p\n    pHp: Scalar = hess_quad(x, p, *args, **kwargs)\n    alpha: Scalar = self.compute_alpha(g=g, p=p, pHp=pHp)\n    x += alpha * p\n    DeltaE: Scalar = -alpha * jnp.vdot(g, p) - 0.5 * jnp.square(alpha) * pHp\n    return attrs.evolve(\n        state,\n        alpha=alpha,\n        beta=beta,\n        DeltaE=DeltaE,\n        g=g,\n        hess_diag=hess_diag,\n        hess_quad=pHp,\n        p=p,\n        P=P,\n        x=x,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerScipy","title":"MinimizerScipy","text":"<p>               Bases: <code>Minimizer</code></p> <p>Parameters:</p> <ul> <li> <code>jit</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>timer</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>method</code>               (<code>str</code>, default:                   <code>'trust-constr'</code> )           \u2013            </li> <li> <code>tol</code>               (<code>float | None</code>, default:                   <code>1e-05</code> )           \u2013            </li> <li> <code>options</code>               (<code>Mapping[str, Any]</code>, default:                   <code>{}</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>minimize</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>jit</code>               (<code>bool</code>)           \u2013            </li> <li> <code>method</code>               (<code>str</code>)           \u2013            </li> <li> <code>options</code>               (<code>Mapping[str, Any]</code>)           \u2013            </li> <li> <code>timer</code>               (<code>bool</code>)           \u2013            </li> <li> <code>tol</code>               (<code>float | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerScipy.jit","title":"jit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jit: bool = field(default=True)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerScipy.method","title":"method  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>method: str = 'trust-constr'\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerScipy.options","title":"options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>options: Mapping[str, Any] = {}\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerScipy.timer","title":"timer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timer: bool = field(default=True)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerScipy.tol","title":"tol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tol: float | None = 1e-05\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.MinimizerScipy.minimize","title":"minimize","text":"<pre><code>minimize(\n    x0: PyTree,\n    *,\n    fun: Callable | None = None,\n    jac: Callable | None = None,\n    hess: Callable | None = None,\n    hessp: Callable | None = None,\n    hess_diag: Callable | None = None,\n    hess_quad: Callable | None = None,\n    fun_and_jac: Callable | None = None,\n    jac_and_hess_diag: Callable | None = None,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    bounds: Any = None,\n    callback: Callable | None = None,\n) -&gt; Solution\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_minimizer.py</code> <pre><code>def minimize(\n    self,\n    x0: PyTree,\n    *,\n    fun: Callable | None = None,\n    jac: Callable | None = None,\n    hess: Callable | None = None,\n    hessp: Callable | None = None,\n    hess_diag: Callable | None = None,\n    hess_quad: Callable | None = None,\n    fun_and_jac: Callable | None = None,\n    jac_and_hess_diag: Callable | None = None,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    bounds: Any = None,\n    callback: Callable | None = None,\n) -&gt; Solution:\n    objective: Objective = Objective(\n        fun=fun,\n        jac=jac,\n        hess=hess,\n        hessp=hessp,\n        hess_diag=hess_diag,\n        hess_quad=hess_quad,\n        fun_and_jac=fun_and_jac,\n        jac_and_hess_diag=jac_and_hess_diag,\n    )\n    if self.jit:\n        objective = objective.jit()\n    if self.timer:\n        objective = objective.timer()\n    with grapes.timer(name=str(self)) as timer:\n        solution: Solution = self._minimize_impl(\n            objective=objective,\n            x0=x0,\n            args=args,\n            kwargs=kwargs,\n            bounds=bounds,\n            callback=callback,\n        )\n    solution[\"time\"] = timer.elapsed()\n    for field in attrs.fields(type(objective)):\n        fn: Callable | None = getattr(objective, field.name)\n        if fn is None:\n            continue\n        timer: grapes.BaseTimer | None = grapes.get_timer(fn, None)\n        if timer is None:\n            continue\n        if len(timer) == 0:\n            continue\n        timer.log_summary()\n    return solution\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective","title":"Objective","text":"<p>Parameters:</p> <ul> <li> <code>fun</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>jac</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>hess</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>hessp</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>hess_diag</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>hess_quad</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>fun_and_jac</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>jac_and_hess_diag</code>               (<code>Callable | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>flatten</code>             \u2013              </li> <li> <code>jit</code>             \u2013              </li> <li> <code>partial</code>             \u2013              </li> <li> <code>timer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>fun</code>               (<code>Callable | None</code>)           \u2013            </li> <li> <code>fun_and_jac</code>               (<code>Callable | None</code>)           \u2013            </li> <li> <code>hess</code>               (<code>Callable | None</code>)           \u2013            </li> <li> <code>hess_diag</code>               (<code>Callable | None</code>)           \u2013            </li> <li> <code>hess_quad</code>               (<code>Callable | None</code>)           \u2013            </li> <li> <code>hessp</code>               (<code>Callable | None</code>)           \u2013            </li> <li> <code>jac</code>               (<code>Callable | None</code>)           \u2013            </li> <li> <code>jac_and_hess_diag</code>               (<code>Callable | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.fun","title":"fun  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fun: Callable | None = None\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.fun_and_jac","title":"fun_and_jac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fun_and_jac: Callable | None = None\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.hess","title":"hess  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hess: Callable | None = None\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.hess_diag","title":"hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hess_diag: Callable | None = None\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.hess_quad","title":"hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hess_quad: Callable | None = None\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.hessp","title":"hessp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hessp: Callable | None = None\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.jac","title":"jac  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jac: Callable | None = None\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.jac_and_hess_diag","title":"jac_and_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>jac_and_hess_diag: Callable | None = None\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.flatten","title":"flatten","text":"<pre><code>flatten(unflatten: Callable[[Array], PyTree]) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_objective/_objective.py</code> <pre><code>def flatten(self, unflatten: Callable[[Array], PyTree]) -&gt; Self:\n    def flatten(\n        fn: Callable | None,\n        *,\n        arg_nums: Iterable[int] = (0,),\n        multiple_outputs: bool = False,\n    ) -&gt; Callable | None:\n        if fn is None:\n            return None\n\n        @wrapt.decorator\n        def wrapper(\n            wrapped: Callable,\n            _instance: None,\n            args: Sequence[Any],\n            kwargs: Mapping[str, Any],\n        ) -&gt; Any:\n            args = list(args)\n            for i in arg_nums:\n                args[i] = unflatten(args[i])\n            outputs: Any = wrapped(*args, **kwargs)\n            if not multiple_outputs:\n                return tree.flatten(outputs)[0]\n            outputs = tuple(tree.flatten(r)[0] for r in outputs)\n            return outputs\n\n        return wrapper(fn)\n\n    updates: dict[str, Callable | None] = {}\n    updates[\"fun\"] = flatten(self.fun, arg_nums=(0,))\n    updates[\"jac\"] = flatten(self.jac, arg_nums=(0,))\n    if self.hess is not None:\n        raise NotImplementedError\n    updates[\"hessp\"] = flatten(self.hessp, arg_nums=(0, 1))\n    updates[\"hess_diag\"] = flatten(self.hess_diag, arg_nums=(0,))\n    updates[\"hess_quad\"] = flatten(self.hess_quad, arg_nums=(0, 1))\n    updates[\"fun_and_jac\"] = flatten(\n        self.fun_and_jac, arg_nums=(0,), multiple_outputs=True\n    )\n    updates[\"jac_and_hess_diag\"] = flatten(\n        self.jac_and_hess_diag, arg_nums=(0,), multiple_outputs=True\n    )\n    updates = toolz.valfilter(lambda fn: fn is not None, updates)\n    return attrs.evolve(self, **updates)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.jit","title":"jit","text":"<pre><code>jit() -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_objective/_objective.py</code> <pre><code>def jit(self) -&gt; Self:\n    updates: dict[str, Callable] = {}\n    for name in FUNCTION_NAMES:\n        fn: Callable | None = getattr(self, name)\n        if fn is None:\n            continue\n        updates[name] = eqx.filter_jit(fn)\n    return attrs.evolve(self, **updates)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.partial","title":"partial","text":"<pre><code>partial(\n    args: Sequence[Any] = (), kwargs: Mapping[str, Any] = {}\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_objective/_objective.py</code> <pre><code>def partial(self, args: Sequence[Any] = (), kwargs: Mapping[str, Any] = {}) -&gt; Self:\n    updates: dict[str, Callable] = {}\n\n    def partial(\n        fn: Callable, args: Sequence[Any], kwargs: Mapping[str, Any]\n    ) -&gt; Callable:\n        partial_args: Sequence[Any] = args\n        partial_kwargs: Mapping[str, Any] = kwargs\n\n        @wrapt.decorator\n        def wrapper(\n            wrapped: Callable,\n            _instance: None,\n            args: Sequence[Any],\n            kwargs: Mapping[str, Any],\n        ) -&gt; Any:\n            return wrapped(*args, *partial_args, **partial_kwargs, **kwargs)\n\n        return wrapper(fn)\n\n    for name in FUNCTION_NAMES:\n        fn: Callable | None = getattr(self, name)\n        if fn is None:\n            continue\n        updates[name] = partial(fn, args, kwargs)\n    return attrs.evolve(self, **updates)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Objective.timer","title":"timer","text":"<pre><code>timer() -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/optim/_minimize/_objective/_objective.py</code> <pre><code>def timer(self) -&gt; Self:\n    updates: dict[str, Callable] = {}\n    for name in FUNCTION_NAMES:\n        fn: Callable | None = getattr(self, name)\n        if fn is None:\n            continue\n        updates[name] = grapes.timer(fn, name=f\"{name}()\")\n    return attrs.evolve(self, **updates)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/optim/#liblaf.apple.jax.optim.Solution","title":"Solution","text":"<p>               Bases: <code>OptimizeResult</code></p>"},{"location":"reference/liblaf/apple/jax/sim/","title":"sim","text":""},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim","title":"liblaf.apple.jax.sim","text":"<p>Modules:</p> <ul> <li> <code>dirichlet</code>           \u2013            </li> <li> <code>element</code>           \u2013            </li> <li> <code>energy</code>           \u2013            </li> <li> <code>geometry</code>           \u2013            </li> <li> <code>model</code>           \u2013            </li> <li> <code>quadrature</code>           \u2013            </li> <li> <code>region</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>ARAP</code>           \u2013            </li> <li> <code>ARAPActive</code>           \u2013            </li> <li> <code>Dirichlet</code>           \u2013            </li> <li> <code>DirichletBuilder</code>           \u2013            </li> <li> <code>Elastic</code>           \u2013            </li> <li> <code>Element</code>           \u2013            <p>Base-class for a finite element which provides methods for plotting.</p> </li> <li> <code>ElementTetra</code>           \u2013            </li> <li> <code>Energy</code>           \u2013            </li> <li> <code>Geometry</code>           \u2013            </li> <li> <code>GeometryAttributes</code>           \u2013            </li> <li> <code>GeometryTetra</code>           \u2013            </li> <li> <code>GeometryTriangle</code>           \u2013            </li> <li> <code>Koiter</code>           \u2013            </li> <li> <code>Model</code>           \u2013            </li> <li> <code>ModelBuilder</code>           \u2013            </li> <li> <code>PhaceActive</code>           \u2013            </li> <li> <code>PhaceStatic</code>           \u2013            </li> <li> <code>QuadratureTetra</code>           \u2013            </li> <li> <code>Region</code>           \u2013            </li> <li> <code>Scheme</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>make_activation</code>             \u2013              </li> <li> <code>rest_activation</code>             \u2013              </li> <li> <code>transform_activation</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP","title":"ARAP","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap.py</code> <pre><code>def energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    return 0.5 * mu * math.fro_norm_square(F - R)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(region=region, mu=region.cell_data[\"mu\"], **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAP.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive","title":"ARAPActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>activation</code>               (<code>Float[Array, 'c 6']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> <li> <code>mixed_derivative_prod_activation</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>Float[Array, 'c 6']</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.activation","title":"activation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>activation: Float[Array, 'c 6'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    A: Float[Array, \" c #q J J\"] = utils.make_activation(self.activation)[\n        :, jnp.newaxis, :, :\n    ]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    return mu * math.fro_norm_square(F - R @ A)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        activation=region.cell_data[\"activation\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ARAPActive.mixed_derivative_prod_activation","title":"mixed_derivative_prod_activation","text":"<pre><code>mixed_derivative_prod_activation(\n    u: Vector, p: Vector\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>def mixed_derivative_prod_activation(self, u: Vector, p: Vector) -&gt; Vector:\n    def jac(q: Float[Array, \"c 6\"]) -&gt; Vector:\n        energy: Self = attrs.evolve(self, activation=q)\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.jac(u)\n        jac: Vector = jax.ops.segment_sum(data, index, num_segments=u.shape[0])\n        return jac\n\n    vjp: Callable[[Vector], Float[Array, \"c 6\"]]\n    _, vjp = jax.vjp(jac, self.activation)\n\n    output: Float[Array, \"c 6\"]\n    (output,) = vjp(p)\n    return output\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet","title":"Dirichlet","text":"<p>Parameters:</p> <ul> <li> <code>n_dofs</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            </li> <li> <code>index</code>               (<code>Integer[Array, dirichlet]</code>, default:                   <code>Array([], shape=(0,), dtype=int32)</code> )           \u2013            </li> <li> <code>index_free</code>               (<code>Integer[Array, free]</code>, default:                   <code>Array([], shape=(0,), dtype=int32)</code> )           \u2013            </li> <li> <code>values</code>               (<code>Float[Array, dirichlet]</code>, default:                   <code>Array([], shape=(0,), dtype=float32)</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>apply</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>get_free</code>             \u2013              </li> <li> <code>mask</code>             \u2013              </li> <li> <code>set</code>             \u2013              </li> <li> <code>set_free</code>             \u2013              </li> <li> <code>zero</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>index</code>               (<code>Integer[Array, ' dirichlet']</code>)           \u2013            </li> <li> <code>index_free</code>               (<code>Integer[Array, ' free']</code>)           \u2013            </li> <li> <code>n_dirichlet</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_dofs</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_free</code>               (<code>int</code>)           \u2013            </li> <li> <code>values</code>               (<code>Float[Array, ' dirichlet']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: Integer[Array, \" dirichlet\"] = array(\n    factory=_default_index\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.index_free","title":"index_free  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index_free: Integer[Array, \" free\"] = array(\n    factory=_default_index\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.n_dirichlet","title":"n_dirichlet  <code>property</code>","text":"<pre><code>n_dirichlet: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.n_dofs","title":"n_dofs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_dofs: int = field(default=0)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.n_free","title":"n_free  <code>property</code>","text":"<pre><code>n_free: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.values","title":"values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>values: Float[Array, \" dirichlet\"] = array(\n    factory=_default_values\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.apply","title":"apply","text":"<pre><code>apply(x: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def apply(self, x: Vector) -&gt; Vector:\n    return self.set(x, self.values)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.get","title":"get","text":"<pre><code>get(x: Vector) -&gt; Float[Array, ' dirichlet']\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def get(self, x: Vector) -&gt; Float[Array, \" dirichlet\"]:\n    x_flat: Array = x.flatten()\n    return x_flat[self.index]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.get_free","title":"get_free","text":"<pre><code>get_free(x: Vector) -&gt; Float[Array, ' free']\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def get_free(self, x: Vector) -&gt; Float[Array, \" free\"]:\n    x_flat: Array = x.flatten()\n    return x_flat[self.index_free]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.mask","title":"mask","text":"<pre><code>mask(x: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def mask(self, x: Vector) -&gt; Vector:\n    return self.set(x, True)  # noqa: FBT003\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.set","title":"set","text":"<pre><code>set(x: Vector, values: ArrayLike) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def set(self, x: Vector, values: ArrayLike) -&gt; Vector:\n    x_flat: Array = x.flatten()\n    y_flat: Array = x_flat.at[self.index].set(values)\n    return y_flat.reshape(x.shape)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.set_free","title":"set_free","text":"<pre><code>set_free(x: Vector, values: ArrayLike) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def set_free(self, x: Vector, values: ArrayLike) -&gt; Vector:\n    x_flat: Array = x.flatten()\n    y_flat: Array = x_flat.at[self.index_free].set(values)\n    return y_flat.reshape(x.shape)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Dirichlet.zero","title":"zero","text":"<pre><code>zero(x: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def zero(self, x: Vector) -&gt; Vector:\n    return self.set(x, 0.0)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.DirichletBuilder","title":"DirichletBuilder","text":"<p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            </li> <li> <code>mask</code>               (<code>Bool[Array, 'p J']</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>values</code>               (<code>Float[Array, 'p J']</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>add</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> <li> <code>resize</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>mask</code>               (<code>Bool[Array, 'p J']</code>)           \u2013            </li> <li> <code>values</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.DirichletBuilder.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dim: int = field(default=3)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.DirichletBuilder.mask","title":"mask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mask: Bool[Array, \"p J\"] = field(\n    default=Factory(_default_mask, takes_self=True)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.DirichletBuilder.values","title":"values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>values: Float[Array, \"p J\"] = field(\n    default=Factory(_default_values, takes_self=True)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.DirichletBuilder.add","title":"add","text":"<pre><code>add(mesh: DataSet) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet_builder.py</code> <pre><code>def add(self, mesh: pv.DataSet) -&gt; None:\n    point_ids: Integer[Array, \" p\"] = math.asarray(\n        mesh.point_data[\"point-ids\"], dtype=int\n    )\n    dirichlet_mask: Bool[Array, \"p J\"] = _broadcast_to(\n        mesh.point_data[\"dirichlet-mask\"], dtype=bool, shape=mesh.points.shape\n    )\n    dirichlet_values: Float[Array, \"p J\"] = _broadcast_to(\n        mesh.point_data[\"dirichlet-values\"], dtype=float, shape=mesh.points.shape\n    )\n    self.mask = self.mask.at[point_ids].set(dirichlet_mask)\n    self.values = self.values.at[point_ids].set(dirichlet_values)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.DirichletBuilder.finish","title":"finish","text":"<pre><code>finish() -&gt; Dirichlet\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet_builder.py</code> <pre><code>def finish(self) -&gt; Dirichlet:\n    mask_flat: Bool[Array, \" N\"] = self.mask.flatten()\n    index: Integer[Array, \" dirichlet\"]\n    (index,) = jnp.nonzero(mask_flat)\n    index_free: Integer[Array, \" free\"]\n    (index_free,) = jnp.nonzero(~mask_flat)\n    return Dirichlet(\n        index=index,\n        index_free=index_free,\n        n_dofs=self.mask.size,\n        values=self.values.flatten()[index],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.DirichletBuilder.resize","title":"resize","text":"<pre><code>resize(n_points: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet_builder.py</code> <pre><code>def resize(self, n_points: int) -&gt; None:\n    if n_points &lt;= self.mask.shape[0]:\n        return\n    pad_width: tuple[tuple[int, int], tuple[int, int]] = (\n        (0, n_points - self.mask.shape[0]),\n        (0, 0),\n    )\n    self.mask = jnp.pad(self.mask, pad_width)\n    self.values = jnp.pad(self.values, pad_width)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic","title":"Elastic","text":"<p>               Bases: <code>Energy</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>def energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(region=region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Elastic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element","title":"Element","text":"<p>Base-class for a finite element which provides methods for plotting.</p> References <ol> <li>felupe.Element</li> </ol> <p>Methods:</p> <ul> <li> <code>function</code>             \u2013              <p>Return the shape functions at given coordinates.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>hessian</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>Integer[Array, ' points']</code>)           \u2013            </li> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'points dim']</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element.cells","title":"cells  <code>property</code>","text":"<pre><code>cells: Integer[Array, ' points']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element.dim","title":"dim  <code>property</code>","text":"<pre><code>dim: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element.points","title":"points  <code>property</code>","text":"<pre><code>points: Float[Array, 'points dim']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element.quadrature","title":"quadrature  <code>property</code>","text":"<pre><code>quadrature: Scheme\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element.function","title":"function","text":"<pre><code>function(\n    coords: Float[Array, \" dim\"],\n) -&gt; Float[Array, \" points\"]\n</code></pre> <p>Return the shape functions at given coordinates.</p> Source code in <code>src/liblaf/apple/jax/sim/element/_element.py</code> <pre><code>def function(self, coords: Float[Array, \" dim\"]) -&gt; Float[Array, \" points\"]:\n    \"\"\"Return the shape functions at given coordinates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element.gradient","title":"gradient","text":"<pre><code>gradient(\n    coords: Float[Array, \" dim\"],\n) -&gt; Float[Array, \"points dim\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/element/_element.py</code> <pre><code>def gradient(self, coords: Float[Array, \" dim\"]) -&gt; Float[Array, \"points dim\"]:\n    return jax.jacobian(self.function)(coords)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Element.hessian","title":"hessian","text":"<pre><code>hessian(\n    coords: Float[Array, \" dim\"],\n) -&gt; Float[Array, \"points dim dim\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/element/_element.py</code> <pre><code>def hessian(self, coords: Float[Array, \" dim\"]) -&gt; Float[Array, \"points dim dim\"]:\n    return jax.hessian(self.function)(coords)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra","title":"ElementTetra","text":"<p>               Bases: <code>Element</code></p> <p>Methods:</p> <ul> <li> <code>function</code>             \u2013              <p>Return the shape functions at given coordinates.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>hessian</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>Integer[Array, ' points']</code>)           \u2013            </li> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'points=4 dim=3']</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>QuadratureTetra</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra.cells","title":"cells  <code>property</code>","text":"<pre><code>cells: Integer[Array, ' points']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra.dim","title":"dim  <code>property</code>","text":"<pre><code>dim: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra.points","title":"points  <code>property</code>","text":"<pre><code>points: Float[Array, 'points=4 dim=3']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra.quadrature","title":"quadrature  <code>property</code>","text":"<pre><code>quadrature: QuadratureTetra\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra.function","title":"function","text":"<pre><code>function(\n    coords: Float[Array, \"dim=3\"],\n) -&gt; Float[Array, \"points=4\"]\n</code></pre> <p>Return the shape functions at given coordinates.</p> Source code in <code>src/liblaf/apple/jax/sim/element/_tetra.py</code> <pre><code>@override\ndef function(self, coords: Float[Array, \"dim=3\"]) -&gt; Float[Array, \"points=4\"]:\n    coords = jnp.asarray(coords)\n    r, s, t = coords\n    return jnp.asarray([1.0 - r - s - t, r, s, t], float)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra.gradient","title":"gradient","text":"<pre><code>gradient(\n    coords: Float[Array, \"dim=3\"],\n) -&gt; Float[Array, \"points=4 dim=3\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/element/_tetra.py</code> <pre><code>@override\ndef gradient(self, coords: Float[Array, \"dim=3\"]) -&gt; Float[Array, \"points=4 dim=3\"]:\n    with jax.ensure_compile_time_eval():\n        return jnp.asarray([[-1, -1, -1], [1, 0, 0], [0, 1, 0], [0, 0, 1]], float)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ElementTetra.hessian","title":"hessian","text":"<pre><code>hessian(\n    coords: Float[Array, \"dim=3\"],\n) -&gt; Float[Array, \"points=4 dim=3 dim=3\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/element/_tetra.py</code> <pre><code>@override\ndef hessian(\n    self, coords: Float[Array, \"dim=3\"]\n) -&gt; Float[Array, \"points=4 dim=3 dim=3\"]:\n    with jax.ensure_compile_time_eval():\n        return jnp.zeros((4, 3, 3), float)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy","title":"Energy","text":"<p>               Bases: <code>IdMixin</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun(self, u: Vector) -&gt; Scalar:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Energy.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry","title":"Geometry","text":"<p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.POINT: 0&gt;, data={})</code> )           \u2013            </li> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.CELL: 1&gt;, data={})</code> )           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.NONE: 2&gt;, data={})</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>copy_attributes</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>cells_global</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>element</code>               (<code>Element</code>)           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>point_ids</code>               (<code>Integer[Array, ' p']</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.cell_data","title":"cell_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cell_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=CELL)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: Integer[Array, 'c a'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.cells_global","title":"cells_global  <code>property</code>","text":"<pre><code>cells_global: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.element","title":"element  <code>property</code>","text":"<pre><code>element: Element\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.field_data","title":"field_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=NONE)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.point_data","title":"point_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=POINT)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.point_ids","title":"point_ids  <code>property</code>","text":"<pre><code>point_ids: Integer[Array, ' p']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, 'p J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.copy_attributes","title":"copy_attributes","text":"<pre><code>copy_attributes(other: Self | DataObject) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_geometry.py</code> <pre><code>def copy_attributes(self, other: Self | pv.DataObject) -&gt; None:\n    self.point_data.update(as_array_dict(other.point_data))\n    self.cell_data.update(as_array_dict(other.cell_data))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Geometry.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(mesh: DataObject) -&gt; Geometry\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_geometry.py</code> <pre><code>@classmethod\ndef from_pyvista(cls, mesh: pv.DataObject) -&gt; \"Geometry\":\n    from ._tetra import GeometryTetra\n    from ._triangle import GeometryTriangle\n\n    if isinstance(mesh, pv.PolyData):\n        return GeometryTriangle.from_pyvista(mesh)\n    if isinstance(mesh, pv.UnstructuredGrid):\n        return GeometryTetra.from_pyvista(mesh)\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryAttributes","title":"GeometryAttributes","text":"<p>               Bases: <code>MutableMapping[str, Array]</code></p> <p>Parameters:</p> <ul> <li> <code>association</code>               (<code>FieldAssociation</code>)           \u2013            </li> <li> <code>data</code>               (<code>dict[str, Array]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__delitem__</code>             \u2013              </li> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__iter__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>__setitem__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>association</code>               (<code>FieldAssociation</code>)           \u2013            </li> <li> <code>data</code>               (<code>dict[str, Array]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryAttributes.association","title":"association  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>association: FieldAssociation = field()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryAttributes.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: dict[str, Array] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryAttributes.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __delitem__(self, key: str) -&gt; None:\n    del self.data[key]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryAttributes.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; Array\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __getitem__(self, key: str, /) -&gt; Array:\n    return self.data[key]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryAttributes.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[str]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n    yield from self.data\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryAttributes.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryAttributes.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: str, value: Array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __setitem__(self, key: str, value: Array, /) -&gt; None:\n    self.data[key] = value\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra","title":"GeometryTetra","text":"<p>               Bases: <code>Geometry</code></p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.POINT: 0&gt;, data={})</code> )           \u2013            </li> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.CELL: 1&gt;, data={})</code> )           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.NONE: 2&gt;, data={})</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>copy_attributes</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>cells_global</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>element</code>               (<code>ElementTetra</code>)           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>point_ids</code>               (<code>Integer[Array, ' p']</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.cell_data","title":"cell_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cell_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=CELL)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: Integer[Array, 'c a'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.cells_global","title":"cells_global  <code>property</code>","text":"<pre><code>cells_global: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.element","title":"element  <code>property</code>","text":"<pre><code>element: ElementTetra\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.field_data","title":"field_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=NONE)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.point_data","title":"point_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=POINT)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.point_ids","title":"point_ids  <code>property</code>","text":"<pre><code>point_ids: Integer[Array, ' p']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, 'p J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.copy_attributes","title":"copy_attributes","text":"<pre><code>copy_attributes(other: Self | DataObject) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_geometry.py</code> <pre><code>def copy_attributes(self, other: Self | pv.DataObject) -&gt; None:\n    self.point_data.update(as_array_dict(other.point_data))\n    self.cell_data.update(as_array_dict(other.cell_data))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTetra.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(mesh: UnstructuredGrid) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_tetra.py</code> <pre><code>@override\n@classmethod\ndef from_pyvista(cls, mesh: pv.UnstructuredGrid) -&gt; Self:  # pyright: ignore[reportIncompatibleMethodOverride]\n    points: Float[Array, \"p J\"] = math.asarray(mesh.points, float_)\n    cells: Integer[Array, \"c a\"] = math.asarray(\n        mesh.cells_dict[pv.CellType.TETRA],  # pyright: ignore[reportArgumentType]\n        int_,\n    )\n    self: Self = cls(points=points, cells=cells)\n    self.copy_attributes(mesh)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle","title":"GeometryTriangle","text":"<p>               Bases: <code>Geometry</code></p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.POINT: 0&gt;, data={})</code> )           \u2013            </li> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.CELL: 1&gt;, data={})</code> )           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.NONE: 2&gt;, data={})</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>copy_attributes</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>cells_global</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>element</code>               (<code>Element</code>)           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>point_ids</code>               (<code>Integer[Array, ' p']</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.cell_data","title":"cell_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cell_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=CELL)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: Integer[Array, 'c a'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.cells_global","title":"cells_global  <code>property</code>","text":"<pre><code>cells_global: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.element","title":"element  <code>property</code>","text":"<pre><code>element: Element\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.field_data","title":"field_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=NONE)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.point_data","title":"point_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=POINT)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.point_ids","title":"point_ids  <code>property</code>","text":"<pre><code>point_ids: Integer[Array, ' p']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, 'p J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.copy_attributes","title":"copy_attributes","text":"<pre><code>copy_attributes(other: Self | DataObject) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_geometry.py</code> <pre><code>def copy_attributes(self, other: Self | pv.DataObject) -&gt; None:\n    self.point_data.update(as_array_dict(other.point_data))\n    self.cell_data.update(as_array_dict(other.cell_data))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.GeometryTriangle.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(mesh: PolyData) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_triangle.py</code> <pre><code>@override\n@classmethod\ndef from_pyvista(cls, mesh: pv.PolyData) -&gt; Self:  # pyright: ignore[reportIncompatibleMethodOverride]\n    mesh = mesh.triangulate()  # pyright: ignore[reportAssignmentType]\n    points: Float[Array, \"p J\"] = math.asarray(mesh.points, float_)\n    cells: Integer[Array, \"c a\"] = math.asarray(mesh.regular_faces, int_)\n    self: Self = cls(points=points, cells=cells)\n    self.copy_attributes(mesh)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter","title":"Koiter","text":"<p>               Bases: <code>Energy</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>alpha</code>               (<code>Float[Array, c]</code>)           \u2013            <p>Lam\u00e9\u2019s first parameter.</p> </li> <li> <code>beta</code>               (<code>Float[Array, c]</code>)           \u2013            <p>Lam\u00e9\u2019s second parameter.</p> </li> <li> <code>det_Iu</code>               (<code>Float[Array, c]</code>)           \u2013            <p>det(Iu).</p> </li> <li> <code>h</code>               (<code>Float[Array, c]</code>)           \u2013            <p>Thickness.</p> </li> <li> <code>Iu_inv</code>               (<code>Float[Array, 'c 2 2']</code>)           \u2013            <p>Inverse of the midsurface first fundamental form.</p> </li> <li> <code>pre_strain</code>               (<code>Float[Array, c]</code>)           \u2013            </li> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>Iu_inv</code>               (<code>Float[Array, 'c 2 2']</code>)           \u2013            <p>Inverse of the midsurface first fundamental form.</p> </li> <li> <code>alpha</code>               (<code>Float[Array, ' c']</code>)           \u2013            <p>Lam\u00e9\u2019s first parameter.</p> </li> <li> <code>beta</code>               (<code>Float[Array, ' c']</code>)           \u2013            <p>Lam\u00e9\u2019s second parameter.</p> </li> <li> <code>det_Iu</code>               (<code>Float[Array, ' c']</code>)           \u2013            <p>det(Iu).</p> </li> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            </li> <li> <code>h</code>               (<code>Float[Array, ' c']</code>)           \u2013            <p>Thickness.</p> </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>pre_strain</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.Iu_inv","title":"Iu_inv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Iu_inv: Float[Array, 'c 2 2'] = array()\n</code></pre> <p>Inverse of the midsurface first fundamental form.</p>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Float[Array, ' c'] = array()\n</code></pre> <p>Lam\u00e9\u2019s first parameter.</p>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.beta","title":"beta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>beta: Float[Array, ' c'] = array()\n</code></pre> <p>Lam\u00e9\u2019s second parameter.</p>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.det_Iu","title":"det_Iu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>det_Iu: Float[Array, ' c'] = array()\n</code></pre> <p>det(Iu).</p>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.geometry","title":"geometry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>geometry: Geometry = field()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.h","title":"h  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>h: Float[Array, ' c'] = array()\n</code></pre> <p>Thickness.</p>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.pre_strain","title":"pre_strain  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pre_strain: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(geometry: Geometry) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_koiter.py</code> <pre><code>@classmethod\ndef from_geometry(cls, geometry: Geometry) -&gt; Self:\n    alpha: Float[Array, \" c\"] = math.asarray(\n        geometry.cell_data[\"alpha\"], dtype=float\n    )\n    beta: Float[Array, \" c\"] = math.asarray(geometry.cell_data[\"beta\"], dtype=float)\n    h: Float[Array, \" c\"] = math.asarray(geometry.cell_data[\"h\"], dtype=float)\n    Iu: Float[Array, \"c 2 2\"] = _first_fundamental_form(\n        geometry.points[geometry.cells_global]\n    )\n    pre_strain: Float[Array, \" c\"] = math.asarray(\n        geometry.cell_data[\"pre-strain\"], dtype=float\n    )\n    self: Self = cls(\n        alpha=alpha,\n        beta=beta,\n        det_Iu=jnp.linalg.det(Iu),\n        Iu_inv=jnp.linalg.inv(Iu),\n        h=h,\n        pre_strain=pre_strain,\n        geometry=geometry,\n    )\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_koiter.py</code> <pre><code>def fun(self, u: Vector) -&gt; Scalar:\n    I: Float[Array, \"c 2 2\"] = _first_fundamental_form(  # noqa: E741\n        u[self.geometry.cells_global]\n        + self.geometry.points[self.geometry.cells_global]\n    )\n    M: Float[Array, \"c 2 2\"] = (\n        jnp.matmul(self.Iu_inv, I)\n        - self.pre_strain[:, jnp.newaxis, jnp.newaxis]\n        * jnp.eye(2)[jnp.newaxis, ...]\n    )\n    Ws: Float[Array, \"\"] = self._norm_SV(M)\n    E: Float[Array, \" c\"] = 0.5 * (0.25 * self.h * Ws) * jnp.sqrt(self.det_Iu)\n    return jnp.sum(E)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Koiter.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model","title":"Model","text":"<p>Parameters:</p> <ul> <li> <code>energies</code>               (<code>Mapping[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>energies</code>               (<code>Mapping[str, Energy]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.energies","title":"energies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies: Mapping[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def fun(self, u: Vector) -&gt; Scalar:\n    if not self.energies:\n        return jnp.zeros((), u.dtype)\n    outputs: list[Scalar] = [energy.fun(u) for energy in self.energies.values()]\n    return jnp.sum(jnp.asarray(outputs))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Vector]:\n    if not self.energies:\n        return jnp.zeros((), u.dtype), jnp.zeros_like(u)\n    value_list: list[Scalar] = []\n    updates_data_list: list[UpdatesData] = []\n    updates_index_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        fun, (data, index) = energy.fun_and_jac(u)\n        value_list.append(fun)\n        updates_data_list.append(data)\n        updates_index_list.append(index)\n    fun: Scalar = jnp.sum(jnp.asarray(value_list))\n    jac: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_list),\n        jnp.concat(updates_index_list),\n        num_segments=u.shape[0],\n    )\n    return fun, jac\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Vector:\n    if not self.energies:\n        return jnp.zeros_like(u)\n    updates_data_list: list[UpdatesData] = []\n    updates_index_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.hess_diag(u)\n        updates_data_list.append(data)\n        updates_index_list.append(index)\n    hess_diag: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_list),\n        jnp.concat(updates_index_list),\n        num_segments=u.shape[0],\n    )\n    return hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Vector:\n    if not self.energies:\n        return jnp.zeros_like(u)\n    updates_data_list: list[UpdatesData] = []\n    updates_index_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.hess_prod(u, p)\n        updates_data_list.append(data)\n        updates_index_list.append(index)\n    hess_prod: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_list),\n        jnp.concat(updates_index_list),\n        num_segments=u.shape[0],\n    )\n    return hess_prod\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    if not self.energies:\n        return jnp.zeros((), u.dtype)\n    outputs: list[Scalar] = [\n        energy.hess_quad(u, p) for energy in self.energies.values()\n    ]\n    return jnp.sum(jnp.asarray(outputs))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def jac(self, u: Vector) -&gt; Vector:\n    if not self.energies:\n        return jnp.zeros_like(u)\n    updates_data_list: list[UpdatesData] = []\n    updates_index_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.jac(u)\n        updates_data_list.append(data)\n        updates_index_list.append(index)\n    jac: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_list),\n        jnp.concat(updates_index_list),\n        num_segments=u.shape[0],\n    )\n    return jac\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Vector, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Vector, Vector]:\n    if not self.energies:\n        return jnp.zeros_like(u), jnp.zeros_like(u)\n    updates_data_jac_list: list[UpdatesData] = []\n    updates_index_jac_list: list[UpdatesIndex] = []\n    updates_data_hess_list: list[UpdatesData] = []\n    updates_index_hess_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        (data_jac, index_jac), (data_hess, index_hess) = energy.jac_and_hess_diag(u)\n        updates_data_jac_list.append(data_jac)\n        updates_index_jac_list.append(index_jac)\n        updates_data_hess_list.append(data_hess)\n        updates_index_hess_list.append(index_hess)\n    jac: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_jac_list),\n        jnp.concat(updates_index_jac_list),\n        num_segments=u.shape[0],\n    )\n    hess_diag: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_hess_list),\n        jnp.concat(updates_index_hess_list),\n        num_segments=u.shape[0],\n    )\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Model.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, dict[str, Array]]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def mixed_derivative_prod(\n    self, u: Vector, p: Vector\n) -&gt; dict[str, dict[str, Array]]:\n    outputs: dict[str, dict[str, Array]] = {\n        energy.id: energy.mixed_derivative_prod(u, p)\n        for energy in self.energies.values()\n    }\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder","title":"ModelBuilder","text":"<p>Parameters:</p> <ul> <li> <code>dirichlet</code>               (<code>DirichletBuilder</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>energies</code>               (<code>dict[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>, default:                   <code>Array([], shape=(0, 3), dtype=float32)</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>add_dirichlet</code>             \u2013              </li> <li> <code>add_energy</code>             \u2013              </li> <li> <code>assign_dofs</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dirichlet</code>               (<code>DirichletBuilder</code>)           \u2013            </li> <li> <code>energies</code>               (<code>dict[str, Energy]</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder.dirichlet","title":"dirichlet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirichlet: DirichletBuilder = field(\n    factory=DirichletBuilder\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder.energies","title":"energies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies: dict[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, \"p J\"] = array(factory=_default_points)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder.add_dirichlet","title":"add_dirichlet","text":"<pre><code>add_dirichlet(mesh: DataSet) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model_builder.py</code> <pre><code>def add_dirichlet(self, mesh: pv.DataSet) -&gt; None:\n    self.dirichlet.add(mesh)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder.add_energy","title":"add_energy","text":"<pre><code>add_energy(energy: Energy) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model_builder.py</code> <pre><code>def add_energy(self, energy: Energy) -&gt; None:\n    self.energies[energy.id] = energy\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder.assign_dofs","title":"assign_dofs","text":"<pre><code>assign_dofs(mesh: T) -&gt; T\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model_builder.py</code> <pre><code>def assign_dofs[T: pv.DataSet](self, mesh: T) -&gt; T:\n    mesh.point_data[\"point-ids\"] = np.arange(\n        self.n_points, self.n_points + mesh.n_points\n    )\n    self.points = jnp.concat([self.points, mesh.points])\n    self.dirichlet.resize(self.n_points)\n    return mesh\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.ModelBuilder.finish","title":"finish","text":"<pre><code>finish() -&gt; Model\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model_builder.py</code> <pre><code>def finish(self) -&gt; Model:\n    return Model(energies=self.energies)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive","title":"PhaceActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>activation</code>               (<code>Float[Array, 'c J J']</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, c]</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> <li> <code>mixed_derivative_prod_activation</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>Float[Array, 'c J J']</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.activation","title":"activation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>activation: Float[Array, 'c J J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.lambda_","title":"lambda_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lambda_: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    A: Float[Array, \" c #q J J\"] = utils.make_activation(self.activation)[\n        :, jnp.newaxis, :, :\n    ]\n    lambda_: Float[Array, \" c #q\"] = self.lambda_[:, jnp.newaxis]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    J: Float[Array, \"c q\"] = jnp.linalg.det(F)\n    Psi_ARAP: Float[Array, \"c q\"] = mu * math.fro_norm_square(F - R @ A)\n    Psi_volume_preserving: Float[Array, \"c q\"] = lambda_ * (J - 1.0) ** 2\n    Psi: Float[Array, \"c q\"] = Psi_ARAP + Psi_volume_preserving\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>@override\n@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        activation=region.cell_data[\"activation\"],\n        lambda_=region.cell_data[\"lambda\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceActive.mixed_derivative_prod_activation","title":"mixed_derivative_prod_activation","text":"<pre><code>mixed_derivative_prod_activation(\n    u: Vector, p: Vector\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>def mixed_derivative_prod_activation(self, u: Vector, p: Vector) -&gt; Vector:\n    def jac(q: Float[Array, \"c 6\"]) -&gt; Vector:\n        energy: Self = attrs.evolve(self, activation=q)\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.jac(u)\n        jac: Vector = jax.ops.segment_sum(data, index, num_segments=u.shape[0])\n        return jac\n\n    vjp: Callable[[Vector], Float[Array, \"c 6\"]]\n    _, vjp = jax.vjp(jac, self.activation)\n\n    output: Float[Array, \"c 6\"]\n    (output,) = vjp(p)\n    return output\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic","title":"PhaceStatic","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.lambda_","title":"lambda_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lambda_: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_static.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    lambda_: Float[Array, \" c #q\"] = self.lambda_[:, jnp.newaxis]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    J: Float[Array, \"c q\"] = jnp.linalg.det(F)\n    Psi_ARAP: Float[Array, \"c q\"] = mu * math.fro_norm_square(F - R)\n    Psi_volume_preserving: Float[Array, \"c q\"] = lambda_ * (J - 1.0) ** 2\n    Psi: Float[Array, \"c q\"] = 2.0 * Psi_ARAP + Psi_volume_preserving\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_static.py</code> <pre><code>@override\n@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        lambda_=region.cell_data[\"lambda\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.PhaceStatic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.QuadratureTetra","title":"QuadratureTetra","text":"<p>               Bases: <code>Scheme</code></p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'q=1 J=3']</code>, default:                   <code>Array([[0.25, 0.25, 0.25]], dtype=float32)</code> )           \u2013            </li> <li> <code>weights</code>               (<code>Float[Array, 'q=1']</code>, default:                   <code>Array([0.16666667], dtype=float32)</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_felupe</code>             \u2013              </li> <li> <code>from_order</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'q=1 J=3']</code>)           \u2013            </li> <li> <code>weights</code>               (<code>Float[Array, 'q=1']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.QuadratureTetra.dim","title":"dim  <code>property</code>","text":"<pre><code>dim: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.QuadratureTetra.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.QuadratureTetra.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, \"q=1 J=3\"] = array(\n    factory=_default_points\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.QuadratureTetra.weights","title":"weights  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weights: Float[Array, \"q=1\"] = array(\n    factory=_default_weights\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.QuadratureTetra.from_felupe","title":"from_felupe  <code>classmethod</code>","text":"<pre><code>from_felupe(scheme: Scheme) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/quadrature/_scheme.py</code> <pre><code>@classmethod\ndef from_felupe(cls, scheme: felupe.quadrature.Scheme) -&gt; Self:\n    with jax.ensure_compile_time_eval():\n        return cls(\n            points=math.asarray(scheme.points), weights=math.asarray(scheme.weights)\n        )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.QuadratureTetra.from_order","title":"from_order  <code>classmethod</code>","text":"<pre><code>from_order(order: int = 1) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/quadrature/_tetra.py</code> <pre><code>@classmethod\ndef from_order(cls, order: int = 1) -&gt; Self:\n    with jax.ensure_compile_time_eval():\n        return cls.from_felupe(felupe.quadrature.Tetrahedron(order=order))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region","title":"Region","text":"<p>Parameters:</p> <ul> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>h</code>               (<code>Float[Array, 'q a']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdr</code>               (<code>Float[Array, 'q a J']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dXdr</code>               (<code>Float[Array, 'c q J J']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>drdX</code>               (<code>Float[Array, 'c q J J']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>Float[Array, 'c q']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>Float[Array, 'c q a J']</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>compute_grad</code>             \u2013              </li> <li> <code>deformation_gradient</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>integrate</code>             \u2013              </li> <li> <code>scatter</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>cells_global</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>dV</code>               (<code>Float[Array, 'c q']</code>)           \u2013            </li> <li> <code>dXdr</code>               (<code>Float[Array, 'c q J J']</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>Float[Array, 'c q a J']</code>)           \u2013            </li> <li> <code>dhdr</code>               (<code>Float[Array, 'q a J']</code>)           \u2013            </li> <li> <code>drdX</code>               (<code>Float[Array, 'c q J J']</code>)           \u2013            </li> <li> <code>element</code>               (<code>Element</code>)           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            </li> <li> <code>h</code>               (<code>Float[Array, 'q a']</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.cell_data","title":"cell_data  <code>property</code>","text":"<pre><code>cell_data: GeometryAttributes\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.cells","title":"cells  <code>property</code>","text":"<pre><code>cells: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.cells_global","title":"cells_global  <code>property</code>","text":"<pre><code>cells_global: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: Float[Array, 'c q'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.dXdr","title":"dXdr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dXdr: Float[Array, 'c q J J'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: Float[Array, 'c q a J'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.dhdr","title":"dhdr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdr: Float[Array, 'q a J'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.drdX","title":"drdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>drdX: Float[Array, 'c q J J'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.element","title":"element  <code>property</code>","text":"<pre><code>element: Element\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.field_data","title":"field_data  <code>property</code>","text":"<pre><code>field_data: GeometryAttributes\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.geometry","title":"geometry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>geometry: Geometry = field()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.h","title":"h  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>h: Float[Array, 'q a'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.point_data","title":"point_data  <code>property</code>","text":"<pre><code>point_data: GeometryAttributes\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.points","title":"points  <code>property</code>","text":"<pre><code>points: Float[Array, 'p J']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.compute_grad","title":"compute_grad","text":"<pre><code>compute_grad() -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def compute_grad(self) -&gt; None:\n    h: Float[Array, \"q a\"] = jnp.stack(\n        [self.element.function(q) for q in self.quadrature.points]\n    )\n    dhdr: Float[Array, \"q a J\"] = jnp.stack(\n        [self.element.gradient(q) for q in self.quadrature.points]\n    )\n    dXdr: Float[Array, \"c q J J\"] = einops.einsum(\n        self.points[self.cells], dhdr, \"c a I, q a J -&gt; c q I J\"\n    )\n    drdX: Float[Array, \"c q J J\"] = jnp.linalg.inv(dXdr)\n    dV: Float[Array, \"c q\"] = (\n        jnp.linalg.det(dXdr) * self.quadrature.weights[jnp.newaxis, :]\n    )\n    if jnp.any(dV &lt;= 0):\n        logger.warning(\"dV &lt;= 0\")\n    dhdX: Float[Array, \"c q a J\"] = einops.einsum(\n        dhdr, drdX, \"q a I, c q I J -&gt; c q a J\"\n    )\n    self.h = h\n    self.dhdr = dhdr\n    self.dXdr = dXdr\n    self.drdX = drdX\n    self.dV = dV\n    self.dhdX = dhdX\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.deformation_gradient","title":"deformation_gradient","text":"<pre><code>deformation_gradient(\n    u: Float[Array, \"p J\"],\n) -&gt; Float[Array, \"c q J J\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def deformation_gradient(self, u: Float[Array, \"p J\"]) -&gt; Float[Array, \"c q J J\"]:\n    grad: Float[Array, \"c q J J\"] = self.gradient(u)\n    F: Float[Array, \"c q J J\"] = (\n        grad + jnp.identity(3)[jnp.newaxis, jnp.newaxis, ...]\n    )\n    return F\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    grad: bool = False,\n    quadrature: Scheme | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, grad: bool = False, quadrature: Scheme | None = None\n) -&gt; Self:\n    if quadrature is None:\n        quadrature = geometry.element.quadrature\n    self: Self = cls(geometry=geometry, quadrature=quadrature)\n    if grad:\n        self.compute_grad()\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: DataObject,\n    *,\n    grad: bool = False,\n    quadrature: Scheme | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls,\n    mesh: pv.DataObject,\n    *,\n    grad: bool = False,\n    quadrature: Scheme | None = None,\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    self: Self = cls.from_geometry(geometry, grad=grad, quadrature=quadrature)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.gradient","title":"gradient","text":"<pre><code>gradient(\n    u: Float[Array, \" points *shape\"],\n) -&gt; Float[Array, \"c q *shape J\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def gradient(\n    self, u: Float[Array, \" points *shape\"]\n) -&gt; Float[Array, \"c q *shape J\"]:\n    result: Float[Array, \"c q *shape J\"] = einops.einsum(\n        self.scatter(u), self.dhdX, \"c a ..., c q a J -&gt; c q ... J\"\n    )\n    return result\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.integrate","title":"integrate","text":"<pre><code>integrate(\n    a: Float[Array, \"c q *shape\"],\n) -&gt; Float[Array, \" c *shape\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def integrate(self, a: Float[Array, \"c q *shape\"]) -&gt; Float[Array, \" c *shape\"]:\n    return einops.einsum(a, self.dV, \"c q ..., c q -&gt; c ...\")\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Region.scatter","title":"scatter","text":"<pre><code>scatter(\n    u: Float[Array, \" points *shape\"],\n) -&gt; Float[Array, \"c a *shape\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def scatter(self, u: Float[Array, \" points *shape\"]) -&gt; Float[Array, \"c a *shape\"]:\n    return u[self.cells_global]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Scheme","title":"Scheme","text":"<p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'q J']</code>)           \u2013            </li> <li> <code>weights</code>               (<code>Float[Array, q]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_felupe</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'q J']</code>)           \u2013            </li> <li> <code>weights</code>               (<code>Float[Array, ' q']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Scheme.dim","title":"dim  <code>property</code>","text":"<pre><code>dim: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Scheme.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Scheme.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, 'q J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Scheme.weights","title":"weights  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weights: Float[Array, ' q'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.Scheme.from_felupe","title":"from_felupe  <code>classmethod</code>","text":"<pre><code>from_felupe(scheme: Scheme) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/quadrature/_scheme.py</code> <pre><code>@classmethod\ndef from_felupe(cls, scheme: felupe.quadrature.Scheme) -&gt; Self:\n    with jax.ensure_compile_time_eval():\n        return cls(\n            points=math.asarray(scheme.points), weights=math.asarray(scheme.weights)\n        )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.make_activation","title":"make_activation","text":"<pre><code>make_activation(\n    activation: Float[Array, \"c 6\"],\n) -&gt; Float[Array, \"c 3 3\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def make_activation(activation: Float[Array, \"c 6\"]) -&gt; Float[Array, \"c 3 3\"]:\n    n_cells: int = activation.shape[0]\n    A: Float[Array, \"c 3 3\"] = jnp.empty((n_cells, 3, 3), activation.dtype)\n    A = A.at[:, 0, 0].set(activation[:, 0])\n    A = A.at[:, 1, 1].set(activation[:, 1])\n    A = A.at[:, 2, 2].set(activation[:, 2])\n    A = A.at[:, 0, 1].set(activation[:, 3])\n    A = A.at[:, 0, 2].set(activation[:, 4])\n    A = A.at[:, 1, 2].set(activation[:, 5])\n    A = A.at[:, 1, 0].set(activation[:, 3])\n    A = A.at[:, 2, 0].set(activation[:, 4])\n    A = A.at[:, 2, 1].set(activation[:, 5])\n    # A += jnp.identity(3, activation.dtype)\n    return A\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.rest_activation","title":"rest_activation","text":"<pre><code>rest_activation(\n    n_cells: int = 1, dtype: DTypeLike = float\n) -&gt; Float[Array, \"c 6\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def rest_activation(n_cells: int = 1, dtype: DTypeLike = float) -&gt; Float[Array, \"c 6\"]:\n    activation: Float[Array, \"c 6\"] = jnp.zeros((n_cells, 6), dtype)\n    activation = activation.at[:, 0].set(1.0)\n    activation = activation.at[:, 1].set(1.0)\n    activation = activation.at[:, 2].set(1.0)\n    return activation\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/#liblaf.apple.jax.sim.transform_activation","title":"transform_activation","text":"<pre><code>transform_activation(\n    activation: Float[Array, \"#c 6\"],\n    orientation: Float[Array, \"#c 3 3\"],\n    *,\n    inverse: bool = False,\n) -&gt; Float[Array, \"c 6\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def transform_activation(\n    activation: Float[Array, \"#c 6\"],\n    orientation: Float[Array, \"#c 3 3\"],\n    *,\n    inverse: bool = False,\n) -&gt; Float[Array, \"c 6\"]:\n    activation_mat: Float[Array, \"c 3 3\"] = make_activation(activation)\n    if inverse:\n        orientation = orientation.mT\n    transformed_mat: Float[Array, \"c 3 3\"] = (\n        orientation.mT @ activation_mat @ orientation\n    )\n    n_cells: int = transformed_mat.shape[0]\n    transformed: Float[Array, \"c 6\"] = jnp.empty((n_cells, 6), activation.dtype)\n    transformed = transformed.at[:, 0].set(transformed_mat[:, 0, 0])\n    transformed = transformed.at[:, 1].set(transformed_mat[:, 1, 1])\n    transformed = transformed.at[:, 2].set(transformed_mat[:, 2, 2])\n    transformed = transformed.at[:, 3].set(transformed_mat[:, 0, 1])\n    transformed = transformed.at[:, 4].set(transformed_mat[:, 0, 2])\n    transformed = transformed.at[:, 5].set(transformed_mat[:, 1, 2])\n    return transformed\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/","title":"dirichlet","text":""},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet","title":"liblaf.apple.jax.sim.dirichlet","text":"<p>Classes:</p> <ul> <li> <code>Dirichlet</code>           \u2013            </li> <li> <code>DirichletBuilder</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet","title":"Dirichlet","text":"<p>Parameters:</p> <ul> <li> <code>n_dofs</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            </li> <li> <code>index</code>               (<code>Integer[Array, dirichlet]</code>, default:                   <code>Array([], shape=(0,), dtype=int32)</code> )           \u2013            </li> <li> <code>index_free</code>               (<code>Integer[Array, free]</code>, default:                   <code>Array([], shape=(0,), dtype=int32)</code> )           \u2013            </li> <li> <code>values</code>               (<code>Float[Array, dirichlet]</code>, default:                   <code>Array([], shape=(0,), dtype=float32)</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>apply</code>             \u2013              </li> <li> <code>get</code>             \u2013              </li> <li> <code>get_free</code>             \u2013              </li> <li> <code>mask</code>             \u2013              </li> <li> <code>set</code>             \u2013              </li> <li> <code>set_free</code>             \u2013              </li> <li> <code>zero</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>index</code>               (<code>Integer[Array, ' dirichlet']</code>)           \u2013            </li> <li> <code>index_free</code>               (<code>Integer[Array, ' free']</code>)           \u2013            </li> <li> <code>n_dirichlet</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_dofs</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_free</code>               (<code>int</code>)           \u2013            </li> <li> <code>values</code>               (<code>Float[Array, ' dirichlet']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: Integer[Array, \" dirichlet\"] = array(\n    factory=_default_index\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.index_free","title":"index_free  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index_free: Integer[Array, \" free\"] = array(\n    factory=_default_index\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.n_dirichlet","title":"n_dirichlet  <code>property</code>","text":"<pre><code>n_dirichlet: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.n_dofs","title":"n_dofs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_dofs: int = field(default=0)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.n_free","title":"n_free  <code>property</code>","text":"<pre><code>n_free: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.values","title":"values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>values: Float[Array, \" dirichlet\"] = array(\n    factory=_default_values\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.apply","title":"apply","text":"<pre><code>apply(x: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def apply(self, x: Vector) -&gt; Vector:\n    return self.set(x, self.values)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.get","title":"get","text":"<pre><code>get(x: Vector) -&gt; Float[Array, ' dirichlet']\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def get(self, x: Vector) -&gt; Float[Array, \" dirichlet\"]:\n    x_flat: Array = x.flatten()\n    return x_flat[self.index]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.get_free","title":"get_free","text":"<pre><code>get_free(x: Vector) -&gt; Float[Array, ' free']\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def get_free(self, x: Vector) -&gt; Float[Array, \" free\"]:\n    x_flat: Array = x.flatten()\n    return x_flat[self.index_free]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.mask","title":"mask","text":"<pre><code>mask(x: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def mask(self, x: Vector) -&gt; Vector:\n    return self.set(x, True)  # noqa: FBT003\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.set","title":"set","text":"<pre><code>set(x: Vector, values: ArrayLike) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def set(self, x: Vector, values: ArrayLike) -&gt; Vector:\n    x_flat: Array = x.flatten()\n    y_flat: Array = x_flat.at[self.index].set(values)\n    return y_flat.reshape(x.shape)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.set_free","title":"set_free","text":"<pre><code>set_free(x: Vector, values: ArrayLike) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def set_free(self, x: Vector, values: ArrayLike) -&gt; Vector:\n    x_flat: Array = x.flatten()\n    y_flat: Array = x_flat.at[self.index_free].set(values)\n    return y_flat.reshape(x.shape)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.Dirichlet.zero","title":"zero","text":"<pre><code>zero(x: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet.py</code> <pre><code>def zero(self, x: Vector) -&gt; Vector:\n    return self.set(x, 0.0)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.DirichletBuilder","title":"DirichletBuilder","text":"<p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            </li> <li> <code>mask</code>               (<code>Bool[Array, 'p J']</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>values</code>               (<code>Float[Array, 'p J']</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>add</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> <li> <code>resize</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>mask</code>               (<code>Bool[Array, 'p J']</code>)           \u2013            </li> <li> <code>values</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.DirichletBuilder.dim","title":"dim  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dim: int = field(default=3)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.DirichletBuilder.mask","title":"mask  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mask: Bool[Array, \"p J\"] = field(\n    default=Factory(_default_mask, takes_self=True)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.DirichletBuilder.values","title":"values  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>values: Float[Array, \"p J\"] = field(\n    default=Factory(_default_values, takes_self=True)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.DirichletBuilder.add","title":"add","text":"<pre><code>add(mesh: DataSet) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet_builder.py</code> <pre><code>def add(self, mesh: pv.DataSet) -&gt; None:\n    point_ids: Integer[Array, \" p\"] = math.asarray(\n        mesh.point_data[\"point-ids\"], dtype=int\n    )\n    dirichlet_mask: Bool[Array, \"p J\"] = _broadcast_to(\n        mesh.point_data[\"dirichlet-mask\"], dtype=bool, shape=mesh.points.shape\n    )\n    dirichlet_values: Float[Array, \"p J\"] = _broadcast_to(\n        mesh.point_data[\"dirichlet-values\"], dtype=float, shape=mesh.points.shape\n    )\n    self.mask = self.mask.at[point_ids].set(dirichlet_mask)\n    self.values = self.values.at[point_ids].set(dirichlet_values)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.DirichletBuilder.finish","title":"finish","text":"<pre><code>finish() -&gt; Dirichlet\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet_builder.py</code> <pre><code>def finish(self) -&gt; Dirichlet:\n    mask_flat: Bool[Array, \" N\"] = self.mask.flatten()\n    index: Integer[Array, \" dirichlet\"]\n    (index,) = jnp.nonzero(mask_flat)\n    index_free: Integer[Array, \" free\"]\n    (index_free,) = jnp.nonzero(~mask_flat)\n    return Dirichlet(\n        index=index,\n        index_free=index_free,\n        n_dofs=self.mask.size,\n        values=self.values.flatten()[index],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/dirichlet/#liblaf.apple.jax.sim.dirichlet.DirichletBuilder.resize","title":"resize","text":"<pre><code>resize(n_points: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/dirichlet/_dirichlet_builder.py</code> <pre><code>def resize(self, n_points: int) -&gt; None:\n    if n_points &lt;= self.mask.shape[0]:\n        return\n    pad_width: tuple[tuple[int, int], tuple[int, int]] = (\n        (0, n_points - self.mask.shape[0]),\n        (0, 0),\n    )\n    self.mask = jnp.pad(self.mask, pad_width)\n    self.values = jnp.pad(self.values, pad_width)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/","title":"element","text":""},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element","title":"liblaf.apple.jax.sim.element","text":"<p>Classes:</p> <ul> <li> <code>Element</code>           \u2013            <p>Base-class for a finite element which provides methods for plotting.</p> </li> <li> <code>ElementTetra</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element","title":"Element","text":"<p>Base-class for a finite element which provides methods for plotting.</p> References <ol> <li>felupe.Element</li> </ol> <p>Methods:</p> <ul> <li> <code>function</code>             \u2013              <p>Return the shape functions at given coordinates.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>hessian</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>Integer[Array, ' points']</code>)           \u2013            </li> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'points dim']</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element.cells","title":"cells  <code>property</code>","text":"<pre><code>cells: Integer[Array, ' points']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element.dim","title":"dim  <code>property</code>","text":"<pre><code>dim: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element.points","title":"points  <code>property</code>","text":"<pre><code>points: Float[Array, 'points dim']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element.quadrature","title":"quadrature  <code>property</code>","text":"<pre><code>quadrature: Scheme\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element.function","title":"function","text":"<pre><code>function(\n    coords: Float[Array, \" dim\"],\n) -&gt; Float[Array, \" points\"]\n</code></pre> <p>Return the shape functions at given coordinates.</p> Source code in <code>src/liblaf/apple/jax/sim/element/_element.py</code> <pre><code>def function(self, coords: Float[Array, \" dim\"]) -&gt; Float[Array, \" points\"]:\n    \"\"\"Return the shape functions at given coordinates.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element.gradient","title":"gradient","text":"<pre><code>gradient(\n    coords: Float[Array, \" dim\"],\n) -&gt; Float[Array, \"points dim\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/element/_element.py</code> <pre><code>def gradient(self, coords: Float[Array, \" dim\"]) -&gt; Float[Array, \"points dim\"]:\n    return jax.jacobian(self.function)(coords)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.Element.hessian","title":"hessian","text":"<pre><code>hessian(\n    coords: Float[Array, \" dim\"],\n) -&gt; Float[Array, \"points dim dim\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/element/_element.py</code> <pre><code>def hessian(self, coords: Float[Array, \" dim\"]) -&gt; Float[Array, \"points dim dim\"]:\n    return jax.hessian(self.function)(coords)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra","title":"ElementTetra","text":"<p>               Bases: <code>Element</code></p> <p>Methods:</p> <ul> <li> <code>function</code>             \u2013              <p>Return the shape functions at given coordinates.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>hessian</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>Integer[Array, ' points']</code>)           \u2013            </li> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'points=4 dim=3']</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>QuadratureTetra</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra.cells","title":"cells  <code>property</code>","text":"<pre><code>cells: Integer[Array, ' points']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra.dim","title":"dim  <code>property</code>","text":"<pre><code>dim: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra.points","title":"points  <code>property</code>","text":"<pre><code>points: Float[Array, 'points=4 dim=3']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra.quadrature","title":"quadrature  <code>property</code>","text":"<pre><code>quadrature: QuadratureTetra\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra.function","title":"function","text":"<pre><code>function(\n    coords: Float[Array, \"dim=3\"],\n) -&gt; Float[Array, \"points=4\"]\n</code></pre> <p>Return the shape functions at given coordinates.</p> Source code in <code>src/liblaf/apple/jax/sim/element/_tetra.py</code> <pre><code>@override\ndef function(self, coords: Float[Array, \"dim=3\"]) -&gt; Float[Array, \"points=4\"]:\n    coords = jnp.asarray(coords)\n    r, s, t = coords\n    return jnp.asarray([1.0 - r - s - t, r, s, t], float)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra.gradient","title":"gradient","text":"<pre><code>gradient(\n    coords: Float[Array, \"dim=3\"],\n) -&gt; Float[Array, \"points=4 dim=3\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/element/_tetra.py</code> <pre><code>@override\ndef gradient(self, coords: Float[Array, \"dim=3\"]) -&gt; Float[Array, \"points=4 dim=3\"]:\n    with jax.ensure_compile_time_eval():\n        return jnp.asarray([[-1, -1, -1], [1, 0, 0], [0, 1, 0], [0, 0, 1]], float)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/element/#liblaf.apple.jax.sim.element.ElementTetra.hessian","title":"hessian","text":"<pre><code>hessian(\n    coords: Float[Array, \"dim=3\"],\n) -&gt; Float[Array, \"points=4 dim=3 dim=3\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/element/_tetra.py</code> <pre><code>@override\ndef hessian(\n    self, coords: Float[Array, \"dim=3\"]\n) -&gt; Float[Array, \"points=4 dim=3 dim=3\"]:\n    with jax.ensure_compile_time_eval():\n        return jnp.zeros((4, 3, 3), float)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/","title":"energy","text":""},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy","title":"liblaf.apple.jax.sim.energy","text":"<p>Modules:</p> <ul> <li> <code>elastic</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>ARAP</code>           \u2013            </li> <li> <code>ARAPActive</code>           \u2013            </li> <li> <code>Elastic</code>           \u2013            </li> <li> <code>Energy</code>           \u2013            </li> <li> <code>Koiter</code>           \u2013            </li> <li> <code>PhaceActive</code>           \u2013            </li> <li> <code>PhaceStatic</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>make_activation</code>             \u2013              </li> <li> <code>rest_activation</code>             \u2013              </li> <li> <code>transform_activation</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP","title":"ARAP","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap.py</code> <pre><code>def energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    return 0.5 * mu * math.fro_norm_square(F - R)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(region=region, mu=region.cell_data[\"mu\"], **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAP.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive","title":"ARAPActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>activation</code>               (<code>Float[Array, 'c 6']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> <li> <code>mixed_derivative_prod_activation</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>Float[Array, 'c 6']</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.activation","title":"activation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>activation: Float[Array, 'c 6'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    A: Float[Array, \" c #q J J\"] = utils.make_activation(self.activation)[\n        :, jnp.newaxis, :, :\n    ]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    return mu * math.fro_norm_square(F - R @ A)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        activation=region.cell_data[\"activation\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.ARAPActive.mixed_derivative_prod_activation","title":"mixed_derivative_prod_activation","text":"<pre><code>mixed_derivative_prod_activation(\n    u: Vector, p: Vector\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>def mixed_derivative_prod_activation(self, u: Vector, p: Vector) -&gt; Vector:\n    def jac(q: Float[Array, \"c 6\"]) -&gt; Vector:\n        energy: Self = attrs.evolve(self, activation=q)\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.jac(u)\n        jac: Vector = jax.ops.segment_sum(data, index, num_segments=u.shape[0])\n        return jac\n\n    vjp: Callable[[Vector], Float[Array, \"c 6\"]]\n    _, vjp = jax.vjp(jac, self.activation)\n\n    output: Float[Array, \"c 6\"]\n    (output,) = vjp(p)\n    return output\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic","title":"Elastic","text":"<p>               Bases: <code>Energy</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>def energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(region=region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Elastic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy","title":"Energy","text":"<p>               Bases: <code>IdMixin</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun(self, u: Vector) -&gt; Scalar:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Energy.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter","title":"Koiter","text":"<p>               Bases: <code>Energy</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>alpha</code>               (<code>Float[Array, c]</code>)           \u2013            <p>Lam\u00e9\u2019s first parameter.</p> </li> <li> <code>beta</code>               (<code>Float[Array, c]</code>)           \u2013            <p>Lam\u00e9\u2019s second parameter.</p> </li> <li> <code>det_Iu</code>               (<code>Float[Array, c]</code>)           \u2013            <p>det(Iu).</p> </li> <li> <code>h</code>               (<code>Float[Array, c]</code>)           \u2013            <p>Thickness.</p> </li> <li> <code>Iu_inv</code>               (<code>Float[Array, 'c 2 2']</code>)           \u2013            <p>Inverse of the midsurface first fundamental form.</p> </li> <li> <code>pre_strain</code>               (<code>Float[Array, c]</code>)           \u2013            </li> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>Iu_inv</code>               (<code>Float[Array, 'c 2 2']</code>)           \u2013            <p>Inverse of the midsurface first fundamental form.</p> </li> <li> <code>alpha</code>               (<code>Float[Array, ' c']</code>)           \u2013            <p>Lam\u00e9\u2019s first parameter.</p> </li> <li> <code>beta</code>               (<code>Float[Array, ' c']</code>)           \u2013            <p>Lam\u00e9\u2019s second parameter.</p> </li> <li> <code>det_Iu</code>               (<code>Float[Array, ' c']</code>)           \u2013            <p>det(Iu).</p> </li> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            </li> <li> <code>h</code>               (<code>Float[Array, ' c']</code>)           \u2013            <p>Thickness.</p> </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>pre_strain</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.Iu_inv","title":"Iu_inv  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Iu_inv: Float[Array, 'c 2 2'] = array()\n</code></pre> <p>Inverse of the midsurface first fundamental form.</p>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.alpha","title":"alpha  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>alpha: Float[Array, ' c'] = array()\n</code></pre> <p>Lam\u00e9\u2019s first parameter.</p>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.beta","title":"beta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>beta: Float[Array, ' c'] = array()\n</code></pre> <p>Lam\u00e9\u2019s second parameter.</p>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.det_Iu","title":"det_Iu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>det_Iu: Float[Array, ' c'] = array()\n</code></pre> <p>det(Iu).</p>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.geometry","title":"geometry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>geometry: Geometry = field()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.h","title":"h  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>h: Float[Array, ' c'] = array()\n</code></pre> <p>Thickness.</p>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.pre_strain","title":"pre_strain  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pre_strain: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(geometry: Geometry) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_koiter.py</code> <pre><code>@classmethod\ndef from_geometry(cls, geometry: Geometry) -&gt; Self:\n    alpha: Float[Array, \" c\"] = math.asarray(\n        geometry.cell_data[\"alpha\"], dtype=float\n    )\n    beta: Float[Array, \" c\"] = math.asarray(geometry.cell_data[\"beta\"], dtype=float)\n    h: Float[Array, \" c\"] = math.asarray(geometry.cell_data[\"h\"], dtype=float)\n    Iu: Float[Array, \"c 2 2\"] = _first_fundamental_form(\n        geometry.points[geometry.cells_global]\n    )\n    pre_strain: Float[Array, \" c\"] = math.asarray(\n        geometry.cell_data[\"pre-strain\"], dtype=float\n    )\n    self: Self = cls(\n        alpha=alpha,\n        beta=beta,\n        det_Iu=jnp.linalg.det(Iu),\n        Iu_inv=jnp.linalg.inv(Iu),\n        h=h,\n        pre_strain=pre_strain,\n        geometry=geometry,\n    )\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_koiter.py</code> <pre><code>def fun(self, u: Vector) -&gt; Scalar:\n    I: Float[Array, \"c 2 2\"] = _first_fundamental_form(  # noqa: E741\n        u[self.geometry.cells_global]\n        + self.geometry.points[self.geometry.cells_global]\n    )\n    M: Float[Array, \"c 2 2\"] = (\n        jnp.matmul(self.Iu_inv, I)\n        - self.pre_strain[:, jnp.newaxis, jnp.newaxis]\n        * jnp.eye(2)[jnp.newaxis, ...]\n    )\n    Ws: Float[Array, \"\"] = self._norm_SV(M)\n    E: Float[Array, \" c\"] = 0.5 * (0.25 * self.h * Ws) * jnp.sqrt(self.det_Iu)\n    return jnp.sum(E)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.Koiter.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive","title":"PhaceActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>activation</code>               (<code>Float[Array, 'c J J']</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, c]</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> <li> <code>mixed_derivative_prod_activation</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>Float[Array, 'c J J']</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.activation","title":"activation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>activation: Float[Array, 'c J J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.lambda_","title":"lambda_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lambda_: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    A: Float[Array, \" c #q J J\"] = utils.make_activation(self.activation)[\n        :, jnp.newaxis, :, :\n    ]\n    lambda_: Float[Array, \" c #q\"] = self.lambda_[:, jnp.newaxis]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    J: Float[Array, \"c q\"] = jnp.linalg.det(F)\n    Psi_ARAP: Float[Array, \"c q\"] = mu * math.fro_norm_square(F - R @ A)\n    Psi_volume_preserving: Float[Array, \"c q\"] = lambda_ * (J - 1.0) ** 2\n    Psi: Float[Array, \"c q\"] = Psi_ARAP + Psi_volume_preserving\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>@override\n@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        activation=region.cell_data[\"activation\"],\n        lambda_=region.cell_data[\"lambda\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceActive.mixed_derivative_prod_activation","title":"mixed_derivative_prod_activation","text":"<pre><code>mixed_derivative_prod_activation(\n    u: Vector, p: Vector\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>def mixed_derivative_prod_activation(self, u: Vector, p: Vector) -&gt; Vector:\n    def jac(q: Float[Array, \"c 6\"]) -&gt; Vector:\n        energy: Self = attrs.evolve(self, activation=q)\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.jac(u)\n        jac: Vector = jax.ops.segment_sum(data, index, num_segments=u.shape[0])\n        return jac\n\n    vjp: Callable[[Vector], Float[Array, \"c 6\"]]\n    _, vjp = jax.vjp(jac, self.activation)\n\n    output: Float[Array, \"c 6\"]\n    (output,) = vjp(p)\n    return output\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic","title":"PhaceStatic","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.lambda_","title":"lambda_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lambda_: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_static.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    lambda_: Float[Array, \" c #q\"] = self.lambda_[:, jnp.newaxis]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    J: Float[Array, \"c q\"] = jnp.linalg.det(F)\n    Psi_ARAP: Float[Array, \"c q\"] = mu * math.fro_norm_square(F - R)\n    Psi_volume_preserving: Float[Array, \"c q\"] = lambda_ * (J - 1.0) ** 2\n    Psi: Float[Array, \"c q\"] = 2.0 * Psi_ARAP + Psi_volume_preserving\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_static.py</code> <pre><code>@override\n@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        lambda_=region.cell_data[\"lambda\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.PhaceStatic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.make_activation","title":"make_activation","text":"<pre><code>make_activation(\n    activation: Float[Array, \"c 6\"],\n) -&gt; Float[Array, \"c 3 3\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def make_activation(activation: Float[Array, \"c 6\"]) -&gt; Float[Array, \"c 3 3\"]:\n    n_cells: int = activation.shape[0]\n    A: Float[Array, \"c 3 3\"] = jnp.empty((n_cells, 3, 3), activation.dtype)\n    A = A.at[:, 0, 0].set(activation[:, 0])\n    A = A.at[:, 1, 1].set(activation[:, 1])\n    A = A.at[:, 2, 2].set(activation[:, 2])\n    A = A.at[:, 0, 1].set(activation[:, 3])\n    A = A.at[:, 0, 2].set(activation[:, 4])\n    A = A.at[:, 1, 2].set(activation[:, 5])\n    A = A.at[:, 1, 0].set(activation[:, 3])\n    A = A.at[:, 2, 0].set(activation[:, 4])\n    A = A.at[:, 2, 1].set(activation[:, 5])\n    # A += jnp.identity(3, activation.dtype)\n    return A\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.rest_activation","title":"rest_activation","text":"<pre><code>rest_activation(\n    n_cells: int = 1, dtype: DTypeLike = float\n) -&gt; Float[Array, \"c 6\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def rest_activation(n_cells: int = 1, dtype: DTypeLike = float) -&gt; Float[Array, \"c 6\"]:\n    activation: Float[Array, \"c 6\"] = jnp.zeros((n_cells, 6), dtype)\n    activation = activation.at[:, 0].set(1.0)\n    activation = activation.at[:, 1].set(1.0)\n    activation = activation.at[:, 2].set(1.0)\n    return activation\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/#liblaf.apple.jax.sim.energy.transform_activation","title":"transform_activation","text":"<pre><code>transform_activation(\n    activation: Float[Array, \"#c 6\"],\n    orientation: Float[Array, \"#c 3 3\"],\n    *,\n    inverse: bool = False,\n) -&gt; Float[Array, \"c 6\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def transform_activation(\n    activation: Float[Array, \"#c 6\"],\n    orientation: Float[Array, \"#c 3 3\"],\n    *,\n    inverse: bool = False,\n) -&gt; Float[Array, \"c 6\"]:\n    activation_mat: Float[Array, \"c 3 3\"] = make_activation(activation)\n    if inverse:\n        orientation = orientation.mT\n    transformed_mat: Float[Array, \"c 3 3\"] = (\n        orientation.mT @ activation_mat @ orientation\n    )\n    n_cells: int = transformed_mat.shape[0]\n    transformed: Float[Array, \"c 6\"] = jnp.empty((n_cells, 6), activation.dtype)\n    transformed = transformed.at[:, 0].set(transformed_mat[:, 0, 0])\n    transformed = transformed.at[:, 1].set(transformed_mat[:, 1, 1])\n    transformed = transformed.at[:, 2].set(transformed_mat[:, 2, 2])\n    transformed = transformed.at[:, 3].set(transformed_mat[:, 0, 1])\n    transformed = transformed.at[:, 4].set(transformed_mat[:, 0, 2])\n    transformed = transformed.at[:, 5].set(transformed_mat[:, 1, 2])\n    return transformed\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/","title":"elastic","text":""},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic","title":"liblaf.apple.jax.sim.energy.elastic","text":"<p>Modules:</p> <ul> <li> <code>utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>ARAP</code>           \u2013            </li> <li> <code>ARAPActive</code>           \u2013            </li> <li> <code>Elastic</code>           \u2013            </li> <li> <code>PhaceActive</code>           \u2013            </li> <li> <code>PhaceStatic</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>make_activation</code>             \u2013              </li> <li> <code>rest_activation</code>             \u2013              </li> <li> <code>transform_activation</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP","title":"ARAP","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap.py</code> <pre><code>def energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    return 0.5 * mu * math.fro_norm_square(F - R)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(region=region, mu=region.cell_data[\"mu\"], **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAP.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive","title":"ARAPActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>activation</code>               (<code>Float[Array, 'c 6']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> <li> <code>mixed_derivative_prod_activation</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>Float[Array, 'c 6']</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.activation","title":"activation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>activation: Float[Array, 'c 6'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    A: Float[Array, \" c #q J J\"] = utils.make_activation(self.activation)[\n        :, jnp.newaxis, :, :\n    ]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    return mu * math.fro_norm_square(F - R @ A)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        activation=region.cell_data[\"activation\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.ARAPActive.mixed_derivative_prod_activation","title":"mixed_derivative_prod_activation","text":"<pre><code>mixed_derivative_prod_activation(\n    u: Vector, p: Vector\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_arap_active.py</code> <pre><code>def mixed_derivative_prod_activation(self, u: Vector, p: Vector) -&gt; Vector:\n    def jac(q: Float[Array, \"c 6\"]) -&gt; Vector:\n        energy: Self = attrs.evolve(self, activation=q)\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.jac(u)\n        jac: Vector = jax.ops.segment_sum(data, index, num_segments=u.shape[0])\n        return jac\n\n    vjp: Callable[[Vector], Float[Array, \"c 6\"]]\n    _, vjp = jax.vjp(jac, self.activation)\n\n    output: Float[Array, \"c 6\"]\n    (output,) = vjp(p)\n    return output\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic","title":"Elastic","text":"<p>               Bases: <code>Energy</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>def energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(region=region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.Elastic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive","title":"PhaceActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>activation</code>               (<code>Float[Array, 'c J J']</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, c]</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> <li> <code>mixed_derivative_prod_activation</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>Float[Array, 'c J J']</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.activation","title":"activation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>activation: Float[Array, 'c J J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.lambda_","title":"lambda_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lambda_: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    A: Float[Array, \" c #q J J\"] = utils.make_activation(self.activation)[\n        :, jnp.newaxis, :, :\n    ]\n    lambda_: Float[Array, \" c #q\"] = self.lambda_[:, jnp.newaxis]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    J: Float[Array, \"c q\"] = jnp.linalg.det(F)\n    Psi_ARAP: Float[Array, \"c q\"] = mu * math.fro_norm_square(F - R @ A)\n    Psi_volume_preserving: Float[Array, \"c q\"] = lambda_ * (J - 1.0) ** 2\n    Psi: Float[Array, \"c q\"] = Psi_ARAP + Psi_volume_preserving\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>@override\n@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        activation=region.cell_data[\"activation\"],\n        lambda_=region.cell_data[\"lambda\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceActive.mixed_derivative_prod_activation","title":"mixed_derivative_prod_activation","text":"<pre><code>mixed_derivative_prod_activation(\n    u: Vector, p: Vector\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_active.py</code> <pre><code>def mixed_derivative_prod_activation(self, u: Vector, p: Vector) -&gt; Vector:\n    def jac(q: Float[Array, \"c 6\"]) -&gt; Vector:\n        energy: Self = attrs.evolve(self, activation=q)\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.jac(u)\n        jac: Vector = jax.ops.segment_sum(data, index, num_segments=u.shape[0])\n        return jac\n\n    vjp: Callable[[Vector], Float[Array, \"c 6\"]]\n    _, vjp = jax.vjp(jac, self.activation)\n\n    output: Float[Array, \"c 6\"]\n    (output,) = vjp(p)\n    return output\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic","title":"PhaceStatic","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, c]</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, c]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>mu</code>               (<code>Float[Array, ' c']</code>)           \u2013            </li> <li> <code>region</code>               (<code>Region</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.lambda_","title":"lambda_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lambda_: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.mu","title":"mu  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mu: Float[Array, ' c'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.region","title":"region  <code>instance-attribute</code>","text":"<pre><code>region: Region\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.energy_density","title":"energy_density","text":"<pre><code>energy_density(\n    F: Float[Array, \"c q J J\"],\n) -&gt; Float[Array, \"c q\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_static.py</code> <pre><code>@override\ndef energy_density(self, F: Float[Array, \"c q J J\"]) -&gt; Float[Array, \"c q\"]:\n    lambda_: Float[Array, \" c #q\"] = self.lambda_[:, jnp.newaxis]\n    mu: Float[Array, \" c #q\"] = self.mu[:, jnp.newaxis]\n    R: Float[Array, \"c q J J\"]\n    R, _ = math.polar_rv(F)\n    J: Float[Array, \"c q\"] = jnp.linalg.det(F)\n    Psi_ARAP: Float[Array, \"c q\"] = mu * math.fro_norm_square(F - R)\n    Psi_volume_preserving: Float[Array, \"c q\"] = lambda_ * (J - 1.0) ** 2\n    Psi: Float[Array, \"c q\"] = 2.0 * Psi_ARAP + Psi_volume_preserving\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_geometry(\n        geometry, grad=True, quadrature=quadrature\n    )\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    return cls.from_geometry(geometry, quadrature=quadrature, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_phace_static.py</code> <pre><code>@override\n@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    return cls(\n        region=region,\n        lambda_=region.cell_data[\"lambda\"],\n        mu=region.cell_data[\"mu\"],\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: Vector) -&gt; Scalar:\n    F: Float[Array, \"c q J J\"] = self.region.deformation_gradient(u)\n    Psi: Float[Array, \"c q\"] = self.energy_density(F)\n    return self.region.integrate(Psi).sum()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Updates]:\n    value: Scalar\n    data: Vector\n    value, data = jax.value_and_grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return value, (data, index)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Updates:\n    data: Vector = math.hess_diag(self.fun, u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Updates:\n    data: Vector\n    _, data = jax.jvp(jax.grad(self.fun), (u,), (p,))\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    data: Vector\n    index: UpdatesIndex\n    data, index = self.hess_prod(u, p)\n    return jnp.vdot(p[index], data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Updates\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac(self, u: Vector) -&gt; Updates:\n    data: Vector = jax.grad(self.fun)(u)\n    index: UpdatesIndex = jnp.arange(data.shape[0])\n    return data, index\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Updates, Updates]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Updates, Updates]:\n    jac: Updates = self.jac(u)\n    hess_diag: Updates = self.hess_diag(u)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.PhaceStatic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: Vector, p: Vector) -&gt; dict[str, Array]:\n    outputs: dict[str, Array] = {}\n    for name in self.requires_grad:\n        outputs[name] = getattr(self, f\"mixed_derivative_prod_{name}\")(u, p)\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.make_activation","title":"make_activation","text":"<pre><code>make_activation(\n    activation: Float[Array, \"c 6\"],\n) -&gt; Float[Array, \"c 3 3\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def make_activation(activation: Float[Array, \"c 6\"]) -&gt; Float[Array, \"c 3 3\"]:\n    n_cells: int = activation.shape[0]\n    A: Float[Array, \"c 3 3\"] = jnp.empty((n_cells, 3, 3), activation.dtype)\n    A = A.at[:, 0, 0].set(activation[:, 0])\n    A = A.at[:, 1, 1].set(activation[:, 1])\n    A = A.at[:, 2, 2].set(activation[:, 2])\n    A = A.at[:, 0, 1].set(activation[:, 3])\n    A = A.at[:, 0, 2].set(activation[:, 4])\n    A = A.at[:, 1, 2].set(activation[:, 5])\n    A = A.at[:, 1, 0].set(activation[:, 3])\n    A = A.at[:, 2, 0].set(activation[:, 4])\n    A = A.at[:, 2, 1].set(activation[:, 5])\n    # A += jnp.identity(3, activation.dtype)\n    return A\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.rest_activation","title":"rest_activation","text":"<pre><code>rest_activation(\n    n_cells: int = 1, dtype: DTypeLike = float\n) -&gt; Float[Array, \"c 6\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def rest_activation(n_cells: int = 1, dtype: DTypeLike = float) -&gt; Float[Array, \"c 6\"]:\n    activation: Float[Array, \"c 6\"] = jnp.zeros((n_cells, 6), dtype)\n    activation = activation.at[:, 0].set(1.0)\n    activation = activation.at[:, 1].set(1.0)\n    activation = activation.at[:, 2].set(1.0)\n    return activation\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/#liblaf.apple.jax.sim.energy.elastic.transform_activation","title":"transform_activation","text":"<pre><code>transform_activation(\n    activation: Float[Array, \"#c 6\"],\n    orientation: Float[Array, \"#c 3 3\"],\n    *,\n    inverse: bool = False,\n) -&gt; Float[Array, \"c 6\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def transform_activation(\n    activation: Float[Array, \"#c 6\"],\n    orientation: Float[Array, \"#c 3 3\"],\n    *,\n    inverse: bool = False,\n) -&gt; Float[Array, \"c 6\"]:\n    activation_mat: Float[Array, \"c 3 3\"] = make_activation(activation)\n    if inverse:\n        orientation = orientation.mT\n    transformed_mat: Float[Array, \"c 3 3\"] = (\n        orientation.mT @ activation_mat @ orientation\n    )\n    n_cells: int = transformed_mat.shape[0]\n    transformed: Float[Array, \"c 6\"] = jnp.empty((n_cells, 6), activation.dtype)\n    transformed = transformed.at[:, 0].set(transformed_mat[:, 0, 0])\n    transformed = transformed.at[:, 1].set(transformed_mat[:, 1, 1])\n    transformed = transformed.at[:, 2].set(transformed_mat[:, 2, 2])\n    transformed = transformed.at[:, 3].set(transformed_mat[:, 0, 1])\n    transformed = transformed.at[:, 4].set(transformed_mat[:, 0, 2])\n    transformed = transformed.at[:, 5].set(transformed_mat[:, 1, 2])\n    return transformed\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/utils/","title":"utils","text":""},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/utils/#liblaf.apple.jax.sim.energy.elastic.utils","title":"liblaf.apple.jax.sim.energy.elastic.utils","text":"<p>Functions:</p> <ul> <li> <code>make_activation</code>             \u2013              </li> <li> <code>rest_activation</code>             \u2013              </li> <li> <code>transform_activation</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/utils/#liblaf.apple.jax.sim.energy.elastic.utils.make_activation","title":"make_activation","text":"<pre><code>make_activation(\n    activation: Float[Array, \"c 6\"],\n) -&gt; Float[Array, \"c 3 3\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def make_activation(activation: Float[Array, \"c 6\"]) -&gt; Float[Array, \"c 3 3\"]:\n    n_cells: int = activation.shape[0]\n    A: Float[Array, \"c 3 3\"] = jnp.empty((n_cells, 3, 3), activation.dtype)\n    A = A.at[:, 0, 0].set(activation[:, 0])\n    A = A.at[:, 1, 1].set(activation[:, 1])\n    A = A.at[:, 2, 2].set(activation[:, 2])\n    A = A.at[:, 0, 1].set(activation[:, 3])\n    A = A.at[:, 0, 2].set(activation[:, 4])\n    A = A.at[:, 1, 2].set(activation[:, 5])\n    A = A.at[:, 1, 0].set(activation[:, 3])\n    A = A.at[:, 2, 0].set(activation[:, 4])\n    A = A.at[:, 2, 1].set(activation[:, 5])\n    # A += jnp.identity(3, activation.dtype)\n    return A\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/utils/#liblaf.apple.jax.sim.energy.elastic.utils.rest_activation","title":"rest_activation","text":"<pre><code>rest_activation(\n    n_cells: int = 1, dtype: DTypeLike = float\n) -&gt; Float[Array, \"c 6\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def rest_activation(n_cells: int = 1, dtype: DTypeLike = float) -&gt; Float[Array, \"c 6\"]:\n    activation: Float[Array, \"c 6\"] = jnp.zeros((n_cells, 6), dtype)\n    activation = activation.at[:, 0].set(1.0)\n    activation = activation.at[:, 1].set(1.0)\n    activation = activation.at[:, 2].set(1.0)\n    return activation\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/energy/elastic/utils/#liblaf.apple.jax.sim.energy.elastic.utils.transform_activation","title":"transform_activation","text":"<pre><code>transform_activation(\n    activation: Float[Array, \"#c 6\"],\n    orientation: Float[Array, \"#c 3 3\"],\n    *,\n    inverse: bool = False,\n) -&gt; Float[Array, \"c 6\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/energy/elastic/utils.py</code> <pre><code>def transform_activation(\n    activation: Float[Array, \"#c 6\"],\n    orientation: Float[Array, \"#c 3 3\"],\n    *,\n    inverse: bool = False,\n) -&gt; Float[Array, \"c 6\"]:\n    activation_mat: Float[Array, \"c 3 3\"] = make_activation(activation)\n    if inverse:\n        orientation = orientation.mT\n    transformed_mat: Float[Array, \"c 3 3\"] = (\n        orientation.mT @ activation_mat @ orientation\n    )\n    n_cells: int = transformed_mat.shape[0]\n    transformed: Float[Array, \"c 6\"] = jnp.empty((n_cells, 6), activation.dtype)\n    transformed = transformed.at[:, 0].set(transformed_mat[:, 0, 0])\n    transformed = transformed.at[:, 1].set(transformed_mat[:, 1, 1])\n    transformed = transformed.at[:, 2].set(transformed_mat[:, 2, 2])\n    transformed = transformed.at[:, 3].set(transformed_mat[:, 0, 1])\n    transformed = transformed.at[:, 4].set(transformed_mat[:, 0, 2])\n    transformed = transformed.at[:, 5].set(transformed_mat[:, 1, 2])\n    return transformed\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/","title":"geometry","text":""},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry","title":"liblaf.apple.jax.sim.geometry","text":"<p>Classes:</p> <ul> <li> <code>Geometry</code>           \u2013            </li> <li> <code>GeometryAttributes</code>           \u2013            </li> <li> <code>GeometryTetra</code>           \u2013            </li> <li> <code>GeometryTriangle</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_array_dict</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry","title":"Geometry","text":"<p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.POINT: 0&gt;, data={})</code> )           \u2013            </li> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.CELL: 1&gt;, data={})</code> )           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.NONE: 2&gt;, data={})</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>copy_attributes</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>cells_global</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>element</code>               (<code>Element</code>)           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>point_ids</code>               (<code>Integer[Array, ' p']</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.cell_data","title":"cell_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cell_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=CELL)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: Integer[Array, 'c a'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.cells_global","title":"cells_global  <code>property</code>","text":"<pre><code>cells_global: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.element","title":"element  <code>property</code>","text":"<pre><code>element: Element\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.field_data","title":"field_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=NONE)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.point_data","title":"point_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=POINT)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.point_ids","title":"point_ids  <code>property</code>","text":"<pre><code>point_ids: Integer[Array, ' p']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, 'p J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.copy_attributes","title":"copy_attributes","text":"<pre><code>copy_attributes(other: Self | DataObject) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_geometry.py</code> <pre><code>def copy_attributes(self, other: Self | pv.DataObject) -&gt; None:\n    self.point_data.update(as_array_dict(other.point_data))\n    self.cell_data.update(as_array_dict(other.cell_data))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.Geometry.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(mesh: DataObject) -&gt; Geometry\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_geometry.py</code> <pre><code>@classmethod\ndef from_pyvista(cls, mesh: pv.DataObject) -&gt; \"Geometry\":\n    from ._tetra import GeometryTetra\n    from ._triangle import GeometryTriangle\n\n    if isinstance(mesh, pv.PolyData):\n        return GeometryTriangle.from_pyvista(mesh)\n    if isinstance(mesh, pv.UnstructuredGrid):\n        return GeometryTetra.from_pyvista(mesh)\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryAttributes","title":"GeometryAttributes","text":"<p>               Bases: <code>MutableMapping[str, Array]</code></p> <p>Parameters:</p> <ul> <li> <code>association</code>               (<code>FieldAssociation</code>)           \u2013            </li> <li> <code>data</code>               (<code>dict[str, Array]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__delitem__</code>             \u2013              </li> <li> <code>__getitem__</code>             \u2013              </li> <li> <code>__iter__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>__setitem__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>association</code>               (<code>FieldAssociation</code>)           \u2013            </li> <li> <code>data</code>               (<code>dict[str, Array]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryAttributes.association","title":"association  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>association: FieldAssociation = field()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryAttributes.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: dict[str, Array] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryAttributes.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __delitem__(self, key: str) -&gt; None:\n    del self.data[key]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryAttributes.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; Array\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __getitem__(self, key: str, /) -&gt; Array:\n    return self.data[key]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryAttributes.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[str]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __iter__(self) -&gt; Iterator[str]:\n    yield from self.data\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryAttributes.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.data)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryAttributes.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: str, value: Array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def __setitem__(self, key: str, value: Array, /) -&gt; None:\n    self.data[key] = value\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra","title":"GeometryTetra","text":"<p>               Bases: <code>Geometry</code></p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.POINT: 0&gt;, data={})</code> )           \u2013            </li> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.CELL: 1&gt;, data={})</code> )           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.NONE: 2&gt;, data={})</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>copy_attributes</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>cells_global</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>element</code>               (<code>ElementTetra</code>)           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>point_ids</code>               (<code>Integer[Array, ' p']</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.cell_data","title":"cell_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cell_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=CELL)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: Integer[Array, 'c a'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.cells_global","title":"cells_global  <code>property</code>","text":"<pre><code>cells_global: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.element","title":"element  <code>property</code>","text":"<pre><code>element: ElementTetra\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.field_data","title":"field_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=NONE)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.point_data","title":"point_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=POINT)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.point_ids","title":"point_ids  <code>property</code>","text":"<pre><code>point_ids: Integer[Array, ' p']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, 'p J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.copy_attributes","title":"copy_attributes","text":"<pre><code>copy_attributes(other: Self | DataObject) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_geometry.py</code> <pre><code>def copy_attributes(self, other: Self | pv.DataObject) -&gt; None:\n    self.point_data.update(as_array_dict(other.point_data))\n    self.cell_data.update(as_array_dict(other.cell_data))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTetra.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(mesh: UnstructuredGrid) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_tetra.py</code> <pre><code>@override\n@classmethod\ndef from_pyvista(cls, mesh: pv.UnstructuredGrid) -&gt; Self:  # pyright: ignore[reportIncompatibleMethodOverride]\n    points: Float[Array, \"p J\"] = math.asarray(mesh.points, float_)\n    cells: Integer[Array, \"c a\"] = math.asarray(\n        mesh.cells_dict[pv.CellType.TETRA],  # pyright: ignore[reportArgumentType]\n        int_,\n    )\n    self: Self = cls(points=points, cells=cells)\n    self.copy_attributes(mesh)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle","title":"GeometryTriangle","text":"<p>               Bases: <code>Geometry</code></p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.POINT: 0&gt;, data={})</code> )           \u2013            </li> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.CELL: 1&gt;, data={})</code> )           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>, default:                   <code>GeometryAttributes(association=&lt;FieldAssociation.NONE: 2&gt;, data={})</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>copy_attributes</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>cells_global</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>element</code>               (<code>Element</code>)           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>point_ids</code>               (<code>Integer[Array, ' p']</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.cell_data","title":"cell_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cell_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=CELL)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: Integer[Array, 'c a'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.cells_global","title":"cells_global  <code>property</code>","text":"<pre><code>cells_global: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.element","title":"element  <code>property</code>","text":"<pre><code>element: Element\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.field_data","title":"field_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>field_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=NONE)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.point_data","title":"point_data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>point_data: GeometryAttributes = field(\n    factory=lambda: GeometryAttributes(association=POINT)\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.point_ids","title":"point_ids  <code>property</code>","text":"<pre><code>point_ids: Integer[Array, ' p']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, 'p J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.copy_attributes","title":"copy_attributes","text":"<pre><code>copy_attributes(other: Self | DataObject) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_geometry.py</code> <pre><code>def copy_attributes(self, other: Self | pv.DataObject) -&gt; None:\n    self.point_data.update(as_array_dict(other.point_data))\n    self.cell_data.update(as_array_dict(other.cell_data))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.GeometryTriangle.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(mesh: PolyData) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_triangle.py</code> <pre><code>@override\n@classmethod\ndef from_pyvista(cls, mesh: pv.PolyData) -&gt; Self:  # pyright: ignore[reportIncompatibleMethodOverride]\n    mesh = mesh.triangulate()  # pyright: ignore[reportAssignmentType]\n    points: Float[Array, \"p J\"] = math.asarray(mesh.points, float_)\n    cells: Integer[Array, \"c a\"] = math.asarray(mesh.regular_faces, int_)\n    self: Self = cls(points=points, cells=cells)\n    self.copy_attributes(mesh)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/geometry/#liblaf.apple.jax.sim.geometry.as_array_dict","title":"as_array_dict","text":"<pre><code>as_array_dict(\n    m: Mapping[str, ArrayLike],\n) -&gt; dict[str, Array]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/geometry/_attributes.py</code> <pre><code>def as_array_dict(m: Mapping[str, ArrayLike], /) -&gt; dict[str, Array]:\n    return {k: math.asarray(v) for k, v in m.items()}\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/","title":"model","text":""},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model","title":"liblaf.apple.jax.sim.model","text":"<p>Classes:</p> <ul> <li> <code>Model</code>           \u2013            </li> <li> <code>ModelBuilder</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model","title":"Model","text":"<p>Parameters:</p> <ul> <li> <code>energies</code>               (<code>Mapping[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>energies</code>               (<code>Mapping[str, Energy]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.energies","title":"energies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies: Mapping[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def fun(self, u: Vector) -&gt; Scalar:\n    if not self.energies:\n        return jnp.zeros((), u.dtype)\n    outputs: list[Scalar] = [energy.fun(u) for energy in self.energies.values()]\n    return jnp.sum(jnp.asarray(outputs))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Vector]:\n    if not self.energies:\n        return jnp.zeros((), u.dtype), jnp.zeros_like(u)\n    value_list: list[Scalar] = []\n    updates_data_list: list[UpdatesData] = []\n    updates_index_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        fun, (data, index) = energy.fun_and_jac(u)\n        value_list.append(fun)\n        updates_data_list.append(data)\n        updates_index_list.append(index)\n    fun: Scalar = jnp.sum(jnp.asarray(value_list))\n    jac: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_list),\n        jnp.concat(updates_index_list),\n        num_segments=u.shape[0],\n    )\n    return fun, jac\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def hess_diag(self, u: Vector) -&gt; Vector:\n    if not self.energies:\n        return jnp.zeros_like(u)\n    updates_data_list: list[UpdatesData] = []\n    updates_index_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.hess_diag(u)\n        updates_data_list.append(data)\n        updates_index_list.append(index)\n    hess_diag: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_list),\n        jnp.concat(updates_index_list),\n        num_segments=u.shape[0],\n    )\n    return hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def hess_prod(self, u: Vector, p: Vector) -&gt; Vector:\n    if not self.energies:\n        return jnp.zeros_like(u)\n    updates_data_list: list[UpdatesData] = []\n    updates_index_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.hess_prod(u, p)\n        updates_data_list.append(data)\n        updates_index_list.append(index)\n    hess_prod: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_list),\n        jnp.concat(updates_index_list),\n        num_segments=u.shape[0],\n    )\n    return hess_prod\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    if not self.energies:\n        return jnp.zeros((), u.dtype)\n    outputs: list[Scalar] = [\n        energy.hess_quad(u, p) for energy in self.energies.values()\n    ]\n    return jnp.sum(jnp.asarray(outputs))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def jac(self, u: Vector) -&gt; Vector:\n    if not self.energies:\n        return jnp.zeros_like(u)\n    updates_data_list: list[UpdatesData] = []\n    updates_index_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        data: UpdatesData\n        index: UpdatesIndex\n        data, index = energy.jac(u)\n        updates_data_list.append(data)\n        updates_index_list.append(index)\n    jac: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_list),\n        jnp.concat(updates_index_list),\n        num_segments=u.shape[0],\n    )\n    return jac\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Vector, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def jac_and_hess_diag(self, u: Vector) -&gt; tuple[Vector, Vector]:\n    if not self.energies:\n        return jnp.zeros_like(u), jnp.zeros_like(u)\n    updates_data_jac_list: list[UpdatesData] = []\n    updates_index_jac_list: list[UpdatesIndex] = []\n    updates_data_hess_list: list[UpdatesData] = []\n    updates_index_hess_list: list[UpdatesIndex] = []\n    for energy in self.energies.values():\n        (data_jac, index_jac), (data_hess, index_hess) = energy.jac_and_hess_diag(u)\n        updates_data_jac_list.append(data_jac)\n        updates_index_jac_list.append(index_jac)\n        updates_data_hess_list.append(data_hess)\n        updates_index_hess_list.append(index_hess)\n    jac: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_jac_list),\n        jnp.concat(updates_index_jac_list),\n        num_segments=u.shape[0],\n    )\n    hess_diag: Vector = jax.ops.segment_sum(\n        jnp.concat(updates_data_hess_list),\n        jnp.concat(updates_index_hess_list),\n        num_segments=u.shape[0],\n    )\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.Model.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, dict[str, Array]]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model.py</code> <pre><code>def mixed_derivative_prod(\n    self, u: Vector, p: Vector\n) -&gt; dict[str, dict[str, Array]]:\n    outputs: dict[str, dict[str, Array]] = {\n        energy.id: energy.mixed_derivative_prod(u, p)\n        for energy in self.energies.values()\n    }\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder","title":"ModelBuilder","text":"<p>Parameters:</p> <ul> <li> <code>dirichlet</code>               (<code>DirichletBuilder</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>energies</code>               (<code>dict[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>, default:                   <code>Array([], shape=(0, 3), dtype=float32)</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>add_dirichlet</code>             \u2013              </li> <li> <code>add_energy</code>             \u2013              </li> <li> <code>assign_dofs</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dirichlet</code>               (<code>DirichletBuilder</code>)           \u2013            </li> <li> <code>energies</code>               (<code>dict[str, Energy]</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder.dirichlet","title":"dirichlet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirichlet: DirichletBuilder = field(\n    factory=DirichletBuilder\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder.energies","title":"energies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies: dict[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, \"p J\"] = array(factory=_default_points)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder.add_dirichlet","title":"add_dirichlet","text":"<pre><code>add_dirichlet(mesh: DataSet) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model_builder.py</code> <pre><code>def add_dirichlet(self, mesh: pv.DataSet) -&gt; None:\n    self.dirichlet.add(mesh)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder.add_energy","title":"add_energy","text":"<pre><code>add_energy(energy: Energy) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model_builder.py</code> <pre><code>def add_energy(self, energy: Energy) -&gt; None:\n    self.energies[energy.id] = energy\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder.assign_dofs","title":"assign_dofs","text":"<pre><code>assign_dofs(mesh: T) -&gt; T\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model_builder.py</code> <pre><code>def assign_dofs[T: pv.DataSet](self, mesh: T) -&gt; T:\n    mesh.point_data[\"point-ids\"] = np.arange(\n        self.n_points, self.n_points + mesh.n_points\n    )\n    self.points = jnp.concat([self.points, mesh.points])\n    self.dirichlet.resize(self.n_points)\n    return mesh\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/model/#liblaf.apple.jax.sim.model.ModelBuilder.finish","title":"finish","text":"<pre><code>finish() -&gt; Model\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/model/_model_builder.py</code> <pre><code>def finish(self) -&gt; Model:\n    return Model(energies=self.energies)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/","title":"quadrature","text":""},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature","title":"liblaf.apple.jax.sim.quadrature","text":"<p>Classes:</p> <ul> <li> <code>QuadratureTetra</code>           \u2013            </li> <li> <code>Scheme</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.QuadratureTetra","title":"QuadratureTetra","text":"<p>               Bases: <code>Scheme</code></p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'q=1 J=3']</code>, default:                   <code>Array([[0.25, 0.25, 0.25]], dtype=float32)</code> )           \u2013            </li> <li> <code>weights</code>               (<code>Float[Array, 'q=1']</code>, default:                   <code>Array([0.16666667], dtype=float32)</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_felupe</code>             \u2013              </li> <li> <code>from_order</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'q=1 J=3']</code>)           \u2013            </li> <li> <code>weights</code>               (<code>Float[Array, 'q=1']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.QuadratureTetra.dim","title":"dim  <code>property</code>","text":"<pre><code>dim: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.QuadratureTetra.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.QuadratureTetra.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, \"q=1 J=3\"] = array(\n    factory=_default_points\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.QuadratureTetra.weights","title":"weights  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weights: Float[Array, \"q=1\"] = array(\n    factory=_default_weights\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.QuadratureTetra.from_felupe","title":"from_felupe  <code>classmethod</code>","text":"<pre><code>from_felupe(scheme: Scheme) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/quadrature/_scheme.py</code> <pre><code>@classmethod\ndef from_felupe(cls, scheme: felupe.quadrature.Scheme) -&gt; Self:\n    with jax.ensure_compile_time_eval():\n        return cls(\n            points=math.asarray(scheme.points), weights=math.asarray(scheme.weights)\n        )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.QuadratureTetra.from_order","title":"from_order  <code>classmethod</code>","text":"<pre><code>from_order(order: int = 1) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/quadrature/_tetra.py</code> <pre><code>@classmethod\ndef from_order(cls, order: int = 1) -&gt; Self:\n    with jax.ensure_compile_time_eval():\n        return cls.from_felupe(felupe.quadrature.Tetrahedron(order=order))\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.Scheme","title":"Scheme","text":"<p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'q J']</code>)           \u2013            </li> <li> <code>weights</code>               (<code>Float[Array, q]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_felupe</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dim</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'q J']</code>)           \u2013            </li> <li> <code>weights</code>               (<code>Float[Array, ' q']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.Scheme.dim","title":"dim  <code>property</code>","text":"<pre><code>dim: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.Scheme.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.Scheme.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, 'q J'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.Scheme.weights","title":"weights  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weights: Float[Array, ' q'] = array()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/quadrature/#liblaf.apple.jax.sim.quadrature.Scheme.from_felupe","title":"from_felupe  <code>classmethod</code>","text":"<pre><code>from_felupe(scheme: Scheme) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/quadrature/_scheme.py</code> <pre><code>@classmethod\ndef from_felupe(cls, scheme: felupe.quadrature.Scheme) -&gt; Self:\n    with jax.ensure_compile_time_eval():\n        return cls(\n            points=math.asarray(scheme.points), weights=math.asarray(scheme.weights)\n        )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/","title":"region","text":""},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region","title":"liblaf.apple.jax.sim.region","text":"<p>Classes:</p> <ul> <li> <code>Region</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region","title":"Region","text":"<p>Parameters:</p> <ul> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>h</code>               (<code>Float[Array, 'q a']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdr</code>               (<code>Float[Array, 'q a J']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dXdr</code>               (<code>Float[Array, 'c q J J']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>drdX</code>               (<code>Float[Array, 'c q J J']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>Float[Array, 'c q']</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>Float[Array, 'c q a J']</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>compute_grad</code>             \u2013              </li> <li> <code>deformation_gradient</code>             \u2013              </li> <li> <code>from_geometry</code>             \u2013              </li> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>integrate</code>             \u2013              </li> <li> <code>scatter</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cell_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>cells</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>cells_global</code>               (<code>Integer[Array, 'c a']</code>)           \u2013            </li> <li> <code>dV</code>               (<code>Float[Array, 'c q']</code>)           \u2013            </li> <li> <code>dXdr</code>               (<code>Float[Array, 'c q J J']</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>Float[Array, 'c q a J']</code>)           \u2013            </li> <li> <code>dhdr</code>               (<code>Float[Array, 'q a J']</code>)           \u2013            </li> <li> <code>drdX</code>               (<code>Float[Array, 'c q J J']</code>)           \u2013            </li> <li> <code>element</code>               (<code>Element</code>)           \u2013            </li> <li> <code>field_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>geometry</code>               (<code>Geometry</code>)           \u2013            </li> <li> <code>h</code>               (<code>Float[Array, 'q a']</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>point_data</code>               (<code>GeometryAttributes</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.cell_data","title":"cell_data  <code>property</code>","text":"<pre><code>cell_data: GeometryAttributes\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.cells","title":"cells  <code>property</code>","text":"<pre><code>cells: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.cells_global","title":"cells_global  <code>property</code>","text":"<pre><code>cells_global: Integer[Array, 'c a']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: Float[Array, 'c q'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.dXdr","title":"dXdr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dXdr: Float[Array, 'c q J J'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: Float[Array, 'c q a J'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.dhdr","title":"dhdr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdr: Float[Array, 'q a J'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.drdX","title":"drdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>drdX: Float[Array, 'c q J J'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.element","title":"element  <code>property</code>","text":"<pre><code>element: Element\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.field_data","title":"field_data  <code>property</code>","text":"<pre><code>field_data: GeometryAttributes\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.geometry","title":"geometry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>geometry: Geometry = field()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.h","title":"h  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>h: Float[Array, 'q a'] = array(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.point_data","title":"point_data  <code>property</code>","text":"<pre><code>point_data: GeometryAttributes\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.points","title":"points  <code>property</code>","text":"<pre><code>points: Float[Array, 'p J']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field()\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.compute_grad","title":"compute_grad","text":"<pre><code>compute_grad() -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def compute_grad(self) -&gt; None:\n    h: Float[Array, \"q a\"] = jnp.stack(\n        [self.element.function(q) for q in self.quadrature.points]\n    )\n    dhdr: Float[Array, \"q a J\"] = jnp.stack(\n        [self.element.gradient(q) for q in self.quadrature.points]\n    )\n    dXdr: Float[Array, \"c q J J\"] = einops.einsum(\n        self.points[self.cells], dhdr, \"c a I, q a J -&gt; c q I J\"\n    )\n    drdX: Float[Array, \"c q J J\"] = jnp.linalg.inv(dXdr)\n    dV: Float[Array, \"c q\"] = (\n        jnp.linalg.det(dXdr) * self.quadrature.weights[jnp.newaxis, :]\n    )\n    if jnp.any(dV &lt;= 0):\n        logger.warning(\"dV &lt;= 0\")\n    dhdX: Float[Array, \"c q a J\"] = einops.einsum(\n        dhdr, drdX, \"q a I, c q I J -&gt; c q a J\"\n    )\n    self.h = h\n    self.dhdr = dhdr\n    self.dXdr = dXdr\n    self.drdX = drdX\n    self.dV = dV\n    self.dhdX = dhdX\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.deformation_gradient","title":"deformation_gradient","text":"<pre><code>deformation_gradient(\n    u: Float[Array, \"p J\"],\n) -&gt; Float[Array, \"c q J J\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def deformation_gradient(self, u: Float[Array, \"p J\"]) -&gt; Float[Array, \"c q J J\"]:\n    grad: Float[Array, \"c q J J\"] = self.gradient(u)\n    F: Float[Array, \"c q J J\"] = (\n        grad + jnp.identity(3)[jnp.newaxis, jnp.newaxis, ...]\n    )\n    return F\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(\n    geometry: Geometry,\n    *,\n    grad: bool = False,\n    quadrature: Scheme | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>@classmethod\ndef from_geometry(\n    cls, geometry: Geometry, *, grad: bool = False, quadrature: Scheme | None = None\n) -&gt; Self:\n    if quadrature is None:\n        quadrature = geometry.element.quadrature\n    self: Self = cls(geometry=geometry, quadrature=quadrature)\n    if grad:\n        self.compute_grad()\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: DataObject,\n    *,\n    grad: bool = False,\n    quadrature: Scheme | None = None,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls,\n    mesh: pv.DataObject,\n    *,\n    grad: bool = False,\n    quadrature: Scheme | None = None,\n) -&gt; Self:\n    geometry: Geometry = Geometry.from_pyvista(mesh)\n    self: Self = cls.from_geometry(geometry, grad=grad, quadrature=quadrature)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.gradient","title":"gradient","text":"<pre><code>gradient(\n    u: Float[Array, \" points *shape\"],\n) -&gt; Float[Array, \"c q *shape J\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def gradient(\n    self, u: Float[Array, \" points *shape\"]\n) -&gt; Float[Array, \"c q *shape J\"]:\n    result: Float[Array, \"c q *shape J\"] = einops.einsum(\n        self.scatter(u), self.dhdX, \"c a ..., c q a J -&gt; c q ... J\"\n    )\n    return result\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.integrate","title":"integrate","text":"<pre><code>integrate(\n    a: Float[Array, \"c q *shape\"],\n) -&gt; Float[Array, \" c *shape\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def integrate(self, a: Float[Array, \"c q *shape\"]) -&gt; Float[Array, \" c *shape\"]:\n    return einops.einsum(a, self.dV, \"c q ..., c q -&gt; c ...\")\n</code></pre>"},{"location":"reference/liblaf/apple/jax/sim/region/#liblaf.apple.jax.sim.region.Region.scatter","title":"scatter","text":"<pre><code>scatter(\n    u: Float[Array, \" points *shape\"],\n) -&gt; Float[Array, \"c a *shape\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/sim/region/_region.py</code> <pre><code>def scatter(self, u: Float[Array, \" points *shape\"]) -&gt; Float[Array, \"c a *shape\"]:\n    return u[self.cells_global]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/testing/","title":"testing","text":""},{"location":"reference/liblaf/apple/jax/testing/#liblaf.apple.jax.testing","title":"liblaf.apple.jax.testing","text":"<p>Functions:</p> <ul> <li> <code>random_mat33</code>             \u2013              </li> <li> <code>random_spd_matrix</code>             \u2013              </li> <li> <code>rosen</code>             \u2013              </li> <li> <code>rosen_der</code>             \u2013              </li> <li> <code>rosen_hess</code>             \u2013              </li> <li> <code>rosen_hess_prod</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/testing/#liblaf.apple.jax.testing.random_mat33","title":"random_mat33","text":"<pre><code>random_mat33(\n    min_dims: int = 1, max_dims: int | None = None\n) -&gt; SearchStrategy[Float[Array, \"*batch 3 3\"]]\n</code></pre> Source code in <code>src/liblaf/apple/jax/testing/_matrix.py</code> <pre><code>def random_mat33(\n    min_dims: int = 1, max_dims: int | None = None\n) -&gt; st.SearchStrategy[Float[Array, \"*batch 3 3\"]]:\n    return hnp.arrays(\n        np.float64,\n        hnp.array_shapes(min_dims=min_dims, max_dims=max_dims).map(\n            lambda s: (*s, 3, 3)\n        ),\n        elements=hnp.from_dtype(np.dtype(np.float16), min_value=-1.0, max_value=1.0),\n    ).map(jnp.asarray)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/testing/#liblaf.apple.jax.testing.random_spd_matrix","title":"random_spd_matrix","text":"<pre><code>random_spd_matrix(\n    draw: DrawFn,\n    dtypes: SearchStrategy[DTypeLike] | None = None,\n    n_dim: int = 3,\n    shapes: SearchStrategy[Sequence[int]] | None = None,\n) -&gt; Float[Array, \"*batch D D\"]\n</code></pre> Source code in <code>src/liblaf/apple/jax/testing/_matrix.py</code> <pre><code>@st.composite\ndef random_spd_matrix(\n    draw: st.DrawFn,\n    dtypes: st.SearchStrategy[DTypeLike] | None = None,\n    n_dim: int = 3,\n    shapes: st.SearchStrategy[Sequence[int]] | None = None,\n) -&gt; Float[Array, \"*batch D D\"]:\n    if dtypes is None:\n        dtypes = hnp.floating_dtypes(endianness=\"=\", sizes=[32, 64])\n    if shapes is None:\n        shapes = hnp.array_shapes(min_dims=1, max_dims=1)\n    dtype: DTypeLike = draw(dtypes)\n    shape: Sequence[int] = draw(shapes)\n    A: Float[np.ndarray, \"*batch D D\"] = draw(\n        hnp.arrays(\n            dtype,\n            (*shape, n_dim, n_dim),\n            elements=hnp.from_dtype(np.dtype(np.float16), min_value=1.0, max_value=2.0),\n        )\n    )\n    X: Float[np.ndarray, \"*batch D D\"] = 0.5 * (A.mT + A) + n_dim * np.identity(\n        n_dim, dtype\n    )\n    return jnp.asarray(X, dtype)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/testing/#liblaf.apple.jax.testing.rosen","title":"rosen","text":"<pre><code>rosen(x: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/jax/testing/_rosen.py</code> <pre><code>def rosen(x: Vector) -&gt; Scalar:\n    return jnp.sum(\n        100.0 * jnp.square(x[1:] - jnp.square(x[:-1])) + jnp.square(1.0 - x[:-1])\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/jax/testing/#liblaf.apple.jax.testing.rosen_der","title":"rosen_der","text":"<pre><code>rosen_der(x: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/testing/_rosen.py</code> <pre><code>def rosen_der(x: Vector) -&gt; Vector:\n    return jax.grad(rosen)(x)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/testing/#liblaf.apple.jax.testing.rosen_hess","title":"rosen_hess","text":"<pre><code>rosen_hess(x: Vector) -&gt; Float[Array, 'I I']\n</code></pre> Source code in <code>src/liblaf/apple/jax/testing/_rosen.py</code> <pre><code>def rosen_hess(x: Vector) -&gt; Float[Array, \"I I\"]:\n    return jax.hessian(rosen)(x)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/testing/#liblaf.apple.jax.testing.rosen_hess_prod","title":"rosen_hess_prod","text":"<pre><code>rosen_hess_prod(x: Vector, p: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/jax/testing/_rosen.py</code> <pre><code>def rosen_hess_prod(x: Vector, p: Vector) -&gt; Vector:\n    return math.hess_prod(rosen, x, p)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/tree/","title":"tree","text":""},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree","title":"liblaf.apple.jax.tree","text":"<p>Classes:</p> <ul> <li> <code>IdMixin</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>array</code>             \u2013              </li> <li> <code>container</code>             \u2013              </li> <li> <code>field</code>             \u2013              </li> <li> <code>flatten</code>             \u2013              </li> <li> <code>pytree</code>             \u2013              </li> <li> <code>register_attrs</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree.IdMixin","title":"IdMixin","text":"<p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree.IdMixin.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree.array","title":"array","text":"<pre><code>array(**kwargs: Unpack[FieldOptions]) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/apple/jax/tree/_field_specifiers.py</code> <pre><code>def array(**kwargs: Unpack[FieldOptions]) -&gt; Any:\n    kwargs.setdefault(\"converter\", _optional_as_array)\n    return field(**kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree.container","title":"container","text":"<pre><code>container(**kwargs: Unpack[FieldOptions]) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/apple/jax/tree/_field_specifiers.py</code> <pre><code>def container(**kwargs: Unpack[FieldOptions]) -&gt; Any:\n    if \"converter\" in kwargs and \"factory\" not in kwargs:\n        kwargs[\"factory\"] = kwargs[\"converter\"]  # pyright: ignore[reportGeneralTypeIssues]\n    elif \"converter\" not in kwargs and \"factory\" in kwargs:\n        kwargs[\"converter\"] = kwargs[\"factory\"]  # pyright: ignore[reportGeneralTypeIssues]\n    elif \"converter\" not in kwargs and \"factory\" not in kwargs:\n        kwargs[\"converter\"] = _dict_if_none\n        kwargs[\"factory\"] = dict\n    return field(**kwargs)  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree.field","title":"field","text":"<pre><code>field(**kwargs: Unpack[FieldOptions]) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/apple/jax/tree/_field_specifiers.py</code> <pre><code>def field(**kwargs: Unpack[FieldOptions]) -&gt; Any:\n    if \"default_factory\" in kwargs:\n        kwargs.setdefault(\"factory\", kwargs.pop(\"default_factory\"))\n    return attrs.field(**kwargs)  # pyright: ignore[reportCallIssue]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree.flatten","title":"flatten","text":"<pre><code>flatten(obj: T) -&gt; tuple[Array, Callable[[Array], T]]\n</code></pre> Source code in <code>src/liblaf/apple/jax/tree/_flatten.py</code> <pre><code>def flatten[T](obj: T) -&gt; tuple[Array, Callable[[Array], T]]:\n    data: T\n    meta: T\n    data, meta = eqx.partition(obj, eqx.is_array)\n    flat: Array\n    unravel: Callable[[Array], T]\n    flat, unravel = jax.flatten_util.ravel_pytree(data)\n\n    def unflatten(a: ArrayLike, /) -&gt; T:\n        a = math.asarray(a, dtype=flat.dtype)\n        data: T = unravel(a)\n        data = eqx.combine(data, meta)\n        return data\n\n    return flat, unflatten\n</code></pre>"},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree.pytree","title":"pytree","text":"<pre><code>pytree(\n    cls: C,\n    /,\n    *,\n    these: dict[str, Any] | None = ...,\n    repr: bool = ...,\n    unsafe_hash: bool | None = ...,\n    hash: bool | None = ...,\n    init: bool = ...,\n    slots: bool = ...,\n    frozen: bool = ...,\n    weakref_slot: bool = ...,\n    str: bool = ...,\n    auto_attribs: bool = ...,\n    kw_only: bool = ...,\n    cache_hash: bool = ...,\n    auto_exc: bool = ...,\n    eq: bool | None = ...,\n    order: bool | None = ...,\n    auto_detect: bool = ...,\n    getstate_setstate: bool | None = ...,\n    on_setattr: OnSetAttrArgType | None = ...,\n    field_transformer: FieldTransformer | None = ...,\n    match_args: bool = ...,\n) -&gt; C\n</code></pre><pre><code>pytree(\n    *,\n    these: dict[str, Any] | None = ...,\n    repr: bool = ...,\n    unsafe_hash: bool | None = ...,\n    hash: bool | None = ...,\n    init: bool = ...,\n    slots: bool = ...,\n    frozen: bool = ...,\n    weakref_slot: bool = ...,\n    str: bool = ...,\n    auto_attribs: bool = ...,\n    kw_only: bool = ...,\n    cache_hash: bool = ...,\n    auto_exc: bool = ...,\n    eq: bool | None = ...,\n    order: bool | None = ...,\n    auto_detect: bool = ...,\n    getstate_setstate: bool | None = ...,\n    on_setattr: OnSetAttrArgType | None = ...,\n    field_transformer: FieldTransformer | None = ...,\n    match_args: bool = ...,\n) -&gt; Callable[[C], C]\n</code></pre> <pre><code>pytree(cls: type | None = None, /, **kwargs) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/apple/jax/tree/_pytree.py</code> <pre><code>@dataclass_transform(field_specifiers=(attrs.field, array, container, field))\ndef pytree[C: type](cls: type | None = None, /, **kwargs) -&gt; Any:\n    if cls is None:\n        return functools.partial(pytree, **kwargs)\n    kwargs.setdefault(\"repr\", False)\n    cls = attrs.define(cls, **kwargs)\n    cls = register_attrs(cls)\n    cls = grapes.auto_repr(cls)\n    return cls\n</code></pre>"},{"location":"reference/liblaf/apple/jax/tree/#liblaf.apple.jax.tree.register_attrs","title":"register_attrs","text":"<pre><code>register_attrs(\n    cls: T,\n    data_fields: Iterable[str] | None = None,\n    meta_fields: Iterable[str] | None = None,\n) -&gt; T\n</code></pre> Source code in <code>src/liblaf/apple/jax/tree/_register_attrs.py</code> <pre><code>def register_attrs[T: type](\n    cls: T,\n    data_fields: Iterable[str] | None = None,\n    meta_fields: Iterable[str] | None = None,\n) -&gt; T:\n    flattener: Flattener[T] = Flattener.from_cls(\n        cls, data_fields=data_fields, meta_fields=meta_fields\n    )\n    jtu.register_pytree_with_keys(\n        cls,\n        flatten_with_keys=flattener.flatten_with_keys,\n        unflatten_func=flattener.unflatten,\n        flatten_func=flattener.flatten,\n    )\n    return cls\n</code></pre>"},{"location":"reference/liblaf/apple/jax/typing/","title":"typing","text":""},{"location":"reference/liblaf/apple/jax/typing/#liblaf.apple.jax.typing","title":"liblaf.apple.jax.typing","text":"<p>Type Aliases:</p> <ul> <li> <code>Scalar</code>           \u2013            </li> <li> <code>Updates</code>           \u2013            </li> <li> <code>UpdatesData</code>           \u2013            </li> <li> <code>UpdatesIndex</code>           \u2013            </li> <li> <code>Vector</code>           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>float_</code>           \u2013            </li> <li> <code>int_</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/jax/typing/#liblaf.apple.jax.typing.float_","title":"float_  <code>module-attribute</code>","text":"<pre><code>float_ = float64\n</code></pre>"},{"location":"reference/liblaf/apple/jax/typing/#liblaf.apple.jax.typing.int_","title":"int_  <code>module-attribute</code>","text":"<pre><code>int_ = int32\n</code></pre>"},{"location":"reference/liblaf/apple/jax/typing/#liblaf.apple.jax.typing.Scalar","title":"Scalar","text":"<pre><code>Scalar = Float[Array, '']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/typing/#liblaf.apple.jax.typing.Updates","title":"Updates","text":"<pre><code>Updates = tuple[UpdatesData, UpdatesIndex]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/typing/#liblaf.apple.jax.typing.UpdatesData","title":"UpdatesData","text":"<pre><code>UpdatesData = Float[Array, 'Any ...']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/typing/#liblaf.apple.jax.typing.UpdatesIndex","title":"UpdatesIndex","text":"<pre><code>UpdatesIndex = Integer[Array, ' Any']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/typing/#liblaf.apple.jax.typing.Vector","title":"Vector","text":"<pre><code>Vector = Float[Array, '*DoF']\n</code></pre>"},{"location":"reference/liblaf/apple/jax/utils/","title":"utils","text":""},{"location":"reference/liblaf/apple/jax/utils/#liblaf.apple.jax.utils","title":"liblaf.apple.jax.utils","text":"<p>Functions:</p> <ul> <li> <code>get_cells_global</code>             \u2013              </li> <li> <code>get_cells_local</code>             \u2013              </li> <li> <code>get_point_id</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/jax/utils/#liblaf.apple.jax.utils.get_cells_global","title":"get_cells_global","text":"<pre><code>get_cells_global(mesh: DataSet) -&gt; Integer[Array, 'c a']\n</code></pre> Source code in <code>src/liblaf/apple/jax/utils/_pyvista.py</code> <pre><code>def get_cells_global(mesh: pv.DataSet) -&gt; Integer[Array, \"c a\"]:\n    point_id: Integer[Array, \" p\"] = get_point_id(mesh)\n    cells_local: Integer[Array, \"c a\"] = get_cells_local(mesh)\n    return point_id[cells_local]\n</code></pre>"},{"location":"reference/liblaf/apple/jax/utils/#liblaf.apple.jax.utils.get_cells_local","title":"get_cells_local","text":"<pre><code>get_cells_local(mesh: DataSet) -&gt; Integer[Array, 'c a']\n</code></pre> Source code in <code>src/liblaf/apple/jax/utils/_pyvista.py</code> <pre><code>def get_cells_local(mesh: pv.DataSet) -&gt; Integer[Array, \"c a\"]:\n    if isinstance(mesh, pv.PolyData):\n        return math.asarray(mesh.regular_faces, dtype=jnp.int32)\n    if isinstance(mesh, pv.UnstructuredGrid):\n        return math.asarray(mesh.cells_dict[pv.CellType.TETRA], dtype=jnp.int32)  # pyright: ignore[reportArgumentType]\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/jax/utils/#liblaf.apple.jax.utils.get_point_id","title":"get_point_id","text":"<pre><code>get_point_id(mesh: DataSet) -&gt; Integer[Array, ' p']\n</code></pre> Source code in <code>src/liblaf/apple/jax/utils/_pyvista.py</code> <pre><code>def get_point_id(mesh: pv.DataSet) -&gt; Integer[Array, \" p\"]:\n    return math.asarray(mesh.point_data[\"point-ids\"], dtype=jnp.int32)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/","title":"sim","text":""},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim","title":"liblaf.apple.sim","text":"<p>Modules:</p> <ul> <li> <code>model</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Model</code>           \u2013            </li> <li> <code>ModelBuilder</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model","title":"Model","text":"<p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>, default:                   <code>Array([], shape=(0, 3), dtype=float32)</code> )           \u2013            </li> <li> <code>dirichlet</code>               (<code>Dirichlet</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>model_jax</code>               (<code>Model</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>model_warp</code>               (<code>Model</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> <li> <code>reshape_or_extract_free</code>             \u2013              </li> <li> <code>to_full</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dirichlet</code>               (<code>Dirichlet</code>)           \u2013            </li> <li> <code>fun_and_jac_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>fun_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>hess_diag_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>hess_prod_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>hess_quad_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>jac_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>model_jax</code>               (<code>Model</code>)           \u2013            </li> <li> <code>model_warp</code>               (<code>Model</code>)           \u2013            </li> <li> <code>n_dirichlet</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_dofs</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_free</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.dirichlet","title":"dirichlet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirichlet: Dirichlet = field(factory=Dirichlet)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.fun_and_jac_jax_callable","title":"fun_and_jac_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>fun_and_jac_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.fun_jax_callable","title":"fun_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>fun_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.hess_diag_jax_callable","title":"hess_diag_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>hess_diag_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.hess_prod_jax_callable","title":"hess_prod_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>hess_prod_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.hess_quad_jax_callable","title":"hess_quad_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>hess_quad_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.jac_and_hess_diag_jax_callable","title":"jac_and_hess_diag_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>jac_and_hess_diag_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.jac_jax_callable","title":"jac_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>jac_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.model_jax","title":"model_jax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_jax: Model = field(factory=Model)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.model_warp","title":"model_warp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_warp: Model = field(factory=Model)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.n_dirichlet","title":"n_dirichlet  <code>property</code>","text":"<pre><code>n_dirichlet: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.n_dofs","title":"n_dofs  <code>property</code>","text":"<pre><code>n_dofs: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.n_free","title":"n_free  <code>property</code>","text":"<pre><code>n_free: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, \"p J\"] = array(factory=_default_points)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef fun(self, u: Vector) -&gt; Scalar:\n    u_full: Vector = self.to_full(u)\n    outputs_jax: Scalar = self.model_jax.fun(u_full)\n    output_wp: Scalar\n    (output_wp,) = self.fun_jax_callable(u_full, output_dims={\"output\": (1,)})\n    output_wp = output_wp.squeeze()\n    return outputs_jax + output_wp\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Vector]:\n    u_full: Vector = self.to_full(u)\n    fun_jax: Scalar\n    jac_jax: Vector\n    fun_jax, jac_jax = self.model_jax.fun_and_jac(u_full)\n    fun_wp: Scalar\n    jac_wp: Vector\n    fun_wp, jac_wp = self.fun_and_jac_jax_callable(\n        u_full, output_dims={\"fun\": (1,), \"jac\": (self.n_points,)}\n    )\n    fun_wp = fun_wp.squeeze()\n    fun: Scalar = fun_jax + fun_wp\n    jac: Vector = jac_jax + jac_wp\n    jac = self.reshape_or_extract_free(jac, u.shape, zero=True)\n    return fun, jac\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef hess_diag(self, u: Vector) -&gt; Vector:\n    u_full: Vector = self.to_full(u)\n    hess_diag_jax: Vector = self.model_jax.hess_diag(u_full)\n    hess_diag_wp: Vector\n    (hess_diag_wp,) = self.hess_diag_jax_callable(\n        u_full, output_dims={\"output\": (self.n_points,)}\n    )\n    hess_diag: Vector = hess_diag_jax + hess_diag_wp\n    hess_diag = self.reshape_or_extract_free(hess_diag, u.shape, zero=False)\n    return hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef hess_prod(self, u: Vector, p: Vector) -&gt; Vector:\n    u_full: Vector = self.to_full(u)\n    p_full: Vector = self.to_full(p, zero=True)\n    hess_prod_jax: Vector = self.model_jax.hess_prod(u_full, p_full)\n    hess_prod_wp: Vector\n    (hess_prod_wp,) = self.hess_prod_jax_callable(\n        u_full, p_full, output_dims={\"output\": (self.n_points,)}\n    )\n    hess_prod: Vector = hess_prod_jax + hess_prod_wp\n    hess_prod = self.reshape_or_extract_free(hess_prod, u.shape, zero=False)\n    return hess_prod\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    u_full: Vector = self.to_full(u)\n    p_full: Vector = self.to_full(p, zero=True)\n    hess_quad_jax: Scalar = self.model_jax.hess_quad(u_full, p_full)\n    hess_quad_wp: Scalar\n    (hess_quad_wp,) = self.hess_quad_jax_callable(\n        u_full, p_full, output_dims={\"output\": (1,)}\n    )\n    hess_quad_wp = hess_quad_wp.squeeze()\n    return hess_quad_jax + hess_quad_wp\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef jac(self, u: Vector) -&gt; Vector:\n    u_full: Vector = self.to_full(u)\n    jac_jax: Vector = self.model_jax.jac(u_full)\n    jac_wp: Vector\n    (jac_wp,) = self.jac_jax_callable(\n        u_full, output_dims={\"output\": (self.n_points,)}\n    )\n    jac: Vector = jac_jax + jac_wp\n    jac = self.reshape_or_extract_free(jac, u.shape, zero=True)\n    return jac\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Vector, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef jac_and_hess_diag(self, u: Vector) -&gt; tuple[Vector, Vector]:\n    u_full: Vector = self.to_full(u)\n    jac_jax: Vector\n    hess_diag_jax: Vector\n    jac_jax, hess_diag_jax = self.model_jax.jac_and_hess_diag(u_full)\n    jac_wp: Vector\n    hess_diag_wp: Vector\n    jac_wp, hess_diag_wp = self.jac_and_hess_diag_jax_callable(\n        u_full, output_dims={\"jac\": (self.n_points,), \"hess_diag\": (self.n_points,)}\n    )\n    jac: Vector = jac_jax + jac_wp\n    hess_diag: Vector = hess_diag_jax + hess_diag_wp\n    jac = self.reshape_or_extract_free(jac, u.shape, zero=True)\n    hess_diag = self.reshape_or_extract_free(hess_diag, u.shape, zero=False)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, dict[str, Array]]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>def mixed_derivative_prod(\n    self, u: Vector, p: Vector\n) -&gt; dict[str, dict[str, Array]]:\n    u_full: Vector = self.to_full(u)\n    p_full: Vector = self.to_full(p, zero=True)\n    outputs: dict[str, dict[str, Array]] = self.model_jax.mixed_derivative_prod(\n        u_full, p_full\n    )\n    outputs_wp: dict[str, dict[str, wp.array]] = (\n        self.model_warp.mixed_derivative_prod(\n            wp_utils.to_warp(u_full, vec3), wp_utils.to_warp(p_full, vec3)\n        )\n    )\n    for key, value in outputs_wp.items():\n        outputs[key] = {k: wp.to_jax(v) for k, v in value.items()}\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.reshape_or_extract_free","title":"reshape_or_extract_free","text":"<pre><code>reshape_or_extract_free(\n    u: Vector, shape: Sequence[int], *, zero: bool = False\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>def reshape_or_extract_free(\n    self, u: Vector, shape: Sequence[int], *, zero: bool = False\n) -&gt; Vector:\n    if u.size == np.prod(shape):\n        u = u.reshape(shape)\n        if zero:\n            u = self.dirichlet.zero(u)\n        return u\n    return self.dirichlet.get_free(u)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.Model.to_full","title":"to_full","text":"<pre><code>to_full(u: Vector, *, zero: bool = False) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>def to_full(self, u: Vector, *, zero: bool = False) -&gt; Vector:\n    if u.size == self.n_dofs:\n        return u.reshape(self.points.shape)\n    full: Vector = jnp.zeros_like(self.points)\n    full = self.dirichlet.set_free(full, u)\n    full = self.dirichlet.zero(full) if zero else self.dirichlet.apply(full)\n    return full\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder","title":"ModelBuilder","text":"<p>Parameters:</p> <ul> <li> <code>dirichlet</code>               (<code>DirichletBuilder</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>energies_jax</code>               (<code>dict[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>energies_warp</code>               (<code>dict[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>, default:                   <code>Array([], shape=(0, 3), dtype=float32)</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>add_dirichlet</code>             \u2013              </li> <li> <code>add_energy</code>             \u2013              </li> <li> <code>assign_dofs</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> <li> <code>finish_jax</code>             \u2013              </li> <li> <code>finish_warp</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dirichlet</code>               (<code>DirichletBuilder</code>)           \u2013            </li> <li> <code>energies_jax</code>               (<code>dict[str, Energy]</code>)           \u2013            </li> <li> <code>energies_warp</code>               (<code>dict[str, Energy]</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.dirichlet","title":"dirichlet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirichlet: DirichletBuilder = field(\n    factory=DirichletBuilder\n)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.energies_jax","title":"energies_jax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies_jax: dict[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.energies_warp","title":"energies_warp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies_warp: dict[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, \"p J\"] = array(factory=_default_points)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.add_dirichlet","title":"add_dirichlet","text":"<pre><code>add_dirichlet(mesh: DataSet) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def add_dirichlet(self, mesh: pv.DataSet) -&gt; None:\n    self.dirichlet.add(mesh)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.add_energy","title":"add_energy","text":"<pre><code>add_energy(energy: Energy | Energy) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def add_energy(self, energy: EnergyJax | EnergyWarp) -&gt; None:\n    if isinstance(energy, EnergyJax):\n        self.energies_jax[energy.id] = energy\n    elif isinstance(energy, EnergyWarp):\n        self.energies_warp[energy.id] = energy\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.assign_dofs","title":"assign_dofs","text":"<pre><code>assign_dofs(mesh: T) -&gt; T\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def assign_dofs[T: pv.DataSet](self, mesh: T) -&gt; T:\n    mesh.point_data[\"point-ids\"] = np.arange(\n        self.n_points, self.n_points + mesh.n_points\n    )\n    self.points = jnp.concat([self.points, mesh.points])\n    self.dirichlet.resize(self.n_points)\n    return mesh\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.finish","title":"finish","text":"<pre><code>finish() -&gt; Model\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def finish(self) -&gt; Model:\n    return Model(\n        points=self.points,\n        dirichlet=self.dirichlet.finish(),\n        model_jax=self.finish_jax(),\n        model_warp=self.finish_warp(),\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.finish_jax","title":"finish_jax","text":"<pre><code>finish_jax() -&gt; Model\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def finish_jax(self) -&gt; ModelJax:\n    return ModelJax(energies=self.energies_jax)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.ModelBuilder.finish_warp","title":"finish_warp","text":"<pre><code>finish_warp() -&gt; Model\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def finish_warp(self) -&gt; ModelWarp:\n    return ModelWarp(energies=self.energies_warp)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.fun","title":"fun","text":"<pre><code>fun(x: Vector, model: Model, *args, **kwargs) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef fun(x: Vector, model: Model, *args, **kwargs) -&gt; Scalar:\n    return model.fun(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(\n    x: Vector, model: Model, *args, **kwargs\n) -&gt; tuple[Scalar, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef fun_and_jac(x: Vector, model: Model, *args, **kwargs) -&gt; tuple[Scalar, Vector]:\n    return model.fun_and_jac(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(\n    x: Vector, model: Model, *args, **kwargs\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef hess_diag(x: Vector, model: Model, *args, **kwargs) -&gt; Vector:\n    return model.hess_diag(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(\n    x: Vector, p: Vector, model: Model, *args, **kwargs\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef hess_prod(x: Vector, p: Vector, model: Model, *args, **kwargs) -&gt; Vector:\n    return model.hess_prod(x, p, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(\n    x: Vector, p: Vector, model: Model, *args, **kwargs\n) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef hess_quad(x: Vector, p: Vector, model: Model, *args, **kwargs) -&gt; Scalar:\n    return model.hess_quad(x, p, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.jac","title":"jac","text":"<pre><code>jac(x: Vector, model: Model, *args, **kwargs) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef jac(x: Vector, model: Model, *args, **kwargs) -&gt; Vector:\n    return model.jac(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/#liblaf.apple.sim.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    x: Vector, model: Model, *args, **kwargs\n) -&gt; tuple[Vector, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef jac_and_hess_diag(\n    x: Vector, model: Model, *args, **kwargs\n) -&gt; tuple[Vector, Vector]:\n    return model.jac_and_hess_diag(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/","title":"model","text":""},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model","title":"liblaf.apple.sim.model","text":"<p>Classes:</p> <ul> <li> <code>Model</code>           \u2013            </li> <li> <code>ModelBuilder</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model","title":"Model","text":"<p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>, default:                   <code>Array([], shape=(0, 3), dtype=float32)</code> )           \u2013            </li> <li> <code>dirichlet</code>               (<code>Dirichlet</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>model_jax</code>               (<code>Model</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>model_warp</code>               (<code>Model</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> <li> <code>reshape_or_extract_free</code>             \u2013              </li> <li> <code>to_full</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dirichlet</code>               (<code>Dirichlet</code>)           \u2013            </li> <li> <code>fun_and_jac_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>fun_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>hess_diag_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>hess_prod_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>hess_quad_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>jac_jax_callable</code>               (<code>FfiCallable</code>)           \u2013            </li> <li> <code>model_jax</code>               (<code>Model</code>)           \u2013            </li> <li> <code>model_warp</code>               (<code>Model</code>)           \u2013            </li> <li> <code>n_dirichlet</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_dofs</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_free</code>               (<code>int</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.dirichlet","title":"dirichlet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirichlet: Dirichlet = field(factory=Dirichlet)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.fun_and_jac_jax_callable","title":"fun_and_jac_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>fun_and_jac_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.fun_jax_callable","title":"fun_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>fun_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.hess_diag_jax_callable","title":"hess_diag_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>hess_diag_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.hess_prod_jax_callable","title":"hess_prod_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>hess_prod_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.hess_quad_jax_callable","title":"hess_quad_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>hess_quad_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.jac_and_hess_diag_jax_callable","title":"jac_and_hess_diag_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>jac_and_hess_diag_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.jac_jax_callable","title":"jac_jax_callable  <code>cached</code> <code>property</code>","text":"<pre><code>jac_jax_callable: FfiCallable\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.model_jax","title":"model_jax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_jax: Model = field(factory=Model)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.model_warp","title":"model_warp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_warp: Model = field(factory=Model)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.n_dirichlet","title":"n_dirichlet  <code>property</code>","text":"<pre><code>n_dirichlet: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.n_dofs","title":"n_dofs  <code>property</code>","text":"<pre><code>n_dofs: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.n_free","title":"n_free  <code>property</code>","text":"<pre><code>n_free: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, \"p J\"] = array(factory=_default_points)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.fun","title":"fun","text":"<pre><code>fun(u: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef fun(self, u: Vector) -&gt; Scalar:\n    u_full: Vector = self.to_full(u)\n    outputs_jax: Scalar = self.model_jax.fun(u_full)\n    output_wp: Scalar\n    (output_wp,) = self.fun_jax_callable(u_full, output_dims={\"output\": (1,)})\n    output_wp = output_wp.squeeze()\n    return outputs_jax + output_wp\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: Vector) -&gt; tuple[Scalar, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef fun_and_jac(self, u: Vector) -&gt; tuple[Scalar, Vector]:\n    u_full: Vector = self.to_full(u)\n    fun_jax: Scalar\n    jac_jax: Vector\n    fun_jax, jac_jax = self.model_jax.fun_and_jac(u_full)\n    fun_wp: Scalar\n    jac_wp: Vector\n    fun_wp, jac_wp = self.fun_and_jac_jax_callable(\n        u_full, output_dims={\"fun\": (1,), \"jac\": (self.n_points,)}\n    )\n    fun_wp = fun_wp.squeeze()\n    fun: Scalar = fun_jax + fun_wp\n    jac: Vector = jac_jax + jac_wp\n    jac = self.reshape_or_extract_free(jac, u.shape, zero=True)\n    return fun, jac\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef hess_diag(self, u: Vector) -&gt; Vector:\n    u_full: Vector = self.to_full(u)\n    hess_diag_jax: Vector = self.model_jax.hess_diag(u_full)\n    hess_diag_wp: Vector\n    (hess_diag_wp,) = self.hess_diag_jax_callable(\n        u_full, output_dims={\"output\": (self.n_points,)}\n    )\n    hess_diag: Vector = hess_diag_jax + hess_diag_wp\n    hess_diag = self.reshape_or_extract_free(hess_diag, u.shape, zero=False)\n    return hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: Vector, p: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef hess_prod(self, u: Vector, p: Vector) -&gt; Vector:\n    u_full: Vector = self.to_full(u)\n    p_full: Vector = self.to_full(p, zero=True)\n    hess_prod_jax: Vector = self.model_jax.hess_prod(u_full, p_full)\n    hess_prod_wp: Vector\n    (hess_prod_wp,) = self.hess_prod_jax_callable(\n        u_full, p_full, output_dims={\"output\": (self.n_points,)}\n    )\n    hess_prod: Vector = hess_prod_jax + hess_prod_wp\n    hess_prod = self.reshape_or_extract_free(hess_prod, u.shape, zero=False)\n    return hess_prod\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: Vector, p: Vector) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef hess_quad(self, u: Vector, p: Vector) -&gt; Scalar:\n    u_full: Vector = self.to_full(u)\n    p_full: Vector = self.to_full(p, zero=True)\n    hess_quad_jax: Scalar = self.model_jax.hess_quad(u_full, p_full)\n    hess_quad_wp: Scalar\n    (hess_quad_wp,) = self.hess_quad_jax_callable(\n        u_full, p_full, output_dims={\"output\": (1,)}\n    )\n    hess_quad_wp = hess_quad_wp.squeeze()\n    return hess_quad_jax + hess_quad_wp\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.jac","title":"jac","text":"<pre><code>jac(u: Vector) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef jac(self, u: Vector) -&gt; Vector:\n    u_full: Vector = self.to_full(u)\n    jac_jax: Vector = self.model_jax.jac(u_full)\n    jac_wp: Vector\n    (jac_wp,) = self.jac_jax_callable(\n        u_full, output_dims={\"output\": (self.n_points,)}\n    )\n    jac: Vector = jac_jax + jac_wp\n    jac = self.reshape_or_extract_free(jac, u.shape, zero=True)\n    return jac\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(u: Vector) -&gt; tuple[Vector, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>@eqx.filter_jit\ndef jac_and_hess_diag(self, u: Vector) -&gt; tuple[Vector, Vector]:\n    u_full: Vector = self.to_full(u)\n    jac_jax: Vector\n    hess_diag_jax: Vector\n    jac_jax, hess_diag_jax = self.model_jax.jac_and_hess_diag(u_full)\n    jac_wp: Vector\n    hess_diag_wp: Vector\n    jac_wp, hess_diag_wp = self.jac_and_hess_diag_jax_callable(\n        u_full, output_dims={\"jac\": (self.n_points,), \"hess_diag\": (self.n_points,)}\n    )\n    jac: Vector = jac_jax + jac_wp\n    hess_diag: Vector = hess_diag_jax + hess_diag_wp\n    jac = self.reshape_or_extract_free(jac, u.shape, zero=True)\n    hess_diag = self.reshape_or_extract_free(hess_diag, u.shape, zero=False)\n    return jac, hess_diag\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: Vector, p: Vector\n) -&gt; dict[str, dict[str, Array]]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>def mixed_derivative_prod(\n    self, u: Vector, p: Vector\n) -&gt; dict[str, dict[str, Array]]:\n    u_full: Vector = self.to_full(u)\n    p_full: Vector = self.to_full(p, zero=True)\n    outputs: dict[str, dict[str, Array]] = self.model_jax.mixed_derivative_prod(\n        u_full, p_full\n    )\n    outputs_wp: dict[str, dict[str, wp.array]] = (\n        self.model_warp.mixed_derivative_prod(\n            wp_utils.to_warp(u_full, vec3), wp_utils.to_warp(p_full, vec3)\n        )\n    )\n    for key, value in outputs_wp.items():\n        outputs[key] = {k: wp.to_jax(v) for k, v in value.items()}\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.reshape_or_extract_free","title":"reshape_or_extract_free","text":"<pre><code>reshape_or_extract_free(\n    u: Vector, shape: Sequence[int], *, zero: bool = False\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>def reshape_or_extract_free(\n    self, u: Vector, shape: Sequence[int], *, zero: bool = False\n) -&gt; Vector:\n    if u.size == np.prod(shape):\n        u = u.reshape(shape)\n        if zero:\n            u = self.dirichlet.zero(u)\n        return u\n    return self.dirichlet.get_free(u)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.Model.to_full","title":"to_full","text":"<pre><code>to_full(u: Vector, *, zero: bool = False) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_model.py</code> <pre><code>def to_full(self, u: Vector, *, zero: bool = False) -&gt; Vector:\n    if u.size == self.n_dofs:\n        return u.reshape(self.points.shape)\n    full: Vector = jnp.zeros_like(self.points)\n    full = self.dirichlet.set_free(full, u)\n    full = self.dirichlet.zero(full) if zero else self.dirichlet.apply(full)\n    return full\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder","title":"ModelBuilder","text":"<p>Parameters:</p> <ul> <li> <code>dirichlet</code>               (<code>DirichletBuilder</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>energies_jax</code>               (<code>dict[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>energies_warp</code>               (<code>dict[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>, default:                   <code>Array([], shape=(0, 3), dtype=float32)</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>add_dirichlet</code>             \u2013              </li> <li> <code>add_energy</code>             \u2013              </li> <li> <code>assign_dofs</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> <li> <code>finish_jax</code>             \u2013              </li> <li> <code>finish_warp</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>dirichlet</code>               (<code>DirichletBuilder</code>)           \u2013            </li> <li> <code>energies_jax</code>               (<code>dict[str, Energy]</code>)           \u2013            </li> <li> <code>energies_warp</code>               (<code>dict[str, Energy]</code>)           \u2013            </li> <li> <code>n_points</code>               (<code>int</code>)           \u2013            </li> <li> <code>points</code>               (<code>Float[Array, 'p J']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.dirichlet","title":"dirichlet  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirichlet: DirichletBuilder = field(\n    factory=DirichletBuilder\n)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.energies_jax","title":"energies_jax  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies_jax: dict[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.energies_warp","title":"energies_warp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies_warp: dict[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.n_points","title":"n_points  <code>property</code>","text":"<pre><code>n_points: int\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.points","title":"points  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>points: Float[Array, \"p J\"] = array(factory=_default_points)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.add_dirichlet","title":"add_dirichlet","text":"<pre><code>add_dirichlet(mesh: DataSet) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def add_dirichlet(self, mesh: pv.DataSet) -&gt; None:\n    self.dirichlet.add(mesh)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.add_energy","title":"add_energy","text":"<pre><code>add_energy(energy: Energy | Energy) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def add_energy(self, energy: EnergyJax | EnergyWarp) -&gt; None:\n    if isinstance(energy, EnergyJax):\n        self.energies_jax[energy.id] = energy\n    elif isinstance(energy, EnergyWarp):\n        self.energies_warp[energy.id] = energy\n    else:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.assign_dofs","title":"assign_dofs","text":"<pre><code>assign_dofs(mesh: T) -&gt; T\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def assign_dofs[T: pv.DataSet](self, mesh: T) -&gt; T:\n    mesh.point_data[\"point-ids\"] = np.arange(\n        self.n_points, self.n_points + mesh.n_points\n    )\n    self.points = jnp.concat([self.points, mesh.points])\n    self.dirichlet.resize(self.n_points)\n    return mesh\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.finish","title":"finish","text":"<pre><code>finish() -&gt; Model\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def finish(self) -&gt; Model:\n    return Model(\n        points=self.points,\n        dirichlet=self.dirichlet.finish(),\n        model_jax=self.finish_jax(),\n        model_warp=self.finish_warp(),\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.finish_jax","title":"finish_jax","text":"<pre><code>finish_jax() -&gt; Model\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def finish_jax(self) -&gt; ModelJax:\n    return ModelJax(energies=self.energies_jax)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.ModelBuilder.finish_warp","title":"finish_warp","text":"<pre><code>finish_warp() -&gt; Model\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_builder.py</code> <pre><code>def finish_warp(self) -&gt; ModelWarp:\n    return ModelWarp(energies=self.energies_warp)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.fun","title":"fun","text":"<pre><code>fun(x: Vector, model: Model, *args, **kwargs) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef fun(x: Vector, model: Model, *args, **kwargs) -&gt; Scalar:\n    return model.fun(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(\n    x: Vector, model: Model, *args, **kwargs\n) -&gt; tuple[Scalar, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef fun_and_jac(x: Vector, model: Model, *args, **kwargs) -&gt; tuple[Scalar, Vector]:\n    return model.fun_and_jac(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(\n    x: Vector, model: Model, *args, **kwargs\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef hess_diag(x: Vector, model: Model, *args, **kwargs) -&gt; Vector:\n    return model.hess_diag(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(\n    x: Vector, p: Vector, model: Model, *args, **kwargs\n) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef hess_prod(x: Vector, p: Vector, model: Model, *args, **kwargs) -&gt; Vector:\n    return model.hess_prod(x, p, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(\n    x: Vector, p: Vector, model: Model, *args, **kwargs\n) -&gt; Scalar\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef hess_quad(x: Vector, p: Vector, model: Model, *args, **kwargs) -&gt; Scalar:\n    return model.hess_quad(x, p, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.jac","title":"jac","text":"<pre><code>jac(x: Vector, model: Model, *args, **kwargs) -&gt; Vector\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef jac(x: Vector, model: Model, *args, **kwargs) -&gt; Vector:\n    return model.jac(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/sim/model/#liblaf.apple.sim.model.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    x: Vector, model: Model, *args, **kwargs\n) -&gt; tuple[Vector, Vector]\n</code></pre> Source code in <code>src/liblaf/apple/sim/model/_staticmethods.py</code> <pre><code>@eqx.filter_jit\ndef jac_and_hess_diag(\n    x: Vector, model: Model, *args, **kwargs\n) -&gt; tuple[Vector, Vector]:\n    return model.jac_and_hess_diag(x, *args, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/","title":"warp","text":""},{"location":"reference/liblaf/apple/warp/#liblaf.apple.warp","title":"liblaf.apple.warp","text":"<p>Modules:</p> <ul> <li> <code>math</code>           \u2013            </li> <li> <code>sim</code>           \u2013            </li> <li> <code>sparse</code>           \u2013            </li> <li> <code>typing</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/math/","title":"math","text":""},{"location":"reference/liblaf/apple/warp/math/#liblaf.apple.warp.math","title":"liblaf.apple.warp.math","text":"<p>Functions:</p> <ul> <li> <code>cw_square</code>             \u2013              </li> <li> <code>frobenius_norm_square</code>             \u2013              <p>\\(\\norm{M}_F^2\\).</p> </li> <li> <code>polar_rv</code>             \u2013              </li> <li> <code>square</code>             \u2013              </li> <li> <code>svd_rv</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/math/#liblaf.apple.warp.math.cw_square","title":"cw_square","text":"<pre><code>cw_square(a: Any)\n</code></pre> Source code in <code>src/liblaf/apple/warp/math/_misc.py</code> <pre><code>@wp.func\ndef cw_square(a: Any):\n    return wp.cw_mul(a, a)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/math/#liblaf.apple.warp.math.frobenius_norm_square","title":"frobenius_norm_square","text":"<pre><code>frobenius_norm_square(M: Any)\n</code></pre> <p>\\(\\norm{M}_F^2\\).</p> <p>Parameters:</p> <ul> <li> <code>M</code>               (<code>matrix</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/math/_misc.py</code> <pre><code>@wp.func\ndef frobenius_norm_square(M: Any):\n    r\"\"\"$\\norm{M}_F^2$.\n\n    Args:\n        M (matrix): ...\n\n    Returns:\n        (float): ...\n    \"\"\"\n    return wp.ddot(M, M)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/math/#liblaf.apple.warp.math.polar_rv","title":"polar_rv","text":"<pre><code>polar_rv(A: mat33d) -&gt; tuple[mat33d, mat33d]\n</code></pre> Source code in <code>src/liblaf/apple/warp/math/_rotation.py</code> <pre><code>@wp.func\n@no_type_check\ndef polar_rv(A: wpt.mat33d) -&gt; tuple[wpt.mat33d, wpt.mat33d]:\n    U, s, V = svd_rv(A)\n    R = U @ wp.transpose(V)\n    S = V @ wp.diag(s) @ wp.transpose(V)\n    return R, S\n</code></pre>"},{"location":"reference/liblaf/apple/warp/math/#liblaf.apple.warp.math.square","title":"square","text":"<pre><code>square(a: Any)\n</code></pre> Source code in <code>src/liblaf/apple/warp/math/_misc.py</code> <pre><code>@wp.func\ndef square(a: Any):\n    return a * a\n</code></pre>"},{"location":"reference/liblaf/apple/warp/math/#liblaf.apple.warp.math.svd_rv","title":"svd_rv","text":"<pre><code>svd_rv(A: mat33d) -&gt; tuple[mat33d, vec3d, mat33d]\n</code></pre> Source code in <code>src/liblaf/apple/warp/math/_rotation.py</code> <pre><code>@wp.func\n@no_type_check\ndef svd_rv(A: wpt.mat33d) -&gt; tuple[wpt.mat33d, wpt.vec3d, wpt.mat33d]:\n    U, s, V = wp.svd3(A)\n    return U, s, V\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/","title":"sim","text":""},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim","title":"liblaf.apple.warp.sim","text":"<p>Modules:</p> <ul> <li> <code>energy</code>           \u2013            </li> <li> <code>model</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Arap</code>           \u2013            <p>As-Rigid-As-Possible.</p> </li> <li> <code>ArapActive</code>           \u2013            </li> <li> <code>Elastic</code>           \u2013            </li> <li> <code>Energy</code>           \u2013            </li> <li> <code>Model</code>           \u2013            </li> <li> <code>Phace</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap","title":"Arap","text":"<p>               Bases: <code>Elastic</code></p> <p>As-Rigid-As-Possible.</p> \\[ \\Psi = \\frac{\\mu}{2} \\|F - R\\|_F^2 = \\frac{\\mu}{2} (I_2 - 2 I_1 + 3) \\] <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.arap.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params: Struct = func.Params()\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Arap.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive","title":"ArapActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params = func.Params()\n    params.activation = wp_utils.to_warp(\n        region.cell_data[\"activation\"],\n        dtype=vec6,\n        requires_grad=\"activation\" in self.requires_grad,\n    )\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.ArapActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic","title":"Elastic","text":"<p>               Bases: <code>Energy</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>def make_params(self, region: Region) -&gt; Struct:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Elastic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy","title":"Energy","text":"<p>               Bases: <code>IdMixin</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def fun(self, u: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    self.fun(u, fun)\n    self.jac(u, jac)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def jac(self, u: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    self.jac(u, jac)\n    self.hess_diag(u, hess_diag)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Energy.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:  # noqa: ARG002\n    if not self.requires_grad:\n        return {}\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model","title":"Model","text":"<p>Parameters:</p> <ul> <li> <code>energies</code>               (<code>Mapping[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>energies</code>               (<code>Mapping[str, Energy]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.energies","title":"energies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies: Mapping[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def fun(self, u: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.fun(u, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.fun_and_jac(u, fun, jac)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess(self, u: wp.array, output: Coo2d) -&gt; None:\n    start: int = 0\n    for energy in self.energies.values():\n        energy.hess(u, output, start=start)\n        start += energy.hess_size()\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.hess_diag(u, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.hess_prod(u, p, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.hess_quad(u, p, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess_size(self) -&gt; int:\n    size: int = 0\n    for energy in self.energies.values():\n        size += energy.hess_size()\n    return size\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def jac(self, u: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.jac(u, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    for energy in self.energies.values():\n        energy.jac_and_hess_diag(u, jac, hess_diag)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Model.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, dict[str, array]]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def mixed_derivative_prod(\n    self, u: wp.array, p: wp.array\n) -&gt; dict[str, dict[str, wp.array]]:\n    outputs: dict[str, dict[str, wp.array]] = {\n        energy.id: energy.mixed_derivative_prod(u, p)\n        for energy in self.energies.values()\n    }\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace","title":"Phace","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.phace.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params = func.Params()\n    params.activation = wp_utils.to_warp(\n        region.cell_data[\"activation\"],\n        dtype=vec6,\n        requires_grad=\"activation\" in self.requires_grad,\n    )\n    params.active_fraction = wp_utils.to_warp(\n        region.cell_data[\"active-fraction\"],\n        dtype=float_,\n        requires_grad=\"active-fraction\" in self.requires_grad,\n    )\n    params.lambda_ = wp_utils.to_warp(\n        region.cell_data[\"lambda\"],\n        dtype=float_,\n        requires_grad=\"lambda\" in self.requires_grad,\n    )\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/#liblaf.apple.warp.sim.Phace.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/","title":"energy","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy","title":"liblaf.apple.warp.sim.energy","text":"<p>Modules:</p> <ul> <li> <code>elastic</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Arap</code>           \u2013            <p>As-Rigid-As-Possible.</p> </li> <li> <code>ArapActive</code>           \u2013            </li> <li> <code>Elastic</code>           \u2013            </li> <li> <code>Energy</code>           \u2013            </li> <li> <code>Phace</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap","title":"Arap","text":"<p>               Bases: <code>Elastic</code></p> <p>As-Rigid-As-Possible.</p> \\[ \\Psi = \\frac{\\mu}{2} \\|F - R\\|_F^2 = \\frac{\\mu}{2} (I_2 - 2 I_1 + 3) \\] <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.arap.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params: Struct = func.Params()\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Arap.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive","title":"ArapActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params = func.Params()\n    params.activation = wp_utils.to_warp(\n        region.cell_data[\"activation\"],\n        dtype=vec6,\n        requires_grad=\"activation\" in self.requires_grad,\n    )\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.ArapActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic","title":"Elastic","text":"<p>               Bases: <code>Energy</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>def make_params(self, region: Region) -&gt; Struct:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Elastic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy","title":"Energy","text":"<p>               Bases: <code>IdMixin</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def fun(self, u: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    self.fun(u, fun)\n    self.jac(u, jac)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def jac(self, u: wp.array, output: wp.array) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    self.jac(u, jac)\n    self.hess_diag(u, hess_diag)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Energy.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/_energy.py</code> <pre><code>def mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:  # noqa: ARG002\n    if not self.requires_grad:\n        return {}\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace","title":"Phace","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.phace.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params = func.Params()\n    params.activation = wp_utils.to_warp(\n        region.cell_data[\"activation\"],\n        dtype=vec6,\n        requires_grad=\"activation\" in self.requires_grad,\n    )\n    params.active_fraction = wp_utils.to_warp(\n        region.cell_data[\"active-fraction\"],\n        dtype=float_,\n        requires_grad=\"active-fraction\" in self.requires_grad,\n    )\n    params.lambda_ = wp_utils.to_warp(\n        region.cell_data[\"lambda\"],\n        dtype=float_,\n        requires_grad=\"lambda\" in self.requires_grad,\n    )\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/#liblaf.apple.warp.sim.energy.Phace.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/","title":"elastic","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic","title":"liblaf.apple.warp.sim.energy.elastic","text":"<p>Modules:</p> <ul> <li> <code>arap</code>           \u2013            </li> <li> <code>arap_active</code>           \u2013            </li> <li> <code>func</code>           \u2013            </li> <li> <code>phace</code>           \u2013            </li> <li> <code>phace_passive</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Arap</code>           \u2013            <p>As-Rigid-As-Possible.</p> </li> <li> <code>ArapActive</code>           \u2013            </li> <li> <code>Elastic</code>           \u2013            </li> <li> <code>Phace</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap","title":"Arap","text":"<p>               Bases: <code>Elastic</code></p> <p>As-Rigid-As-Possible.</p> \\[ \\Psi = \\frac{\\mu}{2} \\|F - R\\|_F^2 = \\frac{\\mu}{2} (I_2 - 2 I_1 + 3) \\] <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.arap.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params: Struct = func.Params()\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Arap.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive","title":"ArapActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params = func.Params()\n    params.activation = wp_utils.to_warp(\n        region.cell_data[\"activation\"],\n        dtype=vec6,\n        requires_grad=\"activation\" in self.requires_grad,\n    )\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.ArapActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic","title":"Elastic","text":"<p>               Bases: <code>Energy</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=None\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>def make_params(self, region: Region) -&gt; Struct:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Elastic.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace","title":"Phace","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.phace.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params = func.Params()\n    params.activation = wp_utils.to_warp(\n        region.cell_data[\"activation\"],\n        dtype=vec6,\n        requires_grad=\"activation\" in self.requires_grad,\n    )\n    params.active_fraction = wp_utils.to_warp(\n        region.cell_data[\"active-fraction\"],\n        dtype=float_,\n        requires_grad=\"active-fraction\" in self.requires_grad,\n    )\n    params.lambda_ = wp_utils.to_warp(\n        region.cell_data[\"lambda\"],\n        dtype=float_,\n        requires_grad=\"lambda\" in self.requires_grad,\n    )\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/#liblaf.apple.warp.sim.energy.elastic.Phace.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/","title":"arap","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap","title":"liblaf.apple.warp.sim.energy.elastic.arap","text":"<p>Modules:</p> <ul> <li> <code>func</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Arap</code>           \u2013            <p>As-Rigid-As-Possible.</p> </li> <li> <code>Params</code>           \u2013            </li> <li> <code>ParamsElem</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>energy_density_hess_diag</code>             \u2013              </li> <li> <code>energy_density_hess_prod</code>             \u2013              </li> <li> <code>energy_density_hess_quad</code>             \u2013              </li> <li> <code>first_piola_kirchhoff_stress_tensor</code>             \u2013              </li> <li> <code>get_cell_params</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap","title":"Arap","text":"<p>               Bases: <code>Elastic</code></p> <p>As-Rigid-As-Possible.</p> \\[ \\Psi = \\frac{\\mu}{2} \\|F - R\\|_F^2 = \\frac{\\mu}{2} (I_2 - 2 I_1 + 3) \\] <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.arap.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params: Struct = func.Params()\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Arap.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Params","title":"Params","text":"<p>Attributes:</p> <ul> <li> <code>mu</code>               (<code>array(dtype=float_)</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.Params.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: array(dtype=float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.ParamsElem","title":"ParamsElem","text":"<p>Attributes:</p> <ul> <li> <code>mu</code>               (<code>float_</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.ParamsElem.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: float_\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.energy_density","title":"energy_density","text":"<pre><code>energy_density(F: mat33, params: ParamsElem)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density(F: mat33, params: ParamsElem):  # -&gt; float:\n    R, _ = math.polar_rv(F)  # mat33\n    Psi = type(F[0, 0])(0.5) * params.mu * math.frobenius_norm_square(F - R)  # float\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.energy_density_hess_diag","title":"energy_density_hess_diag","text":"<pre><code>energy_density_hess_diag(\n    F: mat33, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_diag(F: mat33, dhdX: mat43, params: ParamsElem):  # -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_diag = func.h4_diag(dhdX, lambdas, Q0, Q1, Q2)  # mat43\n    h5_diag = func.h5_diag(dhdX)  # mat43\n    h_diag = -type(F[0, 0])(2.0) * h4_diag + h5_diag  # mat43\n    return type(F[0, 0])(0.5) * params.mu * h_diag  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.energy_density_hess_prod","title":"energy_density_hess_prod","text":"<pre><code>energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_prod = func.h4_prod(p, dhdX, lambdas, Q0, Q1, Q2)  # mat43\n    h5_prod = func.h5_prod(p, dhdX)  # mat43\n    h_prod = -type(F[0, 0])(2.0) * h4_prod + h5_prod  # mat43\n    return type(F[0, 0])(0.5) * params.mu * h_prod  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.energy_density_hess_quad","title":"energy_density_hess_quad","text":"<pre><code>energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; float:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_quad = func.h4_quad(p, dhdX, lambdas, Q0, Q1, Q2)\n    h5_quad = func.h5_quad(p, dhdX)\n    h_quad = -type(F[0, 0])(2.0) * h4_quad + h5_quad\n    # if h_quad &lt; 0.0:\n    #     wp.printf(\"h4_quad = %f, h5_quad = %f, h_quad = %f\\n\", h4_quad, h5_quad, h_quad)\n    return type(F[0, 0])(0.5) * params.mu * h_quad\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.first_piola_kirchhoff_stress_tensor","title":"first_piola_kirchhoff_stress_tensor","text":"<pre><code>first_piola_kirchhoff_stress_tensor(\n    F: mat33, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef first_piola_kirchhoff_stress_tensor(F: mat33, params: ParamsElem):  # -&gt; mat33:\n    R, _ = math.polar_rv(F)  # mat33\n    PK1 = params.mu * (F - R)  # mat33\n    return PK1\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/#liblaf.apple.warp.sim.energy.elastic.arap.get_cell_params","title":"get_cell_params","text":"<pre><code>get_cell_params(params: Params, cid: int) -&gt; ParamsElem\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef get_cell_params(params: Params, cid: int) -&gt; ParamsElem:\n    p = ParamsElem(mu=params.mu[cid])\n    return p\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/","title":"func","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func","title":"liblaf.apple.warp.sim.energy.elastic.arap.func","text":"<p>Classes:</p> <ul> <li> <code>Params</code>           \u2013            </li> <li> <code>ParamsElem</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>energy_density_hess_diag</code>             \u2013              </li> <li> <code>energy_density_hess_prod</code>             \u2013              </li> <li> <code>energy_density_hess_quad</code>             \u2013              </li> <li> <code>first_piola_kirchhoff_stress_tensor</code>             \u2013              </li> <li> <code>get_cell_params</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.Params","title":"Params","text":"<p>Attributes:</p> <ul> <li> <code>mu</code>               (<code>array(dtype=float_)</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.Params.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: array(dtype=float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem","title":"ParamsElem","text":"<p>Attributes:</p> <ul> <li> <code>mu</code>               (<code>float_</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.ParamsElem.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: float_\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.energy_density","title":"energy_density","text":"<pre><code>energy_density(F: mat33, params: ParamsElem)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density(F: mat33, params: ParamsElem):  # -&gt; float:\n    R, _ = math.polar_rv(F)  # mat33\n    Psi = type(F[0, 0])(0.5) * params.mu * math.frobenius_norm_square(F - R)  # float\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.energy_density_hess_diag","title":"energy_density_hess_diag","text":"<pre><code>energy_density_hess_diag(\n    F: mat33, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_diag(F: mat33, dhdX: mat43, params: ParamsElem):  # -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_diag = func.h4_diag(dhdX, lambdas, Q0, Q1, Q2)  # mat43\n    h5_diag = func.h5_diag(dhdX)  # mat43\n    h_diag = -type(F[0, 0])(2.0) * h4_diag + h5_diag  # mat43\n    return type(F[0, 0])(0.5) * params.mu * h_diag  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.energy_density_hess_prod","title":"energy_density_hess_prod","text":"<pre><code>energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_prod = func.h4_prod(p, dhdX, lambdas, Q0, Q1, Q2)  # mat43\n    h5_prod = func.h5_prod(p, dhdX)  # mat43\n    h_prod = -type(F[0, 0])(2.0) * h4_prod + h5_prod  # mat43\n    return type(F[0, 0])(0.5) * params.mu * h_prod  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.energy_density_hess_quad","title":"energy_density_hess_quad","text":"<pre><code>energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; float:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_quad = func.h4_quad(p, dhdX, lambdas, Q0, Q1, Q2)\n    h5_quad = func.h5_quad(p, dhdX)\n    h_quad = -type(F[0, 0])(2.0) * h4_quad + h5_quad\n    # if h_quad &lt; 0.0:\n    #     wp.printf(\"h4_quad = %f, h5_quad = %f, h_quad = %f\\n\", h4_quad, h5_quad, h_quad)\n    return type(F[0, 0])(0.5) * params.mu * h_quad\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.first_piola_kirchhoff_stress_tensor","title":"first_piola_kirchhoff_stress_tensor","text":"<pre><code>first_piola_kirchhoff_stress_tensor(\n    F: mat33, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef first_piola_kirchhoff_stress_tensor(F: mat33, params: ParamsElem):  # -&gt; mat33:\n    R, _ = math.polar_rv(F)  # mat33\n    PK1 = params.mu * (F - R)  # mat33\n    return PK1\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap/func/#liblaf.apple.warp.sim.energy.elastic.arap.func.get_cell_params","title":"get_cell_params","text":"<pre><code>get_cell_params(params: Params, cid: int) -&gt; ParamsElem\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef get_cell_params(params: Params, cid: int) -&gt; ParamsElem:\n    p = ParamsElem(mu=params.mu[cid])\n    return p\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/","title":"arap_active","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active","title":"liblaf.apple.warp.sim.energy.elastic.arap_active","text":"<p>Modules:</p> <ul> <li> <code>func</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>ArapActive</code>           \u2013            </li> <li> <code>Params</code>           \u2013            </li> <li> <code>ParamsElem</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>energy_density_hess_diag</code>             \u2013              </li> <li> <code>energy_density_hess_prod</code>             \u2013              </li> <li> <code>energy_density_hess_quad</code>             \u2013              </li> <li> <code>first_piola_kirchhoff_stress_tensor</code>             \u2013              </li> <li> <code>get_cell_params</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive","title":"ArapActive","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.arap_active.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params = func.Params()\n    params.activation = wp_utils.to_warp(\n        region.cell_data[\"activation\"],\n        dtype=vec6,\n        requires_grad=\"activation\" in self.requires_grad,\n    )\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ArapActive.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.Params","title":"Params","text":"<p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>array(dtype=vec6)</code>)           \u2013            </li> <li> <code>mu</code>               (<code>array(dtype=float_)</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.Params.activation","title":"activation  <code>instance-attribute</code>","text":"<pre><code>activation: array(dtype=vec6)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.Params.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: array(dtype=float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ParamsElem","title":"ParamsElem","text":"<p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>vec6</code>)           \u2013            </li> <li> <code>mu</code>               (<code>float_</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ParamsElem.activation","title":"activation  <code>instance-attribute</code>","text":"<pre><code>activation: vec6\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.ParamsElem.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: float_\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.energy_density","title":"energy_density","text":"<pre><code>energy_density(F: mat33, params: ParamsElem)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density(F: mat33, params: ParamsElem):  # -&gt; float:\n    A = _func.make_activation_mat33(params.activation)  # mat33\n    R, _ = math.polar_rv(F)  # mat33\n    Psi = (\n        type(F[0, 0])(0.5) * params.mu * math.frobenius_norm_square(F - R @ A)\n    )  # float\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.energy_density_hess_diag","title":"energy_density_hess_diag","text":"<pre><code>energy_density_hess_diag(\n    F: mat33, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_diag(F: mat33, dhdX: mat43, params: ParamsElem):  # -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = _func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = _func.Qs(U, V)  # mat33, mat33, mat33\n    h4_diag = _func.h4_diag(dhdX, lambdas, Q0, Q1, Q2)  # mat43\n    h5_diag = _func.h5_diag(dhdX)  # mat43\n    h_diag = -type(F[0, 0])(2.0) * h4_diag + h5_diag  # mat43\n    return type(F[0, 0])(0.5) * params.mu * h_diag  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.energy_density_hess_prod","title":"energy_density_hess_prod","text":"<pre><code>energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = _func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = _func.Qs(U, V)  # mat33, mat33, mat33\n    h4_prod = _func.h4_prod(p, dhdX, lambdas, Q0, Q1, Q2)  # mat43\n    h5_prod = _func.h5_prod(p, dhdX)  # mat43\n    h_prod = -type(F[0, 0])(2.0) * h4_prod + h5_prod  # mat43\n    return type(F[0, 0])(0.5) * params.mu * h_prod  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.energy_density_hess_quad","title":"energy_density_hess_quad","text":"<pre><code>energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; float:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = _func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = _func.Qs(U, V)  # mat33, mat33, mat33\n    h4_quad = _func.h4_quad(p, dhdX, lambdas, Q0, Q1, Q2)\n    h5_quad = _func.h5_quad(p, dhdX)\n    h_quad = -type(F[0, 0])(2.0) * h4_quad + h5_quad\n    return type(F[0, 0])(0.5) * params.mu * h_quad\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.first_piola_kirchhoff_stress_tensor","title":"first_piola_kirchhoff_stress_tensor","text":"<pre><code>first_piola_kirchhoff_stress_tensor(\n    F: mat33, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef first_piola_kirchhoff_stress_tensor(F: mat33, params: ParamsElem):  # -&gt; mat33:\n    A = _func.make_activation_mat33(params.activation)  # mat33\n    R, _ = math.polar_rv(F)  # mat33\n    PK1 = params.mu * (F - R @ A)  # mat33\n    return PK1\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/#liblaf.apple.warp.sim.energy.elastic.arap_active.get_cell_params","title":"get_cell_params","text":"<pre><code>get_cell_params(params: Params, cid: int) -&gt; ParamsElem\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef get_cell_params(params: Params, cid: int) -&gt; ParamsElem:\n    cell_params = ParamsElem(activation=params.activation[cid], mu=params.mu[cid])\n    return cell_params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/","title":"func","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func","title":"liblaf.apple.warp.sim.energy.elastic.arap_active.func","text":"<p>Classes:</p> <ul> <li> <code>Params</code>           \u2013            </li> <li> <code>ParamsElem</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>energy_density_hess_diag</code>             \u2013              </li> <li> <code>energy_density_hess_prod</code>             \u2013              </li> <li> <code>energy_density_hess_quad</code>             \u2013              </li> <li> <code>first_piola_kirchhoff_stress_tensor</code>             \u2013              </li> <li> <code>get_cell_params</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.Params","title":"Params","text":"<p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>array(dtype=vec6)</code>)           \u2013            </li> <li> <code>mu</code>               (<code>array(dtype=float_)</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.Params.activation","title":"activation  <code>instance-attribute</code>","text":"<pre><code>activation: array(dtype=vec6)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.Params.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: array(dtype=float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem","title":"ParamsElem","text":"<p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>vec6</code>)           \u2013            </li> <li> <code>mu</code>               (<code>float_</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem.activation","title":"activation  <code>instance-attribute</code>","text":"<pre><code>activation: vec6\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.ParamsElem.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: float_\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.energy_density","title":"energy_density","text":"<pre><code>energy_density(F: mat33, params: ParamsElem)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density(F: mat33, params: ParamsElem):  # -&gt; float:\n    A = _func.make_activation_mat33(params.activation)  # mat33\n    R, _ = math.polar_rv(F)  # mat33\n    Psi = (\n        type(F[0, 0])(0.5) * params.mu * math.frobenius_norm_square(F - R @ A)\n    )  # float\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.energy_density_hess_diag","title":"energy_density_hess_diag","text":"<pre><code>energy_density_hess_diag(\n    F: mat33, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_diag(F: mat33, dhdX: mat43, params: ParamsElem):  # -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = _func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = _func.Qs(U, V)  # mat33, mat33, mat33\n    h4_diag = _func.h4_diag(dhdX, lambdas, Q0, Q1, Q2)  # mat43\n    h5_diag = _func.h5_diag(dhdX)  # mat43\n    h_diag = -type(F[0, 0])(2.0) * h4_diag + h5_diag  # mat43\n    return type(F[0, 0])(0.5) * params.mu * h_diag  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.energy_density_hess_prod","title":"energy_density_hess_prod","text":"<pre><code>energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = _func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = _func.Qs(U, V)  # mat33, mat33, mat33\n    h4_prod = _func.h4_prod(p, dhdX, lambdas, Q0, Q1, Q2)  # mat43\n    h5_prod = _func.h5_prod(p, dhdX)  # mat43\n    h_prod = -type(F[0, 0])(2.0) * h4_prod + h5_prod  # mat43\n    return type(F[0, 0])(0.5) * params.mu * h_prod  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.energy_density_hess_quad","title":"energy_density_hess_quad","text":"<pre><code>energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; float:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = _func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = _func.Qs(U, V)  # mat33, mat33, mat33\n    h4_quad = _func.h4_quad(p, dhdX, lambdas, Q0, Q1, Q2)\n    h5_quad = _func.h5_quad(p, dhdX)\n    h_quad = -type(F[0, 0])(2.0) * h4_quad + h5_quad\n    return type(F[0, 0])(0.5) * params.mu * h_quad\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.first_piola_kirchhoff_stress_tensor","title":"first_piola_kirchhoff_stress_tensor","text":"<pre><code>first_piola_kirchhoff_stress_tensor(\n    F: mat33, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef first_piola_kirchhoff_stress_tensor(F: mat33, params: ParamsElem):  # -&gt; mat33:\n    A = _func.make_activation_mat33(params.activation)  # mat33\n    R, _ = math.polar_rv(F)  # mat33\n    PK1 = params.mu * (F - R @ A)  # mat33\n    return PK1\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/arap_active/func/#liblaf.apple.warp.sim.energy.elastic.arap_active.func.get_cell_params","title":"get_cell_params","text":"<pre><code>get_cell_params(params: Params, cid: int) -&gt; ParamsElem\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/arap_active/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef get_cell_params(params: Params, cid: int) -&gt; ParamsElem:\n    cell_params = ParamsElem(activation=params.activation[cid], mu=params.mu[cid])\n    return cell_params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/","title":"func","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func","title":"liblaf.apple.warp.sim.energy.elastic.func","text":"<p>Functions:</p> <ul> <li> <code>I1</code>             \u2013              <p>\\(I_1\\).</p> </li> <li> <code>I2</code>             \u2013              <p>\\(I_2\\).</p> </li> <li> <code>I3</code>             \u2013              <p>\\(I_3\\).</p> </li> <li> <code>Qs</code>             \u2013              <p>\u2026</p> </li> <li> <code>deformation_gradient</code>             \u2013              <p>\\(F = \\frac{\\partial u}{\\partial x} + I\\).</p> </li> <li> <code>deformation_gradient_jvp</code>             \u2013              <p>\\(\\frac{\\partial F}{\\partial x} p\\).</p> </li> <li> <code>deformation_gradient_vjp</code>             \u2013              <p>\\(\\frac{\\partial F}{\\partial x}^T p\\).</p> </li> <li> <code>g1</code>             \u2013              <p>Gradient of \\(I_1\\) w.r.t. \\(F\\).</p> </li> <li> <code>g2</code>             \u2013              <p>Gradient of \\(I_2\\) w.r.t. \\(F\\).</p> </li> <li> <code>g3</code>             \u2013              <p>Gradient of \\(I_3\\) w.r.t. \\(F\\).</p> </li> <li> <code>gradient</code>             \u2013              <p>\\(\\frac{\\partial u}{\\partial x}\\).</p> </li> <li> <code>h1_diag</code>             \u2013              <p>\\(diag(h_1)\\).</p> </li> <li> <code>h1_prod</code>             \u2013              <p>\\(h_1 p\\).</p> </li> <li> <code>h1_quad</code>             \u2013              <p>\\(p^T h_1 p\\).</p> </li> <li> <code>h2_diag</code>             \u2013              <p>\\(diag(h_2)\\).</p> </li> <li> <code>h2_prod</code>             \u2013              <p>\\(h_2 p\\).</p> </li> <li> <code>h2_quad</code>             \u2013              <p>\\(p^T h_2 p\\).</p> </li> <li> <code>h3_diag</code>             \u2013              <p>\\(diag(h_3)\\).</p> </li> <li> <code>h3_prod</code>             \u2013              <p>\\(h_3 p\\).</p> </li> <li> <code>h3_quad</code>             \u2013              <p>\\(p^T h_3 p\\).</p> </li> <li> <code>h4_diag</code>             \u2013              <p>\\(diag(h_4)\\).</p> </li> <li> <code>h4_prod</code>             \u2013              <p>\\(h_4 p\\).</p> </li> <li> <code>h4_quad</code>             \u2013              <p>\\(p^T h_4 p\\).</p> </li> <li> <code>h5_diag</code>             \u2013              <p>\\(diag(h_5)\\).</p> </li> <li> <code>h5_prod</code>             \u2013              <p>\\(h_5 p\\).</p> </li> <li> <code>h5_quad</code>             \u2013              <p>\\(p^T h_5 p\\).</p> </li> <li> <code>h6_diag</code>             \u2013              <p>\\(diag(h_6)\\).</p> </li> <li> <code>h6_prod</code>             \u2013              <p>\\(h_6 p\\).</p> </li> <li> <code>h6_quad</code>             \u2013              <p>\\(p^T h_6 p\\).</p> </li> <li> <code>lambdas</code>             \u2013              <p>\u2026</p> </li> <li> <code>make_activation_mat33</code>             \u2013              <p>\u2026</p> </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.I1","title":"I1","text":"<pre><code>I1(S: mat33)\n</code></pre> <p>\\(I_1\\).</p> \\[ I_1 = \\operatorname{tr}(R^T F) = \\operatorname{tr}(S) \\] <p>Parameters:</p> <ul> <li> <code>S</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>I1</code> (              <code>float</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_identities.py</code> <pre><code>@wp.func\ndef I1(S: mat33):\n    r\"\"\"$I_1$.\n\n    $$\n    I_1 = \\operatorname{tr}(R^T F) = \\operatorname{tr}(S)\n    $$\n\n    Args:\n        S (mat33): ...\n\n    Returns:\n        I1 (float): ...\n    \"\"\"\n    return wp.trace(S)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.I2","title":"I2","text":"<pre><code>I2(F: mat33)\n</code></pre> <p>\\(I_2\\).</p> \\[ I_2 = I_C = \\|F\\|_F^2 \\] <p>Parameters:</p> <ul> <li> <code>F</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>I2</code> (              <code>float</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_identities.py</code> <pre><code>@wp.func\ndef I2(F: mat33):\n    r\"\"\"$I_2$.\n\n    $$\n    I_2 = I_C = \\|F\\|_F^2\n    $$\n\n    Args:\n        F (mat33): ...\n\n    Returns:\n        I2 (float): ...\n    \"\"\"\n    return wp.ddot(F, F)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.I3","title":"I3","text":"<pre><code>I3(F: mat33)\n</code></pre> <p>\\(I_3\\).</p> \\[ I_3 = J = \\det(F) \\] <p>Parameters:</p> <ul> <li> <code>F</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>I3</code> (              <code>float</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_identities.py</code> <pre><code>@wp.func\ndef I3(F: mat33):\n    r\"\"\"$I_3$.\n\n    $$\n    I_3 = J = \\det(F)\n    $$\n\n    Args:\n        F (mat33): ...\n\n    Returns:\n        I3 (float): ...\n    \"\"\"\n    return wp.determinant(F)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.Qs","title":"Qs","text":"<pre><code>Qs(U: Any, V: Any)\n</code></pre> <p>\u2026</p> <p>Parameters:</p> <ul> <li> <code>U</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> <li> <code>V</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Q0</code> (              <code>mat33</code> )          \u2013            <p>\u2026</p> </li> <li> <code>Q1</code> (              <code>mat33</code> )          \u2013            <p>\u2026</p> </li> <li> <code>Q2</code> (              <code>mat33</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_misc.py</code> <pre><code>@wp.func\n@no_type_check\ndef Qs(U: Any, V: Any):\n    \"\"\"...\n\n    Args:\n        U (mat33): ...\n        V (mat33): ...\n\n    Returns:\n        Q0 (mat33): ...\n        Q1 (mat33): ...\n        Q2 (mat33): ...\n    \"\"\"\n    _2 = type(U[0, 0])(2.0)\n    _sqrt2 = wp.sqrt(_2)\n    U0 = U[:, 0]\n    U1 = U[:, 1]\n    U2 = U[:, 2]\n    V0 = V[:, 0]\n    V1 = V[:, 1]\n    V2 = V[:, 2]\n    Q0 = (wp.outer(U1, V0) - wp.outer(U0, V1)) / _sqrt2\n    Q1 = (wp.outer(U1, V2) - wp.outer(U2, V1)) / _sqrt2\n    Q2 = (wp.outer(U0, V2) - wp.outer(U2, V0)) / _sqrt2\n    return Q0, Q1, Q2\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.deformation_gradient","title":"deformation_gradient","text":"<pre><code>deformation_gradient(u: Any, dhdX: Any)\n</code></pre> <p>\\(F = \\frac{\\partial u}{\\partial x} + I\\).</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>F</code> (              <code>mat33</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_deformation_gradient.py</code> <pre><code>@wp.func\n@no_type_check\ndef deformation_gradient(u: Any, dhdX: Any):\n    r\"\"\"$F = \\frac{\\partial u}{\\partial x} + I$.\n\n    Args:\n        u (mat43): ...\n        dhdX (mat43): ...\n\n    Returns:\n        F (mat33): ...\n    \"\"\"\n    return gradient(u, dhdX) + wp.identity(3, dtype=type(u[0, 0]))\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.deformation_gradient_jvp","title":"deformation_gradient_jvp","text":"<pre><code>deformation_gradient_jvp(dhdX: Any, p: Any)\n</code></pre> <p>\\(\\frac{\\partial F}{\\partial x} p\\).</p> <p>Parameters:</p> <ul> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat33</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_deformation_gradient.py</code> <pre><code>@wp.func\n@no_type_check\ndef deformation_gradient_jvp(dhdX: Any, p: Any):\n    r\"\"\"$\\frac{\\partial F}{\\partial x} p$.\n\n    Args:\n        dhdX (mat43): ...\n        p (mat43): ...\n\n    Returns:\n        (mat33): ...\n    \"\"\"\n    return wp.transpose(p) @ dhdX\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.deformation_gradient_vjp","title":"deformation_gradient_vjp","text":"<pre><code>deformation_gradient_vjp(dhdX: Any, p: Any)\n</code></pre> <p>\\(\\frac{\\partial F}{\\partial x}^T p\\).</p> <p>Parameters:</p> <ul> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>p</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_deformation_gradient.py</code> <pre><code>@wp.func\n@no_type_check\ndef deformation_gradient_vjp(dhdX: Any, p: Any):\n    r\"\"\"$\\frac{\\partial F}{\\partial x}^T p$.\n\n    Args:\n        dhdX (mat43): ...\n        p (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    return dhdX @ wp.transpose(p)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.g1","title":"g1","text":"<pre><code>g1(R: Any)\n</code></pre> <p>Gradient of \\(I_1\\) w.r.t. \\(F\\).</p> \\[ g_1 = vec(R) \\] <p>Parameters:</p> <ul> <li> <code>R</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>g1</code> (              <code>mat33</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_gradients.py</code> <pre><code>@wp.func\n@no_type_check\ndef g1(R: Any):\n    r\"\"\"Gradient of $I_1$ w.r.t. $F$.\n\n    $$\n    g_1 = vec(R)\n    $$\n\n    Args:\n        R (mat33): ...\n\n    Returns:\n        g1 (mat33): ...\n    \"\"\"\n    return R\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.g2","title":"g2","text":"<pre><code>g2(F: Any)\n</code></pre> <p>Gradient of \\(I_2\\) w.r.t. \\(F\\).</p> \\[ g_2 = 2 vec(F) \\] <p>Parameters:</p> <ul> <li> <code>F</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>g2</code> (              <code>mat33</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_gradients.py</code> <pre><code>@wp.func\n@no_type_check\ndef g2(F: Any):\n    \"\"\"Gradient of $I_2$ w.r.t. $F$.\n\n    $$\n    g_2 = 2 vec(F)\n    $$\n\n    Args:\n        F (mat33): ...\n\n    Returns:\n        g2 (mat33): ...\n    \"\"\"\n    return type(F[0, 0])(2.0) * F\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.g3","title":"g3","text":"<pre><code>g3(F: Any)\n</code></pre> <p>Gradient of \\(I_3\\) w.r.t. \\(F\\).</p> \\[ g_3 = vec([f_1 \\cp f_2, f_2 \\cp f_0, f_0 \\cp f_1]) \\] <p>Parameters:</p> <ul> <li> <code>F</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>g3</code> (              <code>mat33</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_gradients.py</code> <pre><code>@wp.func\n@no_type_check\ndef g3(F: Any):\n    r\"\"\"Gradient of $I_3$ w.r.t. $F$.\n\n    $$\n    g_3 = vec([f_1 \\cp f_2, f_2 \\cp f_0, f_0 \\cp f_1])\n    $$\n\n    Args:\n        F (mat33): ...\n\n    Returns:\n        g3 (mat33): ...\n    \"\"\"\n    f0, f1, f2 = F[:, 0], F[:, 1], F[:, 2]\n    return wp.matrix_from_cols(wp.cross(f1, f2), wp.cross(f2, f0), wp.cross(f0, f1))\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.gradient","title":"gradient","text":"<pre><code>gradient(u: Any, dhdX: Any)\n</code></pre> <p>\\(\\frac{\\partial u}{\\partial x}\\).</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat33</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_deformation_gradient.py</code> <pre><code>@wp.func\n@no_type_check\ndef gradient(u: Any, dhdX: Any):\n    r\"\"\"$\\frac{\\partial u}{\\partial x}$.\n\n    Args:\n        u (mat43): ...\n        dhdX (mat43): ...\n\n    Returns:\n        (mat33): ...\n    \"\"\"\n    return wp.transpose(u) @ dhdX\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h1_diag","title":"h1_diag","text":"<pre><code>h1_diag(dhdX: mat43, g1: mat33)\n</code></pre> <p>\\(diag(h_1)\\).</p> <p>Parameters:</p> <ul> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g1</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_diag.py</code> <pre><code>@wp.func\n@no_type_check\ndef h1_diag(dhdX: mat43, g1: mat33):\n    \"\"\"$diag(h_1)$.\n\n    Args:\n        dhdX (mat43): ...\n        g1 (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    return math.cw_square(deformation_gradient_vjp(dhdX, g1))\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h1_prod","title":"h1_prod","text":"<pre><code>h1_prod(p: mat43, dhdX: mat43, g1: mat33)\n</code></pre> <p>\\(h_1 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g1</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_prod.py</code> <pre><code>@wp.func\n@no_type_check\ndef h1_prod(p: mat43, dhdX: mat43, g1: mat33):\n    \"\"\"$h_1 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        g1 (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    dFdxT_g = deformation_gradient_vjp(dhdX, g1)  # mat33\n    return wp.ddot(dFdxT_g, p) * dFdxT_g\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h1_quad","title":"h1_quad","text":"<pre><code>h1_quad(p: mat43, dhdX: mat43, g1: mat33)\n</code></pre> <p>\\(p^T h_1 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g1</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_quad.py</code> <pre><code>@wp.func\n@no_type_check\ndef h1_quad(p: mat43, dhdX: mat43, g1: mat33):\n    \"\"\"$p^T h_1 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        g1 (mat33): ...\n\n    Returns:\n        (float): ...\n    \"\"\"\n    return math.square(wp.ddot(deformation_gradient_jvp(dhdX, p), g1))\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h2_diag","title":"h2_diag","text":"<pre><code>h2_diag(dhdX: mat43, g2: mat33)\n</code></pre> <p>\\(diag(h_2)\\).</p> <p>Parameters:</p> <ul> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g2</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_diag.py</code> <pre><code>@wp.func\n@no_type_check\ndef h2_diag(dhdX: mat43, g2: mat33):\n    \"\"\"$diag(h_2)$.\n\n    Args:\n        dhdX (mat43): ...\n        g2 (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    return math.cw_square(deformation_gradient_vjp(dhdX, g2))\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h2_prod","title":"h2_prod","text":"<pre><code>h2_prod(p: mat43, dhdX: mat43, g2: mat33)\n</code></pre> <p>\\(h_2 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g2</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_prod.py</code> <pre><code>@wp.func\n@no_type_check\ndef h2_prod(p: mat43, dhdX: mat43, g2: mat33):\n    \"\"\"$h_2 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        g2 (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    dFdxT_g = deformation_gradient_vjp(dhdX, g2)  # mat33\n    return wp.ddot(dFdxT_g, p) * dFdxT_g\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h2_quad","title":"h2_quad","text":"<pre><code>h2_quad(p: mat43, dhdX: mat43, g2: mat33)\n</code></pre> <p>\\(p^T h_2 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g2</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_quad.py</code> <pre><code>@wp.func\n@no_type_check\ndef h2_quad(p: mat43, dhdX: mat43, g2: mat33):\n    \"\"\"$p^T h_2 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        g2 (mat33): ...\n\n    Returns:\n        (float): ...\n    \"\"\"\n    return math.square(wp.ddot(deformation_gradient_jvp(dhdX, p), g2))\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h3_diag","title":"h3_diag","text":"<pre><code>h3_diag(dhdX: mat43, g3: mat33)\n</code></pre> <p>\\(diag(h_3)\\).</p> <p>Parameters:</p> <ul> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g3</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_diag.py</code> <pre><code>@wp.func\n@no_type_check\ndef h3_diag(dhdX: mat43, g3: mat33):\n    \"\"\"$diag(h_3)$.\n\n    Args:\n        dhdX (mat43): ...\n        g3 (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    return math.cw_square(deformation_gradient_vjp(dhdX, g3))\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h3_prod","title":"h3_prod","text":"<pre><code>h3_prod(p: mat43, dhdX: mat43, g3: mat33)\n</code></pre> <p>\\(h_3 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g3</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_prod.py</code> <pre><code>@wp.func\n@no_type_check\ndef h3_prod(p: mat43, dhdX: mat43, g3: mat33):\n    \"\"\"$h_3 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        g3 (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    dFdxT_g = deformation_gradient_vjp(dhdX, g3)  # mat33\n    return wp.ddot(dFdxT_g, p) * dFdxT_g\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h3_quad","title":"h3_quad","text":"<pre><code>h3_quad(p: mat43, dhdX: mat43, g3: mat33)\n</code></pre> <p>\\(p^T h_3 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>g3</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_quad.py</code> <pre><code>@wp.func\n@no_type_check\ndef h3_quad(p: mat43, dhdX: mat43, g3: mat33):\n    \"\"\"$p^T h_3 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        g3 (mat33): ...\n\n    Returns:\n        (float): ...\n    \"\"\"\n    return math.square(wp.ddot(deformation_gradient_jvp(dhdX, p), g3))\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h4_diag","title":"h4_diag","text":"<pre><code>h4_diag(\n    dhdX: mat43,\n    lambdas: vec3,\n    Q0: mat33,\n    Q1: mat33,\n    Q2: mat33,\n)\n</code></pre> <p>\\(diag(h_4)\\).</p> <p>Parameters:</p> <ul> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>lambdas</code>               (<code>vec3</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q0</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q1</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q2</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_diag.py</code> <pre><code>@wp.func\n@no_type_check\ndef h4_diag(dhdX: mat43, lambdas: vec3, Q0: mat33, Q1: mat33, Q2: mat33):\n    \"\"\"$diag(h_4)$.\n\n    Args:\n        dhdX (mat43): ...\n        lambdas (vec3): ...\n        Q0 (mat33): ...\n        Q1 (mat33): ...\n        Q2 (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    W0 = deformation_gradient_vjp(dhdX, Q0)  # mat43\n    W1 = deformation_gradient_vjp(dhdX, Q1)  # mat43\n    W2 = deformation_gradient_vjp(dhdX, Q2)  # mat43\n    return (\n        lambdas[0] * math.cw_square(W0)\n        + lambdas[1] * math.cw_square(W1)\n        + lambdas[2] * math.cw_square(W2)\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h4_prod","title":"h4_prod","text":"<pre><code>h4_prod(\n    p: mat43,\n    dhdX: mat43,\n    lambdas: vec3,\n    Q0: mat33,\n    Q1: mat33,\n    Q2: mat33,\n)\n</code></pre> <p>\\(h_4 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>lambdas</code>               (<code>vec3</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q0</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q1</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q2</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_prod.py</code> <pre><code>@wp.func\n@no_type_check\ndef h4_prod(p: mat43, dhdX: mat43, lambdas: vec3, Q0: mat33, Q1: mat33, Q2: mat33):\n    \"\"\"$h_4 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        lambdas (vec3): ...\n        Q0 (mat33): ...\n        Q1 (mat33): ...\n        Q2 (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    dFdxT_q0 = deformation_gradient_vjp(dhdX, Q0)  # mat33\n    dFdxT_q1 = deformation_gradient_vjp(dhdX, Q1)  # mat33\n    dFdxT_q2 = deformation_gradient_vjp(dhdX, Q2)  # mat33\n    return (\n        lambdas[0] * wp.ddot(dFdxT_q0, p) * dFdxT_q0\n        + lambdas[1] * wp.ddot(dFdxT_q1, p) * dFdxT_q1\n        + lambdas[2] * wp.ddot(dFdxT_q2, p) * dFdxT_q2\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h4_quad","title":"h4_quad","text":"<pre><code>h4_quad(\n    p: mat43,\n    dhdX: mat43,\n    lambdas: vec3,\n    Q0: mat33,\n    Q1: mat33,\n    Q2: mat33,\n)\n</code></pre> <p>\\(p^T h_4 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>lambdas</code>               (<code>vec3</code>)           \u2013            <p>\u2026</p> </li> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q0</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q1</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> <li> <code>Q2</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_quad.py</code> <pre><code>@wp.func\n@no_type_check\ndef h4_quad(p: mat43, dhdX: mat43, lambdas: vec3, Q0: mat33, Q1: mat33, Q2: mat33):\n    \"\"\"$p^T h_4 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        lambdas (vec3): ...\n        p (mat43): ...\n        Q0 (mat33): ...\n        Q1 (mat33): ...\n        Q2 (mat33): ...\n\n    Returns:\n        (float): ...\n    \"\"\"\n    dFdx_p = deformation_gradient_jvp(dhdX, p)  # mat33\n    return (\n        lambdas[0] * math.square(wp.ddot(Q0, dFdx_p))\n        + lambdas[1] * math.square(wp.ddot(Q1, dFdx_p))\n        + lambdas[2] * math.square(wp.ddot(Q2, dFdx_p))\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h5_diag","title":"h5_diag","text":"<pre><code>h5_diag(dhdX: mat43)\n</code></pre> <p>\\(diag(h_5)\\).</p> <p>Parameters:</p> <ul> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_diag.py</code> <pre><code>@wp.func\n@no_type_check\ndef h5_diag(dhdX: mat43):\n    \"\"\"$diag(h_5)$.\n\n    Args:\n        dhdX (mat43): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    t0 = wp.length_sq(dhdX[0])\n    t1 = wp.length_sq(dhdX[1])\n    t2 = wp.length_sq(dhdX[2])\n    t3 = wp.length_sq(dhdX[3])\n    return type(dhdX[0, 0])(2.0) * wp.matrix_from_rows(\n        wp.vector(t0, t0, t0),\n        wp.vector(t1, t1, t1),\n        wp.vector(t2, t2, t2),\n        wp.vector(t3, t3, t3),\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h5_prod","title":"h5_prod","text":"<pre><code>h5_prod(p: mat43, dhdX: mat43)\n</code></pre> <p>\\(h_5 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_prod.py</code> <pre><code>@wp.func\n@no_type_check\ndef h5_prod(p: mat43, dhdX: mat43):\n    \"\"\"$h_5 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    dFdx_p = deformation_gradient_jvp(dhdX, p)  # mat33\n    return type(dhdX[0, 0])(2.0) * deformation_gradient_vjp(dhdX, dFdx_p)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h5_quad","title":"h5_quad","text":"<pre><code>h5_quad(p: mat43, dhdX: mat43)\n</code></pre> <p>\\(p^T h_5 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_quad.py</code> <pre><code>@wp.func\n@no_type_check\ndef h5_quad(p: mat43, dhdX: mat43):\n    \"\"\"$p^T h_5 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n\n    Returns:\n        (float): ...\n    \"\"\"\n    dFdx_p = deformation_gradient_jvp(dhdX, p)  # mat33\n    return type(dhdX[0, 0])(2.0) * math.frobenius_norm_square(dFdx_p)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h6_diag","title":"h6_diag","text":"<pre><code>h6_diag(dhdX: mat43, F: mat33)\n</code></pre> <p>\\(diag(h_6)\\).</p> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_diag.py</code> <pre><code>@wp.func\n@no_type_check\ndef h6_diag(dhdX: mat43, F: mat33):  # noqa: ARG001\n    \"\"\"$diag(h_6)$.\"\"\"\n    return type(dhdX)()\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h6_prod","title":"h6_prod","text":"<pre><code>h6_prod(p: mat43, dhdX: mat43, F: mat33)\n</code></pre> <p>\\(h_6 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>F</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat43</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_prod.py</code> <pre><code>@wp.func\n@no_type_check\ndef h6_prod(p: mat43, dhdX: mat43, F: mat33):\n    \"\"\"$h_6 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        F (mat33): ...\n\n    Returns:\n        (mat43): ...\n    \"\"\"\n    dFdx_p = deformation_gradient_jvp(dhdX, p)  # mat33\n    f0 = F[:, 0]  # vec3\n    f1 = F[:, 1]  # vec3\n    f2 = F[:, 2]  # vec3\n    p0 = dFdx_p[:, 0]  # vec3\n    p1 = dFdx_p[:, 1]  # vec3\n    p2 = dFdx_p[:, 2]  # vec3\n    Hp = wp.matrix_from_cols(\n        wp.cross(f1, p2) - wp.cross(f2, p1),\n        wp.cross(f2, p0) - wp.cross(f0, p2),\n        wp.cross(f0, p1) - wp.cross(f1, p0),\n    )  # mat33\n    return deformation_gradient_vjp(dhdX, Hp)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.h6_quad","title":"h6_quad","text":"<pre><code>h6_quad(p: mat43, dhdX: mat43, F: mat33)\n</code></pre> <p>\\(p^T h_6 p\\).</p> <p>Parameters:</p> <ul> <li> <code>p</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>dhdX</code>               (<code>mat43</code>)           \u2013            <p>\u2026</p> </li> <li> <code>F</code>               (<code>mat33</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_hess_quad.py</code> <pre><code>@wp.func\n@no_type_check\ndef h6_quad(p: mat43, dhdX: mat43, F: mat33):\n    \"\"\"$p^T h_6 p$.\n\n    Args:\n        p (mat43): ...\n        dhdX (mat43): ...\n        F (mat33): ...\n\n    Returns:\n        (float): ...\n    \"\"\"\n    dFdx_p = deformation_gradient_jvp(dhdX, p)  # mat33\n    f0 = F[:, 0]\n    f1 = F[:, 1]\n    f2 = F[:, 2]\n    p0 = dFdx_p[:, 0]\n    p1 = dFdx_p[:, 1]\n    p2 = dFdx_p[:, 2]\n    return (\n        wp.dot(p0, wp.cross(f1, p2) - wp.cross(f2, p1))\n        + wp.dot(p1, wp.cross(f2, p0) - wp.cross(f0, p2))\n        + wp.dot(p2, wp.cross(f0, p1) - wp.cross(f1, p0))\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.lambdas","title":"lambdas","text":"<pre><code>lambdas(sigma: Any, *, clamp: bool = True)\n</code></pre> <p>\u2026</p> <p>Parameters:</p> <ul> <li> <code>sigma</code>               (<code>vec3</code>)           \u2013            <p>\u2026</p> </li> <li> <code>clamp</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lambdas</code> (              <code>vec3</code> )          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_misc.py</code> <pre><code>@wp.func\n@no_type_check\ndef lambdas(sigma: Any, *, clamp: bool = True):\n    \"\"\"...\n\n    Args:\n        sigma (vec3): ...\n        clamp: ...\n\n    Returns:\n        lambdas (vec3): ...\n    \"\"\"\n    _2 = type(sigma[0])(2.0)\n    lambda0 = _2 / (sigma[0] + sigma[1])\n    lambda1 = _2 / (sigma[1] + sigma[2])\n    lambda2 = _2 / (sigma[2] + sigma[0])\n    if clamp:\n        _0 = type(sigma[0])(0.0)\n        _1 = type(sigma[0])(1.0)\n        lambda0 = wp.clamp(lambda0, _0, _1)\n        lambda1 = wp.clamp(lambda1, _0, _1)\n        lambda2 = wp.clamp(lambda2, _0, _1)\n    return wp.vector(lambda0, lambda1, lambda2)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/func/#liblaf.apple.warp.sim.energy.elastic.func.make_activation_mat33","title":"make_activation_mat33","text":"<pre><code>make_activation_mat33(activation: Any)\n</code></pre> <p>\u2026</p> <p>Parameters:</p> <ul> <li> <code>activation</code>               (<code>vec6</code>)           \u2013            <p>\u2026</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mat33</code>          \u2013            <p>\u2026</p> </li> </ul> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/func/_misc.py</code> <pre><code>@wp.func\n@no_type_check\ndef make_activation_mat33(activation: Any):\n    \"\"\"...\n\n    Args:\n        activation (vec6): ...\n\n    Returns:\n        mat33: ...\n    \"\"\"\n    return wp.matrix_from_rows(\n        wp.vector(activation[0], activation[3], activation[4]),\n        wp.vector(activation[3], activation[1], activation[5]),\n        wp.vector(activation[4], activation[5], activation[2]),\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/","title":"phace","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace","title":"liblaf.apple.warp.sim.energy.elastic.phace","text":"<p>Modules:</p> <ul> <li> <code>func</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>Phace</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace","title":"Phace","text":"<p>               Bases: <code>Elastic</code></p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>cells</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>dV</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>, default:                   <code>&lt;Function first_piola_kirchhoff_stress_tensor(F: mat33(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_diag(F: mat33(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_prod(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>, default:                   <code>&lt;Function energy_density_hess_quad(F: mat33(d), p: mat43(d), dhdX: mat43(d), params: liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem)&gt;</code> )           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>, default:                   <code>&lt;Function get_cell_params(params: liblaf.apple.warp.sim.energy.elastic.phace.func.Params, cid: int)&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>from_pyvista</code>             \u2013              </li> <li> <code>from_region</code>             \u2013              </li> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>make_params</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>cells</code>               (<code>array</code>)           \u2013            </li> <li> <code>clamp_hess_diag</code>               (<code>bool</code>)           \u2013            </li> <li> <code>clamp_hess_quad</code>               (<code>bool</code>)           \u2013            </li> <li> <code>dV</code>               (<code>array</code>)           \u2013            </li> <li> <code>dhdX</code>               (<code>array</code>)           \u2013            </li> <li> <code>energy_density_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_diag_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_prod_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>energy_density_hess_quad_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>first_piola_kirchhoff_stress_func</code>               (<code>Function</code>)           \u2013            </li> <li> <code>fun_and_jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>fun_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>get_cell_params</code>               (<code>Function</code>)           \u2013            </li> <li> <code>hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_prod_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>hess_quad_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>id</code>               (<code>str</code>)           \u2013            </li> <li> <code>jac_and_hess_diag_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>jac_kernel</code>               (<code>Kernel</code>)           \u2013            </li> <li> <code>n_cells</code>               (<code>int</code>)           \u2013            </li> <li> <code>params</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>quadrature</code>               (<code>Scheme</code>)           \u2013            </li> <li> <code>requires_grad</code>               (<code>Sequence[str]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.cells","title":"cells  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cells: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.clamp_hess_diag","title":"clamp_hess_diag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_diag: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.clamp_hess_quad","title":"clamp_hess_quad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clamp_hess_quad: bool = True\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.dV","title":"dV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dV: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.dhdX","title":"dhdX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dhdX: array = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.energy_density_func","title":"energy_density_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_func: Function = field(\n    default=energy_density\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.energy_density_hess_diag_func","title":"energy_density_hess_diag_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_diag_func: Function = field(\n    default=energy_density_hess_diag\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.energy_density_hess_prod_func","title":"energy_density_hess_prod_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_prod_func: Function = field(\n    default=energy_density_hess_prod\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.energy_density_hess_quad_func","title":"energy_density_hess_quad_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energy_density_hess_quad_func: Function = field(\n    default=energy_density_hess_quad\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.first_piola_kirchhoff_stress_func","title":"first_piola_kirchhoff_stress_func  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>first_piola_kirchhoff_stress_func: Function = field(\n    default=first_piola_kirchhoff_stress_tensor\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.fun_and_jac_kernel","title":"fun_and_jac_kernel  <code>property</code>","text":"<pre><code>fun_and_jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.fun_kernel","title":"fun_kernel  <code>property</code>","text":"<pre><code>fun_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.get_cell_params","title":"get_cell_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>get_cell_params: Function = field(default=get_cell_params)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.hess_diag_kernel","title":"hess_diag_kernel  <code>property</code>","text":"<pre><code>hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.hess_prod_kernel","title":"hess_prod_kernel  <code>property</code>","text":"<pre><code>hess_prod_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.hess_quad_kernel","title":"hess_quad_kernel  <code>property</code>","text":"<pre><code>hess_quad_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: str = field(\n    default=Factory(_default_id, takes_self=True),\n    kw_only=True,\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.jac_and_hess_diag_kernel","title":"jac_and_hess_diag_kernel  <code>property</code>","text":"<pre><code>jac_and_hess_diag_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.jac_kernel","title":"jac_kernel  <code>property</code>","text":"<pre><code>jac_kernel: Kernel\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.n_cells","title":"n_cells  <code>property</code>","text":"<pre><code>n_cells: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.params","title":"params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>params: Struct = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.quadrature","title":"quadrature  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quadrature: Scheme = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.requires_grad","title":"requires_grad  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>requires_grad: Sequence[str] = field(\n    default=(), kw_only=True\n)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.from_pyvista","title":"from_pyvista  <code>classmethod</code>","text":"<pre><code>from_pyvista(\n    mesh: UnstructuredGrid,\n    *,\n    quadrature: Scheme | None = None,\n    **kwargs,\n) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_pyvista(\n    cls, mesh: pv.UnstructuredGrid, *, quadrature: Scheme | None = None, **kwargs\n) -&gt; Self:\n    region: Region = Region.from_pyvista(mesh, grad=True, quadrature=quadrature)\n    return cls.from_region(region, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.from_region","title":"from_region  <code>classmethod</code>","text":"<pre><code>from_region(region: Region, **kwargs) -&gt; Self\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@classmethod\ndef from_region(cls, region: Region, **kwargs) -&gt; Self:\n    self: Self = cls(\n        cells=wp.from_jax(region.cells_global, vec4i),\n        dhdX=wp.from_jax(region.dhdX, mat43),\n        dV=wp.from_jax(region.dV, float_),\n        quadrature=region.quadrature,\n        **kwargs,\n    )\n    if self.params is None:\n        self.params = self.make_params(region)\n    return self\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    wp.launch(\n        self.fun_and_jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[fun, jac],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d, *, start: int) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess(self, u: wp.array, output: Coo2d, *, start: int) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_prod_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.hess_quad_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, p, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef hess_size(self) -&gt; int:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac(self, u: wp.array, output: wp.array) -&gt; None:\n    wp.launch(\n        self.jac_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[output],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    wp.launch(\n        self.jac_and_hess_diag_kernel,\n        dim=(self.n_cells, self.quadrature.n_points),\n        inputs=[u, self.cells, self.dhdX, self.dV, self.params],\n        outputs=[jac, hess_diag],\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.make_params","title":"make_params","text":"<pre><code>make_params(region: Region) -&gt; Struct\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/_main.py</code> <pre><code>@override\ndef make_params(self, region: Region) -&gt; Struct:\n    params = func.Params()\n    params.activation = wp_utils.to_warp(\n        region.cell_data[\"activation\"],\n        dtype=vec6,\n        requires_grad=\"activation\" in self.requires_grad,\n    )\n    params.active_fraction = wp_utils.to_warp(\n        region.cell_data[\"active-fraction\"],\n        dtype=float_,\n        requires_grad=\"active-fraction\" in self.requires_grad,\n    )\n    params.lambda_ = wp_utils.to_warp(\n        region.cell_data[\"lambda\"],\n        dtype=float_,\n        requires_grad=\"lambda\" in self.requires_grad,\n    )\n    params.mu = wp_utils.to_warp(\n        region.cell_data[\"mu\"],\n        dtype=float_,\n        requires_grad=\"mu\" in self.requires_grad,\n    )\n    return params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/#liblaf.apple.warp.sim.energy.elastic.phace.Phace.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, array]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/_elastic.py</code> <pre><code>@override\ndef mixed_derivative_prod(self, u: wp.array, p: wp.array) -&gt; dict[str, wp.array]:\n    if not self.requires_grad:\n        return {}\n    for name in self.requires_grad:\n        getattr(self.params, name).grad.zero_()\n    output: wp.array = wp.zeros_like(u)\n    with wp.Tape() as tape:\n        self.jac(u, output)\n    tape.backward(grads={output: p})\n    outputs: dict[str, wp.array] = {\n        name: getattr(self.params, name).grad for name in self.requires_grad\n    }\n    ic(outputs[\"activation\"].numpy())\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/","title":"func","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func","title":"liblaf.apple.warp.sim.energy.elastic.phace.func","text":"<p>Classes:</p> <ul> <li> <code>Params</code>           \u2013            </li> <li> <code>ParamsElem</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>energy_density_hess_diag</code>             \u2013              </li> <li> <code>energy_density_hess_prod</code>             \u2013              </li> <li> <code>energy_density_hess_quad</code>             \u2013              </li> <li> <code>first_piola_kirchhoff_stress_tensor</code>             \u2013              </li> <li> <code>get_cell_params</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.Params","title":"Params","text":"<p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>array(dtype=vec6)</code>)           \u2013            </li> <li> <code>active_fraction</code>               (<code>array(dtype=float_)</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>array(dtype=float_)</code>)           \u2013            </li> <li> <code>mu</code>               (<code>array(dtype=float_)</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.Params.activation","title":"activation  <code>instance-attribute</code>","text":"<pre><code>activation: array(dtype=vec6)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.Params.active_fraction","title":"active_fraction  <code>instance-attribute</code>","text":"<pre><code>active_fraction: array(dtype=float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.Params.lambda_","title":"lambda_  <code>instance-attribute</code>","text":"<pre><code>lambda_: array(dtype=float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.Params.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: array(dtype=float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem","title":"ParamsElem","text":"<p>Attributes:</p> <ul> <li> <code>activation</code>               (<code>vec6</code>)           \u2013            </li> <li> <code>active_fraction</code>               (<code>float_</code>)           \u2013            </li> <li> <code>lambda_</code>               (<code>float_</code>)           \u2013            </li> <li> <code>mu</code>               (<code>float_</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem.activation","title":"activation  <code>instance-attribute</code>","text":"<pre><code>activation: vec6\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem.active_fraction","title":"active_fraction  <code>instance-attribute</code>","text":"<pre><code>active_fraction: float_\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem.lambda_","title":"lambda_  <code>instance-attribute</code>","text":"<pre><code>lambda_: float_\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.ParamsElem.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: float_\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.energy_density","title":"energy_density","text":"<pre><code>energy_density(F: mat33, params: ParamsElem)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density(F: mat33, params: ParamsElem):  # -&gt; float:\n    _1 = type(F[0, 0])(1.0)\n    _2 = type(F[0, 0])(2.0)\n    J = _f.I3(F)  # float\n    Psi_ARAP_active = arap_active.energy_density(\n        F, arap_active.ParamsElem(activation=params.activation, mu=params.mu)\n    )  # float\n    Psi_ARAP_passive = arap.energy_density(F, arap.ParamsElem(mu=params.mu))  # float\n    Psi_ARAP = (\n        params.active_fraction * Psi_ARAP_active\n        + (_1 - params.active_fraction) * Psi_ARAP_passive\n    )  # float\n    Psi_VP = params.lambda_ * math.square(J - _1)  # float\n    Psi = _2 * Psi_ARAP + Psi_VP  # float\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.energy_density_hess_diag","title":"energy_density_hess_diag","text":"<pre><code>energy_density_hess_diag(\n    F: mat33, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_diag(F: mat33, dhdX: mat43, params: ParamsElem):  # -&gt; mat43:\n    _1 = type(F[0, 0])(1.0)\n    _2 = type(F[0, 0])(2.0)\n    J = _f.I3(F)  # float\n    g3 = _f.g3(F)  # mat33\n    diag_arap_active = arap_active.energy_density_hess_diag(\n        F, dhdX, arap_active.ParamsElem(activation=params.activation, mu=params.mu)\n    )  # mat43\n    diag_arap_passive = arap.energy_density_hess_diag(\n        F, dhdX, arap.ParamsElem(mu=params.mu)\n    )  # mat43\n    diag_arap = (\n        params.active_fraction * diag_arap_active\n        + (_1 - params.active_fraction) * diag_arap_passive\n    )  # mat43\n    d2Psi_dI32 = _2 * params.lambda_  # float\n    dPsi_dI3 = _2 * params.lambda_ * (J - _1)  # float\n    h3_diag = _f.h3_diag(dhdX, g3)  # mat43\n    h6_diag = _f.h6_diag(dhdX, F)  # mat43\n    diag_vp = d2Psi_dI32 * h3_diag + dPsi_dI3 * h6_diag  # mat43\n    diag = _2 * diag_arap + diag_vp  # mat43\n    return diag\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.energy_density_hess_prod","title":"energy_density_hess_prod","text":"<pre><code>energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; mat43:\n    _1 = type(F[0, 0])(1.0)\n    _2 = type(F[0, 0])(2.0)\n    J = _f.I3(F)  # float\n    g3 = _f.g3(F)  # mat33\n    prod_arap_active = arap_active.energy_density_hess_prod(\n        F, p, dhdX, arap_active.ParamsElem(activation=params.activation, mu=params.mu)\n    )  # mat43\n    prod_arap_passive = arap.energy_density_hess_prod(\n        F, p, dhdX, arap.ParamsElem(mu=params.mu)\n    )  # mat43\n    prod_arap = (\n        params.active_fraction * prod_arap_active\n        + (_1 - params.active_fraction) * prod_arap_passive\n    )  # mat43\n    d2Psi_dI32 = _2 * params.lambda_  # float\n    dPsi_dI3 = _2 * params.lambda_ * (J - _1)  # float\n    h3_prod = _f.h3_prod(p, dhdX, g3)  # mat43\n    h6_prod = _f.h6_prod(p, dhdX, F)  # mat43\n    prod_vp = d2Psi_dI32 * h3_prod + dPsi_dI3 * h6_prod  # mat43\n    prod = _2 * prod_arap + prod_vp  # mat43\n    return prod\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.energy_density_hess_quad","title":"energy_density_hess_quad","text":"<pre><code>energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: ParamsElem\n):  # -&gt; float:\n    _1 = type(F[0, 0])(1.0)\n    _2 = type(F[0, 0])(2.0)\n    J = _f.I3(F)  # float\n    g3 = _f.g3(F)  # mat33\n    quad_arap_active = arap_active.energy_density_hess_quad(\n        F, p, dhdX, arap_active.ParamsElem(activation=params.activation, mu=params.mu)\n    )\n    quad_arap_passive = arap.energy_density_hess_quad(\n        F, p, dhdX, arap.ParamsElem(mu=params.mu)\n    )\n    quad_arap = (\n        params.active_fraction * quad_arap_active\n        + (_1 - params.active_fraction) * quad_arap_passive\n    )\n    d2Psi_dI32 = _2 * params.lambda_  # float\n    dPsi_dI3 = _2 * params.lambda_ * (J - _1)  # float\n    h3_quad = _f.h3_quad(p, dhdX, g3)  # float\n    h6_quad = _f.h6_quad(p, dhdX, F)  # float\n    quad_vp = d2Psi_dI32 * h3_quad + dPsi_dI3 * h6_quad  # float\n    # if quad_vp &lt; 0.0:\n    #     wp.printf(\n    #         \"h3_quad = %f, h6_quad = %f, quad_vp = %f\\n\", h3_quad, h6_quad, quad_vp\n    #     )\n    quad = _2 * quad_arap + quad_vp  # float\n    return quad\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.first_piola_kirchhoff_stress_tensor","title":"first_piola_kirchhoff_stress_tensor","text":"<pre><code>first_piola_kirchhoff_stress_tensor(\n    F: mat33, params: ParamsElem\n)\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef first_piola_kirchhoff_stress_tensor(F: mat33, params: ParamsElem):  # -&gt; mat33:\n    _1 = type(F[0, 0])(1.0)\n    _2 = type(F[0, 0])(2.0)\n    J = _f.I3(F)  # float\n    g3 = _f.g3(F)  # mat33\n    PK1_ARAP_active = arap_active.first_piola_kirchhoff_stress_tensor(\n        F, arap_active.ParamsElem(activation=params.activation, mu=params.mu)\n    )  # mat33\n    PK1_ARAP_passive = arap.first_piola_kirchhoff_stress_tensor(\n        F, arap.ParamsElem(mu=params.mu)\n    )  # mat33\n    PK1_ARAP = (\n        params.active_fraction * PK1_ARAP_active\n        + (_1 - params.active_fraction) * PK1_ARAP_passive\n    )  # mat33\n    PK1_VP = _2 * params.lambda_ * (J - _1) * g3  # mat33\n    PK1 = _2 * PK1_ARAP + PK1_VP  # mat33\n    return PK1\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace/func/#liblaf.apple.warp.sim.energy.elastic.phace.func.get_cell_params","title":"get_cell_params","text":"<pre><code>get_cell_params(params: Params, cid: int) -&gt; ParamsElem\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef get_cell_params(params: Params, cid: int) -&gt; ParamsElem:\n    cell_params = ParamsElem(\n        activation=params.activation[cid],\n        active_fraction=params.active_fraction[cid],\n        lambda_=params.lambda_[cid],\n        mu=params.mu[cid],\n    )\n    return cell_params\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/","title":"phace_passive","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/#liblaf.apple.warp.sim.energy.elastic.phace_passive","title":"liblaf.apple.warp.sim.energy.elastic.phace_passive","text":"<p>Modules:</p> <ul> <li> <code>func</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/","title":"func","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func","title":"liblaf.apple.warp.sim.energy.elastic.phace_passive.func","text":"<p>Classes:</p> <ul> <li> <code>Params</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>energy_density</code>             \u2013              </li> <li> <code>energy_density_hess_diag</code>             \u2013              </li> <li> <code>energy_density_hess_prod</code>             \u2013              </li> <li> <code>energy_density_hess_quad</code>             \u2013              </li> <li> <code>first_piola_kirchhoff_stress_tensor</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func.Params","title":"Params","text":"<p>Attributes:</p> <ul> <li> <code>lambda_</code>               (<code>float</code>)           \u2013            </li> <li> <code>mu</code>               (<code>float</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func.Params.lambda_","title":"lambda_  <code>instance-attribute</code>","text":"<pre><code>lambda_: float\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func.Params.mu","title":"mu  <code>instance-attribute</code>","text":"<pre><code>mu: float\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func.energy_density","title":"energy_density","text":"<pre><code>energy_density(F: mat33, params: Params) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace_passive/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density(F: mat33, params: Params) -&gt; None:\n    Psi_ARAP = arap_func.energy_density(F, params)  # float\n    raise NotImplementedError\n    Psi = Psi_ARAP\n    return Psi\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func.energy_density_hess_diag","title":"energy_density_hess_diag","text":"<pre><code>energy_density_hess_diag(\n    F: mat33, dhdX: mat43, params: Params\n) -&gt; mat33\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace_passive/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_diag(F: mat33, dhdX: mat43, params: Params) -&gt; mat33:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_diag = func.h4_diag(dhdX=dhdX, lambdas=lambdas, Q0=Q0, Q1=Q1, Q2=Q2)  # mat43\n    h5_diag = func.h5_diag(dh_dX=dhdX)  # mat43\n    h_diag = -type(F[0, 0])(2.0) * h4_diag + h5_diag  # mat43\n    return type(params.mu)(0.5) * params.mu * h_diag  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func.energy_density_hess_prod","title":"energy_density_hess_prod","text":"<pre><code>energy_density_hess_prod(\n    F: mat33, p: mat43, dhdX: mat43, params: Params\n) -&gt; mat43\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace_passive/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_prod(F: mat33, p: mat43, dhdX: mat43, params: Params) -&gt; mat43:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_prod = func.h4_prod(\n        dhdX=dhdX, lambdas=lambdas, p=p, Q0=Q0, Q1=Q1, Q2=Q2\n    )  # mat43\n    h5_prod = func.h5_prod(dhdX=dhdX, p=p)  # mat43\n    h_prod = -type(F[0, 0])(2.0) * h4_prod + h5_prod  # mat43\n    return type(params.mu)(0.5) * params.mu * h_prod  # mat43\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func.energy_density_hess_quad","title":"energy_density_hess_quad","text":"<pre><code>energy_density_hess_quad(\n    F: mat33, p: mat43, dhdX: mat43, params: Params\n) -&gt; float_\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace_passive/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef energy_density_hess_quad(F: mat33, p: mat43, dhdX: mat43, params: Params) -&gt; float_:\n    U, s, V = math.svd_rv(F)  # mat33, vec3, mat33\n    lambdas = func.lambdas(s)  # vec3\n    Q0, Q1, Q2 = func.Qs(U, V)  # mat33, mat33, mat33\n    h4_quad = func.h4_quad(p=p, dhdX=dhdX, lambdas=lambdas, Q0=Q0, Q1=Q1, Q2=Q2)\n    h5_quad = func.h5_quad(p=p, dhdX=dhdX)\n    h_quad = -type(F[0, 0])(2.0) * h4_quad + h5_quad\n    return type(params.mu)(0.5) * params.mu * h_quad\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/phace_passive/func/#liblaf.apple.warp.sim.energy.elastic.phace_passive.func.first_piola_kirchhoff_stress_tensor","title":"first_piola_kirchhoff_stress_tensor","text":"<pre><code>first_piola_kirchhoff_stress_tensor(\n    F: mat33, params: Params\n) -&gt; mat33\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/phace_passive/func.py</code> <pre><code>@wp.func\n@no_type_check\ndef first_piola_kirchhoff_stress_tensor(F: mat33, params: Params) -&gt; mat33:\n    R, _ = math.polar_rv(F)  # mat33\n    PK1 = params.mu * (F - R)  # mat33\n    raise NotImplementedError\n    return PK1\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/","title":"utils","text":""},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils","title":"liblaf.apple.warp.sim.energy.elastic.utils","text":"<p>Classes:</p> <ul> <li> <code>ParamsFactory</code>           \u2013            </li> <li> <code>ParamsStructs</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>define_params</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils.ParamsFactory","title":"ParamsFactory","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils.ParamsFactory.__call__","title":"__call__","text":"<pre><code>__call__(\n    floating: type[float_base],\n) -&gt; tuple[Struct, Struct]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/utils/_params.py</code> <pre><code>def __call__(\n    self, floating: type[wpt.float_base], /\n) -&gt; tuple[warp.codegen.Struct, warp.codegen.Struct]: ...\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils.ParamsStructs","title":"ParamsStructs","text":"<p>Parameters:</p> <ul> <li> <code>Params32</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>Params64</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>ParamsElem32</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>ParamsElem64</code>               (<code>Struct</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>Params32</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>Params64</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>ParamsElem32</code>               (<code>Struct</code>)           \u2013            </li> <li> <code>ParamsElem64</code>               (<code>Struct</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils.ParamsStructs.Params32","title":"Params32  <code>instance-attribute</code>","text":"<pre><code>Params32: Struct\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils.ParamsStructs.Params64","title":"Params64  <code>instance-attribute</code>","text":"<pre><code>Params64: Struct\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils.ParamsStructs.ParamsElem32","title":"ParamsElem32  <code>instance-attribute</code>","text":"<pre><code>ParamsElem32: Struct\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils.ParamsStructs.ParamsElem64","title":"ParamsElem64  <code>instance-attribute</code>","text":"<pre><code>ParamsElem64: Struct\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/energy/elastic/utils/#liblaf.apple.warp.sim.energy.elastic.utils.define_params","title":"define_params","text":"<pre><code>define_params(factory: ParamsFactory) -&gt; ParamsStructs\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/energy/elastic/utils/_params.py</code> <pre><code>def define_params(factory: ParamsFactory) -&gt; ParamsStructs:\n    Params32: warp.codegen.Struct\n    ParamsElem32: warp.codegen.Struct\n    Params32, ParamsElem32 = factory(wpt.float32)\n    Params64: warp.codegen.Struct\n    ParamsElem64: warp.codegen.Struct\n    Params64, ParamsElem64 = factory(wpt.float64)\n    return ParamsStructs(\n        Params32=Params32,\n        Params64=Params64,\n        ParamsElem32=ParamsElem32,\n        ParamsElem64=ParamsElem64,\n    )\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/","title":"model","text":""},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model","title":"liblaf.apple.warp.sim.model","text":"<p>Classes:</p> <ul> <li> <code>Model</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model","title":"Model","text":"<p>Parameters:</p> <ul> <li> <code>energies</code>               (<code>Mapping[str, Energy]</code>, default:                   <code>&lt;class 'dict'&gt;</code> )           \u2013            <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object\u2019s     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>fun</code>             \u2013              </li> <li> <code>fun_and_jac</code>             \u2013              </li> <li> <code>hess</code>             \u2013              </li> <li> <code>hess_diag</code>             \u2013              </li> <li> <code>hess_prod</code>             \u2013              </li> <li> <code>hess_quad</code>             \u2013              </li> <li> <code>hess_size</code>             \u2013              </li> <li> <code>jac</code>             \u2013              </li> <li> <code>jac_and_hess_diag</code>             \u2013              </li> <li> <code>mixed_derivative_prod</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>energies</code>               (<code>Mapping[str, Energy]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.energies","title":"energies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>energies: Mapping[str, Energy] = field(factory=dict)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.fun","title":"fun","text":"<pre><code>fun(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def fun(self, u: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.fun(u, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.fun_and_jac","title":"fun_and_jac","text":"<pre><code>fun_and_jac(u: array, fun: array, jac: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def fun_and_jac(self, u: wp.array, fun: wp.array, jac: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.fun_and_jac(u, fun, jac)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.hess","title":"hess","text":"<pre><code>hess(u: array, output: Coo2d) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess(self, u: wp.array, output: Coo2d) -&gt; None:\n    start: int = 0\n    for energy in self.energies.values():\n        energy.hess(u, output, start=start)\n        start += energy.hess_size()\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.hess_diag","title":"hess_diag","text":"<pre><code>hess_diag(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess_diag(self, u: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.hess_diag(u, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.hess_prod","title":"hess_prod","text":"<pre><code>hess_prod(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess_prod(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.hess_prod(u, p, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.hess_quad","title":"hess_quad","text":"<pre><code>hess_quad(u: array, p: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess_quad(self, u: wp.array, p: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.hess_quad(u, p, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.hess_size","title":"hess_size","text":"<pre><code>hess_size() -&gt; int\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def hess_size(self) -&gt; int:\n    size: int = 0\n    for energy in self.energies.values():\n        size += energy.hess_size()\n    return size\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.jac","title":"jac","text":"<pre><code>jac(u: array, output: array) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def jac(self, u: wp.array, output: wp.array) -&gt; None:\n    for energy in self.energies.values():\n        energy.jac(u, output)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.jac_and_hess_diag","title":"jac_and_hess_diag","text":"<pre><code>jac_and_hess_diag(\n    u: array, jac: array, hess_diag: array\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def jac_and_hess_diag(\n    self, u: wp.array, jac: wp.array, hess_diag: wp.array\n) -&gt; None:\n    for energy in self.energies.values():\n        energy.jac_and_hess_diag(u, jac, hess_diag)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sim/model/#liblaf.apple.warp.sim.model.Model.mixed_derivative_prod","title":"mixed_derivative_prod","text":"<pre><code>mixed_derivative_prod(\n    u: array, p: array\n) -&gt; dict[str, dict[str, array]]\n</code></pre> Source code in <code>src/liblaf/apple/warp/sim/model/_model.py</code> <pre><code>def mixed_derivative_prod(\n    self, u: wp.array, p: wp.array\n) -&gt; dict[str, dict[str, wp.array]]:\n    outputs: dict[str, dict[str, wp.array]] = {\n        energy.id: energy.mixed_derivative_prod(u, p)\n        for energy in self.energies.values()\n    }\n    return outputs\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sparse/","title":"sparse","text":""},{"location":"reference/liblaf/apple/warp/sparse/#liblaf.apple.warp.sparse","title":"liblaf.apple.warp.sparse","text":"<p>Classes:</p> <ul> <li> <code>Coo2d</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sparse/#liblaf.apple.warp.sparse.Coo2d","title":"Coo2d","text":"<p>Attributes:</p> <ul> <li> <code>coords</code>               (<code>array(dtype=vec2i)</code>)           \u2013            </li> <li> <code>data</code>               (<code>array(dtype=float_)</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/sparse/#liblaf.apple.warp.sparse.Coo2d.coords","title":"coords  <code>instance-attribute</code>","text":"<pre><code>coords: array(dtype=vec2i)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/sparse/#liblaf.apple.warp.sparse.Coo2d.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: array(dtype=float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/","title":"typing","text":""},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing","title":"liblaf.apple.warp.typing","text":"<p>Modules:</p> <ul> <li> <code>generics</code>           \u2013            </li> </ul> <p>Type Aliases:</p> <ul> <li> <code>Struct</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>floating_dtypes</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>float_</code>           \u2013            </li> <li> <code>int_</code>           \u2013            </li> <li> <code>mat33</code>           \u2013            </li> <li> <code>mat43</code>           \u2013            </li> <li> <code>vec3</code>           \u2013            </li> <li> <code>vec4i</code>           \u2013            </li> <li> <code>vec6</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.float_","title":"float_  <code>module-attribute</code>","text":"<pre><code>float_ = float64\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.int_","title":"int_  <code>module-attribute</code>","text":"<pre><code>int_ = int32\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.mat33","title":"mat33  <code>module-attribute</code>","text":"<pre><code>mat33 = matrix((3, 3), float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.mat43","title":"mat43  <code>module-attribute</code>","text":"<pre><code>mat43 = matrix((4, 3), float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.vec3","title":"vec3  <code>module-attribute</code>","text":"<pre><code>vec3 = vector(3, float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.vec4i","title":"vec4i  <code>module-attribute</code>","text":"<pre><code>vec4i = vector(4, int_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.vec6","title":"vec6  <code>module-attribute</code>","text":"<pre><code>vec6 = vector(6, float_)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.Struct","title":"Struct","text":"<pre><code>Struct = Any\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/#liblaf.apple.warp.typing.floating_dtypes","title":"floating_dtypes","text":"<pre><code>floating_dtypes() -&gt; list[type[float_base]]\n</code></pre> Source code in <code>src/liblaf/apple/warp/typing/_types.py</code> <pre><code>def floating_dtypes() -&gt; list[type[wpt.float_base]]:\n    return [wpt.float32, wpt.float64]\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/generics/","title":"generics","text":""},{"location":"reference/liblaf/apple/warp/typing/generics/#liblaf.apple.warp.typing.generics","title":"liblaf.apple.warp.typing.generics","text":"<p>Attributes:</p> <ul> <li> <code>float_</code>           \u2013            </li> <li> <code>int_</code>           \u2013            </li> <li> <code>mat33</code>           \u2013            </li> <li> <code>mat43</code>           \u2013            </li> <li> <code>vec3</code>           \u2013            </li> <li> <code>vec4i</code>           \u2013            </li> <li> <code>vec6</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/typing/generics/#liblaf.apple.warp.typing.generics.float_","title":"float_  <code>module-attribute</code>","text":"<pre><code>float_ = Any\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/generics/#liblaf.apple.warp.typing.generics.int_","title":"int_  <code>module-attribute</code>","text":"<pre><code>int_ = Any\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/generics/#liblaf.apple.warp.typing.generics.mat33","title":"mat33  <code>module-attribute</code>","text":"<pre><code>mat33 = Any\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/generics/#liblaf.apple.warp.typing.generics.mat43","title":"mat43  <code>module-attribute</code>","text":"<pre><code>mat43 = Any\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/generics/#liblaf.apple.warp.typing.generics.vec3","title":"vec3  <code>module-attribute</code>","text":"<pre><code>vec3 = Any\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/generics/#liblaf.apple.warp.typing.generics.vec4i","title":"vec4i  <code>module-attribute</code>","text":"<pre><code>vec4i = Any\n</code></pre>"},{"location":"reference/liblaf/apple/warp/typing/generics/#liblaf.apple.warp.typing.generics.vec6","title":"vec6  <code>module-attribute</code>","text":"<pre><code>vec6 = Any\n</code></pre>"},{"location":"reference/liblaf/apple/warp/utils/","title":"utils","text":""},{"location":"reference/liblaf/apple/warp/utils/#liblaf.apple.warp.utils","title":"liblaf.apple.warp.utils","text":"<p>Classes:</p> <ul> <li> <code>MatrixLike</code>           \u2013            </li> <li> <code>VectorLike</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>jax_callable</code>             \u2013              </li> <li> <code>to_warp</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/apple/warp/utils/#liblaf.apple.warp.utils.MatrixLike","title":"MatrixLike","text":"<pre><code>MatrixLike(rows: int, cols: int)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>tuple[int, int]</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>shape</code>               (<code>tuple[int, int]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/apple/warp/utils/_to_warp.py</code> <pre><code>def __init__(self, rows: int, cols: int) -&gt; None:\n    self.__attrs_init__(shape=(rows, cols))  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/apple/warp/utils/#liblaf.apple.warp.utils.MatrixLike.shape","title":"shape  <code>instance-attribute</code>","text":"<pre><code>shape: tuple[int, int]\n</code></pre>"},{"location":"reference/liblaf/apple/warp/utils/#liblaf.apple.warp.utils.VectorLike","title":"VectorLike","text":"<p>Parameters:</p> <ul> <li> <code>length</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>length</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/apple/warp/utils/#liblaf.apple.warp.utils.VectorLike.length","title":"length  <code>instance-attribute</code>","text":"<pre><code>length: int\n</code></pre>"},{"location":"reference/liblaf/apple/warp/utils/#liblaf.apple.warp.utils.jax_callable","title":"jax_callable","text":"<pre><code>jax_callable(\n    func: Callable,\n    *,\n    num_outputs: int = 1,\n    graph_mode: GraphMode = JAX,\n    output_dims: OutputDims | None = None,\n    **kwargs,\n) -&gt; FfiCallable\n</code></pre><pre><code>jax_callable(\n    *,\n    num_outputs: int = 1,\n    graph_mode: GraphMode = JAX,\n    output_dims: OutputDims | None = None,\n    **kwargs,\n) -&gt; Callable[[Callable], FfiCallable]\n</code></pre> <pre><code>jax_callable(func: Callable | None = None, **kwargs) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/apple/warp/utils/_jax.py</code> <pre><code>def jax_callable(func: Callable | None = None, **kwargs) -&gt; Any:\n    if func is None:\n        return functools.partial(jax_callable, **kwargs)\n    return ffi.jax_callable(func, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/apple/warp/utils/#liblaf.apple.warp.utils.to_warp","title":"to_warp","text":"<pre><code>to_warp(\n    a: Any,\n    dtype: Any | None = None,\n    shape: Sequence[int] | None = None,\n    *,\n    requires_grad: bool = False,\n) -&gt; array\n</code></pre> Source code in <code>src/liblaf/apple/warp/utils/_to_warp.py</code> <pre><code>def to_warp(\n    a: Any,\n    dtype: Any | None = None,\n    shape: Sequence[int] | None = None,\n    *,\n    requires_grad: bool = False,\n) -&gt; wp.array:\n    match grapes.array_kind(a):\n        case \"numpy\":\n            assert isinstance(a, np.ndarray)\n            if isinstance(dtype, MatrixLike):\n                dtype = wpt.matrix(dtype.shape, wp.dtype_from_numpy(a.dtype))\n            elif isinstance(dtype, VectorLike):\n                dtype = wpt.vector(dtype.length, wp.dtype_from_numpy(a.dtype))\n            return wp.from_numpy(\n                a, dtype=dtype, shape=shape, requires_grad=requires_grad\n            )\n        case \"jax\":\n            assert isinstance(a, Array)\n            if isinstance(dtype, MatrixLike):\n                dtype = wpt.matrix(dtype.shape, wp.dtype_from_jax(a.dtype))\n            elif isinstance(dtype, VectorLike):\n                dtype = wpt.vector(dtype.length, wp.dtype_from_jax(a.dtype))\n            a_wp: wp.array = wp.from_jax(a, dtype=dtype)\n            a_wp.requires_grad = requires_grad\n            return a_wp\n        case _:\n            return wp.from_numpy(\n                np.asarray(a), dtype=dtype, shape=shape, requires_grad=requires_grad\n            )\n</code></pre>"}]}