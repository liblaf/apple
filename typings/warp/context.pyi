import ast
import ctypes
import io
import numpy as np
import types
import warp
import warp.codegen
from _typeshed import Incomplete
from typing import Any, Callable, Literal, Mapping, Sequence, TypeVar
from warp.types import Array as Array, launch_bounds_t as launch_bounds_t

def create_value_func(type): ...
def get_function_args(func): ...

complex_type_hints: Incomplete
sequence_types: Incomplete
function_key_counts: dict[str, int]

def generate_unique_function_identifier(key: str) -> str: ...

class Function:
    func: Incomplete
    key: Incomplete
    namespace: Incomplete
    value_type: Incomplete
    value_func: Incomplete
    export_func: Incomplete
    dispatch_func: Incomplete
    lto_dispatch_func: Incomplete
    input_types: Incomplete
    export: Incomplete
    doc: Incomplete
    group: Incomplete
    module: Incomplete
    variadic: Incomplete
    defaults: Incomplete
    custom_replay_func: Incomplete
    native_snippet: Incomplete
    adj_native_snippet: Incomplete
    replay_snippet: Incomplete
    custom_grad_func: Function | None
    require_original_output_arg: Incomplete
    generic_parent: Incomplete
    initializer_list_func: Incomplete
    hidden: Incomplete
    skip_replay: Incomplete
    missing_grad: Incomplete
    generic: Incomplete
    mangled_name: str | None
    native_func: Incomplete
    user_templates: dict[str, Function]
    user_overloads: dict[str, Function]
    adj: Incomplete
    overloads: list[Function]
    signature: Incomplete
    def __init__(self, func: Callable | None, key: str, namespace: str, input_types: dict[str, type | TypeVar] | None = None, value_type: type | None = None, value_func: Callable[[Mapping[str, type], Mapping[str, Any]], type] | None = None, export_func: Callable[[dict[str, type]], dict[str, type]] | None = None, dispatch_func: Callable | None = None, lto_dispatch_func: Callable | None = None, module: Module | None = None, variadic: bool = False, initializer_list_func: Callable[[dict[str, Any], type], bool] | None = None, export: bool = False, source: str | None = None, doc: str = '', group: str = '', hidden: bool = False, skip_replay: bool = False, missing_grad: bool = False, generic: bool = False, native_func: str | None = None, defaults: dict[str, Any] | None = None, custom_replay_func: Function | None = None, native_snippet: str | None = None, adj_native_snippet: str | None = None, replay_snippet: str | None = None, skip_forward_codegen: bool = False, skip_reverse_codegen: bool = False, custom_reverse_num_input_args: int = -1, custom_reverse_mode: bool = False, overloaded_annotations: dict[str, type] | None = None, code_transformers: list[ast.NodeTransformer] | None = None, skip_adding_overload: bool = False, require_original_output_arg: bool = False, scope_locals: dict[str, Any] | None = None) -> None: ...
    def __call__(self, *args, **kwargs): ...
    def is_builtin(self) -> bool: ...
    def is_simple(self) -> bool: ...
    def mangle(self) -> str: ...
    def add_overload(self, f: Function) -> None: ...
    def get_overload(self, arg_types: list[type], kwarg_types: Mapping[str, type]) -> Function | None: ...

def get_builtin_type(return_type: type) -> type: ...
def extract_return_value(value_type: type, value_ctype: type, ret: Any) -> Any: ...
def call_builtin(func: Function, params: tuple) -> tuple[bool, Any]: ...

class KernelHooks:
    forward: Incomplete
    backward: Incomplete
    forward_smem_bytes: Incomplete
    backward_smem_bytes: Incomplete
    def __init__(self, forward, backward, forward_smem_bytes: int = 0, backward_smem_bytes: int = 0) -> None: ...

class Kernel:
    func: Incomplete
    module: Incomplete
    key: Incomplete
    options: Incomplete
    adj: Incomplete
    is_generic: bool
    sig: str
    overloads: Incomplete
    generic_parent: Incomplete
    arg_indices: Incomplete
    hash: Incomplete
    def __init__(self, func, key=None, module=None, options=None, code_transformers=None, source=None) -> None: ...
    def infer_argument_types(self, args): ...
    def add_overload(self, arg_types): ...
    def get_overload(self, arg_types): ...
    def get_mangled_name(self): ...
    def __call__(self, *args, **kwargs) -> None: ...

def func(f: Callable | None = None, *, name: str | None = None): ...
def func_native(snippet: str, adj_snippet: str | None = None, replay_snippet: str | None = None): ...
def func_grad(forward_fn): ...
def func_replay(forward_fn): ...
def kernel(f: Callable | None = None, *, enable_backward: bool | None = None, module: Module | Literal['unique'] | None = None): ...
def struct(c: type): ...
def overload(kernel, arg_types=...): ...

builtin_functions: dict[str, Function]

def get_generic_vtypes(): ...

generic_vtypes: Incomplete
scalar_types: Incomplete

def add_builtin(key: str, input_types: dict[str, type | TypeVar] | None = None, constraint: Callable[[Mapping[str, type]], bool] | None = None, value_type: type | None = None, value_func: Callable | None = None, export_func: Callable | None = None, dispatch_func: Callable | None = None, lto_dispatch_func: Callable | None = None, doc: str = '', namespace: str = 'wp::', variadic: bool = False, initializer_list_func=None, export: bool = True, group: str = 'Other', hidden: bool = False, skip_replay: bool = False, missing_grad: bool = False, native_func: str | None = None, defaults: dict[str, Any] | None = None, require_original_output_arg: bool = False): ...
def register_api_function(function: Function, group: str = 'Other', hidden: bool = False): ...

user_modules: dict[str, Module]

def get_module(name: str) -> Module: ...

class ModuleHasher:
    function_hashes: Incomplete
    functions_in_progress: Incomplete
    unique_kernels: Incomplete
    module_hash: Incomplete
    def __init__(self, module) -> None: ...
    def hash_kernel(self, kernel: Kernel) -> bytes: ...
    def hash_function(self, func: Function) -> bytes: ...
    def hash_adjoint(self, adj: warp.codegen.Adjoint) -> bytes: ...
    def get_constant_bytes(self, value) -> bytes: ...
    def get_module_hash(self) -> bytes: ...
    def get_unique_kernels(self): ...

class ModuleBuilder:
    functions: Incomplete
    structs: Incomplete
    options: Incomplete
    module: Incomplete
    deferred_functions: Incomplete
    fatbins: Incomplete
    ltoirs: Incomplete
    ltoirs_decl: Incomplete
    shared_memory_bytes: Incomplete
    kernels: Incomplete
    def __init__(self, module, options, hasher=None) -> None: ...
    def build_struct_recursive(self, struct: warp.codegen.Struct): ...
    def build_struct(self, struct) -> None: ...
    def build_kernel(self, kernel) -> None: ...
    def build_function(self, func): ...
    def build_meta(self): ...
    def codegen(self, device): ...

class ModuleExec:
    def __new__(cls, *args, **kwargs): ...
    handle: Incomplete
    module_hash: Incomplete
    device: Incomplete
    kernel_hooks: Incomplete
    meta: Incomplete
    def __init__(self, handle, module_hash, device, meta) -> None: ...
    def __del__(self) -> None: ...
    def get_kernel_hooks(self, kernel) -> KernelHooks: ...

class Module:
    name: Incomplete
    loader: Incomplete
    kernels: Incomplete
    functions: Incomplete
    structs: Incomplete
    execs: Incomplete
    failed_builds: Incomplete
    hashers: Incomplete
    cpu_exec_id: int
    options: Incomplete
    references: Incomplete
    dependents: Incomplete
    def __init__(self, name: str | None, loader=None) -> None: ...
    def register_struct(self, struct) -> None: ...
    def register_kernel(self, kernel) -> None: ...
    def register_function(self, func, scope_locals, skip_adding_overload: bool = False) -> None: ...
    @property
    def live_kernels(self): ...
    def find_kernel(self, func): ...
    def find_references(self, adj) -> None: ...
    def hash_module(self): ...
    def load(self, device, block_dim=None) -> ModuleExec: ...
    def unload(self) -> None: ...
    def mark_modified(self) -> None: ...
    def get_kernel_hooks(self, kernel, device: Device) -> KernelHooks: ...

class CpuDefaultAllocator:
    deleter: Incomplete
    def __init__(self, device) -> None: ...
    def alloc(self, size_in_bytes): ...
    def free(self, ptr, size_in_bytes) -> None: ...

class CpuPinnedAllocator:
    deleter: Incomplete
    def __init__(self, device) -> None: ...
    def alloc(self, size_in_bytes): ...
    def free(self, ptr, size_in_bytes) -> None: ...

class CudaDefaultAllocator:
    device: Incomplete
    deleter: Incomplete
    def __init__(self, device) -> None: ...
    def alloc(self, size_in_bytes): ...
    def free(self, ptr, size_in_bytes) -> None: ...

class CudaMempoolAllocator:
    device: Incomplete
    deleter: Incomplete
    def __init__(self, device) -> None: ...
    def alloc(self, size_in_bytes): ...
    def free(self, ptr, size_in_bytes) -> None: ...

class ContextGuard:
    device: Incomplete
    def __init__(self, device) -> None: ...
    saved_context: Incomplete
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...

class Event:
    class Flags:
        DEFAULT: int
        BLOCKING_SYNC: int
        DISABLE_TIMING: int
        INTERPROCESS: int
    def __new__(cls, *args, **kwargs): ...
    device: Incomplete
    enable_timing: Incomplete
    cuda_event: Incomplete
    owner: bool
    def __init__(self, device: Devicelike = None, cuda_event=None, enable_timing: bool = False, interprocess: bool = False) -> None: ...
    def ipc_handle(self) -> bytes: ...
    @property
    def is_complete(self) -> bool: ...
    def __del__(self) -> None: ...

class Stream:
    def __new__(cls, *args, **kwargs): ...
    device: Incomplete
    cuda_stream: Incomplete
    owner: bool
    def __init__(self, device: Device | str | None = None, priority: int = 0, **kwargs) -> None: ...
    def __del__(self) -> None: ...
    @property
    def cached_event(self) -> Event: ...
    def record_event(self, event: Event | None = None) -> Event: ...
    def wait_event(self, event: Event): ...
    def wait_stream(self, other_stream: Stream, event: Event | None = None): ...
    @property
    def is_complete(self) -> bool: ...
    @property
    def is_capturing(self) -> bool: ...
    @property
    def priority(self) -> int: ...

class Device:
    runtime: Incomplete
    alias: Incomplete
    ordinal: Incomplete
    is_primary: Incomplete
    null_stream: Incomplete
    captures: Incomplete
    context_guard: Incomplete
    name: Incomplete
    arch: int
    sm_count: int
    is_uva: bool
    is_mempool_supported: bool
    is_mempool_enabled: bool
    is_ipc_supported: bool
    is_cubin_supported: bool
    uuid: Incomplete
    pci_bus_id: Incomplete
    memset: Incomplete
    memtile: Incomplete
    default_allocator: Incomplete
    pinned_allocator: Incomplete
    mempool_allocator: Incomplete
    current_allocator: Incomplete
    def __init__(self, runtime, alias, ordinal: int = -1, is_primary: bool = False, context=None) -> None: ...
    def get_allocator(self, pinned: bool = False): ...
    @property
    def is_cpu(self) -> bool: ...
    @property
    def is_cuda(self) -> bool: ...
    @property
    def is_capturing(self) -> bool: ...
    @property
    def context(self): ...
    @property
    def has_context(self) -> bool: ...
    @property
    def stream(self) -> Stream: ...
    @stream.setter
    def stream(self, stream) -> None: ...
    def set_stream(self, stream: Stream, sync: bool = True) -> None: ...
    @property
    def has_stream(self) -> bool: ...
    @property
    def total_memory(self) -> int: ...
    @property
    def free_memory(self) -> int: ...
    def __eq__(self, other): ...
    def make_current(self) -> None: ...
    def can_access(self, other): ...
Devicelike = Device | str | None

class Graph:
    device: Incomplete
    capture_id: Incomplete
    module_execs: set[ModuleExec]
    graph_exec: ctypes.c_void_p | None
    graph: ctypes.c_void_p | None
    has_conditional: bool
    def __init__(self, device: Device, capture_id: int) -> None: ...
    def __del__(self) -> None: ...
    def retain_module_exec(self, module_exec: ModuleExec): ...

class Runtime:
    core: Incomplete
    llvm: Incomplete
    captures: Incomplete
    device_map: Incomplete
    context_map: Incomplete
    cpu_device: Incomplete
    is_cuda_enabled: Incomplete
    is_cuda_compatibility_enabled: Incomplete
    toolkit_version: Incomplete
    driver_version: Incomplete
    min_driver_version: Incomplete
    cuda_devices: Incomplete
    cuda_primary_devices: Incomplete
    nvrtc_supported_archs: Incomplete
    cuda_custom_context_count: Incomplete
    default_ptx_arch: int
    tape: Incomplete
    def __init__(self) -> None: ...
    def get_error_string(self): ...
    def load_dll(self, dll_path): ...
    def get_device(self, ident: Devicelike = None) -> Device: ...
    default_device: Incomplete
    def set_default_device(self, ident: Devicelike) -> None: ...
    def get_current_cuda_device(self) -> Device: ...
    def rename_device(self, device, alias) -> Device: ...
    def map_cuda_device(self, alias, context=None) -> Device: ...
    def unmap_cuda_device(self, alias) -> None: ...
    def verify_cuda_device(self, device: Devicelike = None) -> None: ...

def is_cpu_available() -> bool: ...
def is_cuda_available() -> bool: ...
def is_device_available(device: Device) -> bool: ...
def is_cuda_driver_initialized() -> bool: ...
def get_devices() -> list[Device]: ...
def get_cuda_device_count() -> int: ...
def get_cuda_device(ordinal: int | None = None) -> Device: ...
def get_cuda_devices() -> list[Device]: ...
def get_preferred_device() -> Device: ...
def get_device(ident: Devicelike = None) -> Device: ...
def set_device(ident: Devicelike) -> None: ...
def map_cuda_device(alias: str, context: ctypes.c_void_p | None = None) -> Device: ...
def unmap_cuda_device(alias: str) -> None: ...
def is_mempool_supported(device: Devicelike) -> bool: ...
def is_mempool_enabled(device: Devicelike) -> bool: ...
def set_mempool_enabled(device: Devicelike, enable: bool) -> None: ...
def set_mempool_release_threshold(device: Devicelike, threshold: int | float) -> None: ...
def get_mempool_release_threshold(device: Devicelike = None) -> int: ...
def get_mempool_used_mem_current(device: Devicelike = None) -> int: ...
def get_mempool_used_mem_high(device: Devicelike = None) -> int: ...
def is_peer_access_supported(target_device: Devicelike, peer_device: Devicelike) -> bool: ...
def is_peer_access_enabled(target_device: Devicelike, peer_device: Devicelike) -> bool: ...
def set_peer_access_enabled(target_device: Devicelike, peer_device: Devicelike, enable: bool) -> None: ...
def is_mempool_access_supported(target_device: Devicelike, peer_device: Devicelike) -> bool: ...
def is_mempool_access_enabled(target_device: Devicelike, peer_device: Devicelike) -> bool: ...
def set_mempool_access_enabled(target_device: Devicelike, peer_device: Devicelike, enable: bool) -> None: ...
def get_stream(device: Devicelike = None) -> Stream: ...
def set_stream(stream: Stream, device: Devicelike = None, sync: bool = False) -> None: ...
def record_event(event: Event | None = None): ...
def wait_event(event: Event): ...
def get_event_elapsed_time(start_event: Event, end_event: Event, synchronize: bool = True): ...
def wait_stream(other_stream: Stream, event: Event | None = None): ...

class RegisteredGLBuffer:
    NONE: int
    READ_ONLY: int
    WRITE_DISCARD: int
    def __new__(cls, *args, **kwargs): ...
    gl_buffer_id: Incomplete
    device: Incomplete
    context: Incomplete
    flags: Incomplete
    fallback_to_copy: Incomplete
    resource: Incomplete
    warp_buffer: Incomplete
    warp_buffer_cpu: Incomplete
    def __init__(self, gl_buffer_id: int, device: Devicelike = None, flags: int = ..., fallback_to_copy: bool = True) -> None: ...
    def __del__(self) -> None: ...
    def map(self, dtype, shape) -> warp.array: ...
    def unmap(self) -> None: ...

def zeros(shape: int | tuple[int, ...] | list[int] | None = None, dtype: type = ..., device: Devicelike = None, requires_grad: bool = False, pinned: bool = False, **kwargs) -> warp.array: ...
def zeros_like(src: Array, device: Devicelike = None, requires_grad: bool | None = None, pinned: bool | None = None) -> warp.array: ...
def ones(shape: int | tuple[int, ...] | list[int] | None = None, dtype: type = ..., device: Devicelike = None, requires_grad: bool = False, pinned: bool = False, **kwargs) -> warp.array: ...
def ones_like(src: Array, device: Devicelike = None, requires_grad: bool | None = None, pinned: bool | None = None) -> warp.array: ...
def full(shape: int | tuple[int, ...] | list[int] | None = None, value: int = 0, dtype=..., device: Devicelike = None, requires_grad: bool = False, pinned: bool = False, **kwargs) -> warp.array: ...
def full_like(src: Array, value: Any, device: Devicelike = None, requires_grad: bool | None = None, pinned: bool | None = None) -> warp.array: ...
def clone(src: warp.array, device: Devicelike = None, requires_grad: bool | None = None, pinned: bool | None = None) -> warp.array: ...
def empty(shape: int | tuple[int, ...] | list[int] | None = None, dtype=..., device: Devicelike = None, requires_grad: bool = False, pinned: bool = False, **kwargs) -> warp.array: ...
def empty_like(src: Array, device: Devicelike = None, requires_grad: bool | None = None, pinned: bool | None = None) -> warp.array: ...
def from_numpy(arr: np.ndarray, dtype: type | None = None, shape: Sequence[int] | None = None, device: Devicelike | None = None, requires_grad: bool = False) -> warp.array: ...
def event_from_ipc_handle(handle, device: Devicelike = None) -> Event: ...
def pack_arg(kernel, arg_type, arg_name, value, device, adjoint: bool = False): ...

class Launch:
    module_exec: Incomplete
    kernel: Incomplete
    hooks: Incomplete
    params: Incomplete
    params_addr: Incomplete
    device: Device
    bounds: launch_bounds_t
    max_blocks: int
    block_dim: int
    adjoint: bool
    def __init__(self, kernel, device: Device, hooks: KernelHooks | None = None, params: Sequence[Any] | None = None, params_addr: Sequence[ctypes.c_void_p] | None = None, bounds: launch_bounds_t | None = None, max_blocks: int = 0, block_dim: int = 256, adjoint: bool = False) -> None: ...
    def set_dim(self, dim: int | list[int] | tuple[int, ...]): ...
    def set_param_at_index(self, index: int, value: Any, adjoint: bool = False): ...
    def set_param_at_index_from_ctype(self, index: int, value: ctypes.Structure | int | float): ...
    def set_param_by_name(self, name: str, value: Any, adjoint: bool = False): ...
    def set_param_by_name_from_ctype(self, name: str, value: ctypes.Structure): ...
    def set_params(self, values: Sequence[Any]): ...
    def set_params_from_ctypes(self, values: Sequence[ctypes.Structure]): ...
    def launch(self, stream: Stream | None = None) -> None: ...

def launch(kernel, dim: int | Sequence[int], inputs: Sequence = [], outputs: Sequence = [], adj_inputs: Sequence = [], adj_outputs: Sequence = [], device: Devicelike = None, stream: Stream | None = None, adjoint: bool = False, record_tape: bool = True, record_cmd: bool = False, max_blocks: int = 0, block_dim: int = 256): ...
def launch_tiled(*args, **kwargs): ...
def synchronize() -> None: ...
def synchronize_device(device: Devicelike = None): ...
def synchronize_stream(stream_or_device: Stream | Devicelike | None = None): ...
def synchronize_event(event: Event): ...
def force_load(device: Device | str | list[Device] | list[str] | None = None, modules: list[Module] | None = None): ...
def load_module(module: Module | types.ModuleType | str | None = None, device: Device | str | None = None, recursive: bool = False): ...
def set_module_options(options: dict[str, Any], module: Any = None): ...
def get_module_options(module: Any = None) -> dict[str, Any]: ...
def capture_begin(device: Devicelike = None, stream: Stream | None = None, force_module_load: bool | None = None, external: bool = False): ...
def capture_end(device: Devicelike = None, stream: Stream | None = None) -> Graph: ...
def capture_debug_dot_print(graph: Graph, path: str, verbose: bool = False): ...
def assert_conditional_graph_support() -> None: ...
def capture_pause(device: Devicelike = None, stream: Stream | None = None) -> ctypes.c_void_p: ...
def capture_resume(graph: ctypes.c_void_p, device: Devicelike = None, stream: Stream | None = None): ...

condition_host: Incomplete

def capture_if(condition: None, on_true: Callable | Graph | None = None, on_false: Callable | Graph | None = None, stream: Stream = None, **kwargs): ...
def capture_while(condition: None, while_body: Callable | Graph, stream: Stream = None, **kwargs): ...
def capture_launch(graph: Graph, stream: Stream | None = None): ...
def copy(dest: warp.array, src: warp.array, dest_offset: int = 0, src_offset: int = 0, count: int = 0, stream: Stream | None = None): ...
def adj_copy(adj_dest: warp.array, adj_src: warp.array, dest_offset: int, src_offset: int, count: int, stream: Stream = None): ...
def type_str(t): ...
def ctype_ret_str(t): ...
def resolve_exported_function_sig(f): ...
def print_function(f, file, is_exported, noentry: bool = False): ...
def export_functions_rst(file) -> None: ...
def export_stubs(file) -> None: ...
def export_builtins(file: io.TextIOBase): ...

runtime: Incomplete

def init() -> None: ...
