from _typeshed import Incomplete
from typing import Any, Callable
from warp.fem.linalg import skew_part as skew_part, symmetric_part as symmetric_part
from warp.fem.types import Coords as Coords, Domain as Domain, ElementIndex as ElementIndex, Field as Field, NodeIndex as NodeIndex, Sample as Sample, make_free_sample as make_free_sample

class Integrand:
    func: Incomplete
    name: Incomplete
    module: Incomplete
    argspec: Incomplete
    kernel_options: Incomplete
    operators: dict[str, set[Operator]] | None
    def __init__(self, func: Callable, kernel_options: dict[str, Any] | None = None) -> None: ...

class Operator:
    func: Incomplete
    name: Incomplete
    resolver: Incomplete
    attr: Incomplete
    field_result: Incomplete
    def __init__(self, func: Callable, resolver: Callable, field_result: Callable | None = None, attr: str | None = None) -> None: ...

def integrand(func: Callable | None = None, kernel_options: dict[str, Any] | None = None): ...
def operator(**kwargs): ...
def position(domain: Domain, s: Sample): ...
def normal(domain: Domain, s: Sample): ...
def deformation_gradient(domain: Domain, s: Sample): ...
def lookup(domain: Domain, x: Any) -> Sample: ...
def partition_lookup(domain: Domain, x: Any) -> Sample: ...
def measure(domain: Domain, s: Sample) -> float: ...
def measure_ratio(domain: Domain, s: Sample) -> float: ...
def element_closest_point(domain: Domain, element_index: ElementIndex, x: Any) -> Sample: ...
def element_coordinates(domain: Domain, element_index: ElementIndex, x: Any) -> Sample: ...
def cells(domain: Domain) -> Domain: ...
@integrand
def to_inner_cell(domain: Domain, s: Sample): ...
@integrand
def to_outer_cell(domain: Domain, s: Sample): ...
@integrand
def to_cell_side(domain: Domain, cell_s: Sample, side_index: ElementIndex): ...
def element_index(domain: Domain, domain_element_index: ElementIndex): ...
def element_partition_index(domain: Domain, cell_index: ElementIndex): ...
def inner(f: Field, s: Sample): ...
def grad(f: Field, s: Sample): ...
def div(f: Field, s: Sample): ...
def outer(f: Field, s: Sample): ...
def grad_outer(f: Field, s: Sample): ...
def div_outer(f: Field, s: Sample): ...
def degree(f: Field): ...
def node_count(f: Field, s: Sample): ...
def at_node(f: Field, s: Sample, node_index_in_elt: int | None = None): ...
def node_index(f: Field, s: Sample, node_index_in_elt: int | None = None): ...
def node_partition_index(f: Field, node_index: NodeIndex): ...
@integrand
def D(f: Field, s: Sample): ...
@integrand
def curl(f: Field, s: Sample): ...
@integrand
def jump(f: Field, s: Sample): ...
@integrand
def average(f: Field, s: Sample): ...
@integrand
def grad_jump(f: Field, s: Sample): ...
@integrand
def grad_average(f: Field, s: Sample): ...
