import warp as wp
from _typeshed import Incomplete
from typing import Any, Generic
from warp.types import Array as Array, Cols as Cols, Rows as Rows, Scalar as Scalar, Vector as Vector, is_array as is_array, scalar_types as scalar_types, type_is_matrix as type_is_matrix, type_repr as type_repr, type_scalar_type as type_scalar_type, type_size as type_size, type_size_in_bytes as type_size_in_bytes, type_to_warp as type_to_warp, types_equal as types_equal

class _MatrixBlockType(Generic[Rows, Cols, Scalar]): ...
class _ScalarBlockType(Generic[Scalar]): ...

BlockType: Incomplete

class BsrMatrix(Generic[_BlockType]):
    @property
    def scalar_type(self) -> Scalar: ...
    @property
    def block_shape(self) -> tuple[int, int]: ...
    @property
    def block_size(self) -> int: ...
    @property
    def shape(self) -> tuple[int, int]: ...
    @property
    def dtype(self) -> type: ...
    @property
    def device(self) -> wp.context.Device: ...
    @property
    def requires_grad(self) -> bool: ...
    @property
    def scalar_values(self) -> wp.array: ...
    def uncompress_rows(self, out: wp.array = None) -> wp.array: ...
    nnz: Incomplete
    def nnz_sync(self): ...
    def copy_nnz_async(self) -> None: ...
    def __add__(self, y): ...
    def __iadd__(self, y): ...
    def __radd__(self, x): ...
    def __sub__(self, y): ...
    def __rsub__(self, x): ...
    def __isub__(self, y): ...
    def __mul__(self, y): ...
    def __rmul__(self, x): ...
    def __imul__(self, y): ...
    def __matmul__(self, y): ...
    def __rmatmul__(self, x): ...
    def __imatmul__(self, y): ...
    def __truediv__(self, y): ...
    def __neg__(self): ...
    def transpose(self): ...

def bsr_matrix_t(dtype: BlockType): ...
def bsr_zeros(rows_of_blocks: int, cols_of_blocks: int, block_type: BlockType, device: wp.context.Devicelike = None) -> BsrMatrix: ...
def bsr_set_zero(bsr: BsrMatrix, rows_of_blocks: int | None = None, cols_of_blocks: int | None = None): ...
def bsr_set_from_triplets(dest: BsrMatrix[BlockType[Rows, Cols, Scalar]], rows: Array[int], columns: Array[int], values: Array[Scalar | BlockType[Rows, Cols, Scalar]] | None = None, count: Array[int] | None = None, prune_numerical_zeros: bool = True, masked: bool = False): ...
def bsr_from_triplets(rows_of_blocks: int, cols_of_blocks: int, rows: Array[int], columns: Array[int], values: Array[Scalar | BlockType[Rows, Cols, Scalar]], prune_numerical_zeros: bool = True): ...

class _BsrExpression(Generic[_BlockType]): ...

class _BsrScalingExpression(_BsrExpression):
    mat: Incomplete
    scale: Incomplete
    def __init__(self, mat, scale) -> None: ...
    def eval(self): ...
    @property
    def nrow(self) -> int: ...
    @property
    def ncol(self) -> int: ...
    @property
    def nnz(self) -> int: ...
    @property
    def offsets(self) -> wp.array: ...
    @property
    def columns(self) -> wp.array: ...
    @property
    def scalar_type(self) -> Scalar: ...
    @property
    def block_shape(self) -> tuple[int, int]: ...
    @property
    def block_size(self) -> int: ...
    @property
    def shape(self) -> tuple[int, int]: ...
    @property
    def dtype(self) -> type: ...
    @property
    def requires_grad(self) -> bool: ...
    @property
    def device(self) -> wp.context.Device: ...
    def __add__(self, y): ...
    def __radd__(self, x): ...
    def __sub__(self, y): ...
    def __rsub__(self, x): ...
    def __mul__(self, y): ...
    def __rmul__(self, x): ...
    def __matmul__(self, y): ...
    def __rmatmul__(self, x): ...
    def __truediv__(self, y): ...
    def __neg__(self): ...
    def transpose(self): ...

BsrMatrixOrExpression: Incomplete

def bsr_assign(dest: BsrMatrix[BlockType[Rows, Cols, Scalar]], src: BsrMatrixOrExpression[BlockType[Any, Any, Any]], structure_only: bool = False, masked: bool = False): ...
def bsr_copy(A: BsrMatrixOrExpression, scalar_type: Scalar | None = None, block_shape: tuple[int, int] | None = None, structure_only: bool = False): ...
def bsr_set_transpose(dest: BsrMatrix[BlockType[Cols, Rows, Scalar]], src: BsrMatrixOrExpression[BlockType[Rows, Cols, Scalar]]): ...
def bsr_transposed(A: BsrMatrixOrExpression) -> BsrMatrix: ...
def bsr_get_diag(A: BsrMatrixOrExpression[BlockType], out: Array[BlockType] | None = None) -> Array[BlockType]: ...
def bsr_set_diag(A: BsrMatrix[BlockType], diag: BlockType | Array[BlockType], rows_of_blocks: int | None = None, cols_of_blocks: int | None = None) -> None: ...
def bsr_diag(diag: BlockType | Array[BlockType] | None = None, rows_of_blocks: int | None = None, cols_of_blocks: int | None = None, block_type: BlockType | None = None, device=None) -> BsrMatrix['BlockType']: ...
def bsr_set_identity(A: BsrMatrix, rows_of_blocks: int | None = None) -> None: ...
def bsr_identity(rows_of_blocks: int, block_type: BlockType[Rows, Rows, Scalar], device: wp.context.Devicelike = None) -> BsrMatrix[BlockType[Rows, Rows, Scalar]]: ...
def bsr_scale(x: BsrMatrixOrExpression, alpha: Scalar) -> BsrMatrix: ...

class bsr_axpy_work_arrays:
    def __init__(self) -> None: ...

def bsr_axpy(x: BsrMatrixOrExpression, y: BsrMatrix[BlockType[Rows, Cols, Scalar]] | None = None, alpha: Scalar = 1.0, beta: Scalar = 1.0, masked: bool = False, work_arrays: bsr_axpy_work_arrays | None = None) -> BsrMatrix[BlockType[Rows, Cols, Scalar]]: ...

class bsr_mm_work_arrays:
    def __init__(self) -> None: ...

def bsr_mm(x: BsrMatrixOrExpression[BlockType[Rows, Any, Scalar]], y: BsrMatrixOrExpression[BlockType[Any, Cols, Scalar]], z: BsrMatrix[BlockType[Rows, Cols, Scalar]] | None = None, alpha: Scalar = 1.0, beta: Scalar = 0.0, masked: bool = False, work_arrays: bsr_mm_work_arrays | None = None, reuse_topology: bool = False) -> BsrMatrix[BlockType[Rows, Cols, Scalar]]: ...
def bsr_mv(A: BsrMatrixOrExpression[BlockType[Rows, Cols, Scalar]], x: Array[Vector[Cols, Scalar] | Scalar], y: Array[Vector[Rows, Scalar] | Scalar] | None = None, alpha: Scalar = 1.0, beta: Scalar = 0.0, transpose: bool = False, work_buffer: Array[Vector[Rows, Scalar] | Scalar] | None = None) -> Array[Vector[Rows, Scalar] | Scalar]: ...
