import builtins
import ctypes
import numpy as np
import numpy.typing as npt
import warp
from _typeshed import Incomplete
from typing import Any, Callable, ClassVar, Generic, Literal, NamedTuple, Sequence, TypeVar
from warp.codegen import Var as Var
from warp.fabric import fabricarray as fabricarray, indexedfabricarray as indexedfabricarray

T = TypeVar('T')
Length = TypeVar('Length', bound=int)
Rows = TypeVar('Rows')
Cols = TypeVar('Cols')
DType = TypeVar('DType')
Shape = TypeVar('Shape', bound=tuple[int, ...])
Int = TypeVar('Int')
Float = TypeVar('Float')
Scalar = TypeVar('Scalar')

class Vector(Generic[Length, Scalar]): ...
class Matrix(Generic[Rows, Cols, Scalar]): ...
class Quaternion(Generic[Float]): ...
class Transformation(Generic[Float]): ...

class Array(Generic[DType]):
    device: warp.context.Device | None
    dtype: type
    size: int
    def __add__(self, other) -> array: ...
    def __radd__(self, other) -> array: ...
    def __sub__(self, other) -> array: ...
    def __rsub__(self, other) -> array: ...
    def __mul__(self, other) -> array: ...
    def __rmul__(self, other) -> array: ...
    def __truediv__(self, other) -> array: ...
    def __rtruediv__(self, other) -> array: ...
    def __floordiv__(self, other) -> array: ...
    def __rfloordiv__(self, other) -> array: ...
    def __mod__(self, other) -> array: ...
    def __rmod__(self, other) -> array: ...
    def __pow__(self, other) -> array: ...
    def __rpow__(self, other) -> array: ...
    def __neg__(self) -> array: ...
    def __pos__(self) -> array: ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def __imul__(self, other): ...
    def __itruediv__(self, other): ...
    def __ifloordiv__(self, other): ...
    def __imod__(self, other): ...
    def __ipow__(self, other): ...

class Tile(Generic[DType, Shape]): ...

def constant(x): ...
def float_to_half_bits(value): ...
def half_bits_to_float(value): ...
def safe_len(obj): ...
def vector(length, dtype): ...
def matrix(shape, dtype): ...

class void:
    def __init__(self) -> None: ...

class scalar_base:
    value: Incomplete
    def __init__(self, x: int = 0) -> None: ...
    def __bool__(self) -> builtins.bool: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    def __add__(self, y): ...
    def __radd__(self, y): ...
    def __sub__(self, y): ...
    def __rsub__(self, y): ...
    def __mul__(self, y): ...
    def __rmul__(self, x): ...
    def __truediv__(self, y): ...
    def __rtruediv__(self, x): ...
    def __mod__(self, x): ...
    def __rmod__(self, x): ...
    def __pos__(self): ...
    def __neg__(self): ...

class float_base(scalar_base): ...

class int_base(scalar_base):
    def __index__(self) -> int: ...

class bool:
    value: Incomplete
    def __init__(self, x: bool = False) -> None: ...
    def __bool__(self) -> builtins.bool: ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...

class float16(float_base): ...
class float32(float_base): ...
class float64(float_base): ...
class int8(int_base): ...
class uint8(int_base): ...
class int16(int_base): ...
class uint16(int_base): ...
class int32(int_base): ...
class uint32(int_base): ...
class int64(int_base): ...
class uint64(int_base): ...

def quaternion(dtype=...): ...

class quath(Incomplete): ...
class quatf(Incomplete): ...
class quatd(Incomplete): ...

def transformation(dtype=...): ...

class transformh(Incomplete): ...
class transformf(Incomplete): ...
class transformd(Incomplete): ...
class vec2h(Incomplete): ...
class vec3h(Incomplete): ...
class vec4h(Incomplete): ...
class vec2f(Incomplete): ...
class vec3f(Incomplete): ...
class vec4f(Incomplete): ...
class vec2d(Incomplete): ...
class vec3d(Incomplete): ...
class vec4d(Incomplete): ...
class vec2b(Incomplete): ...
class vec3b(Incomplete): ...
class vec4b(Incomplete): ...
class vec2ub(Incomplete): ...
class vec3ub(Incomplete): ...
class vec4ub(Incomplete): ...
class vec2s(Incomplete): ...
class vec3s(Incomplete): ...
class vec4s(Incomplete): ...
class vec2us(Incomplete): ...
class vec3us(Incomplete): ...
class vec4us(Incomplete): ...
class vec2i(Incomplete): ...
class vec3i(Incomplete): ...
class vec4i(Incomplete): ...
class vec2ui(Incomplete): ...
class vec3ui(Incomplete): ...
class vec4ui(Incomplete): ...
class vec2l(Incomplete): ...
class vec3l(Incomplete): ...
class vec4l(Incomplete): ...
class vec2ul(Incomplete): ...
class vec3ul(Incomplete): ...
class vec4ul(Incomplete): ...
class mat22h(Incomplete): ...
class mat33h(Incomplete): ...
class mat44h(Incomplete): ...
class mat22f(Incomplete): ...
class mat33f(Incomplete): ...
class mat44f(Incomplete): ...
class mat22d(Incomplete): ...
class mat33d(Incomplete): ...
class mat44d(Incomplete): ...
class spatial_vectorh(Incomplete): ...
class spatial_vectorf(Incomplete): ...
class spatial_vectord(Incomplete): ...
class spatial_matrixh(Incomplete): ...
class spatial_matrixf(Incomplete): ...
class spatial_matrixd(Incomplete): ...
vec2 = vec2f
vec3 = vec3f
vec4 = vec4f
mat22 = mat22f
mat33 = mat33f
mat44 = mat44f
quat = quatf
transform = transformf
spatial_vector = spatial_vectorf
spatial_matrix = spatial_matrixf
int_types: Incomplete
float_types: Incomplete
scalar_types: Incomplete
scalar_and_bool_types: Incomplete
vector_types: Incomplete
np_dtype_to_warp_type: Incomplete
warp_type_to_np_dtype: Incomplete
non_atomic_types: Incomplete

def dtype_from_numpy(numpy_dtype): ...
def dtype_to_numpy(warp_dtype): ...

np_dtype_compatible_sets: dict[np.dtype, set[Any]]

def np_dtype_is_compatible(numpy_dtype: np.dtype, warp_dtype) -> builtins.bool: ...

class range_t:
    def __init__(self) -> None: ...

class BvhQuery: ...
class MeshQueryAABB: ...
class HashGridQuery: ...

ARRAY_MAX_DIMS: int
LAUNCH_MAX_DIMS: int
ARRAY_TYPE_REGULAR: int
ARRAY_TYPE_INDEXED: int
ARRAY_TYPE_FABRIC: int
ARRAY_TYPE_FABRIC_INDEXED: int

class launch_bounds_t(ctypes.Structure):
    ndim: int
    size: Incomplete
    def __init__(self, shape: int | Sequence[int]) -> None: ...

class shape_t(ctypes.Structure):
    def __init__(self) -> None: ...

class array_t(ctypes.Structure):
    data: Incomplete
    grad: Incomplete
    ndim: Incomplete
    def __init__(self, data: int = 0, grad: int = 0, ndim: int = 0, shape=(0,), strides=(0,)) -> None: ...
    @classmethod
    def numpy_dtype(cls): ...
    def numpy_value(self): ...

class indexedarray_t(ctypes.Structure):
    data: Incomplete
    def __init__(self, data, indices, shape) -> None: ...

class tuple_t:
    types: Incomplete
    values: Incomplete
    def __init__(self, types, values) -> None: ...

def type_ctype(dtype): ...
def type_length(obj): ...
def type_size(dtype): ...
def type_scalar_type(dtype): ...
def type_size_in_bytes(dtype: type) -> int: ...
def type_to_warp(dtype: type) -> type: ...
def type_typestr(dtype: type) -> str: ...
def scalar_short_name(t): ...
def type_repr(t) -> str: ...
def type_is_int(t): ...
def type_is_float(t): ...
def type_is_vector(t): ...
def type_is_quaternion(t): ...
def type_is_matrix(t): ...
def type_is_transformation(t): ...

value_types: Incomplete

def type_is_value(x: Any) -> builtins.bool: ...
def is_int(x: Any) -> builtins.bool: ...
def is_float(x: Any) -> builtins.bool: ...
def is_value(x: Any) -> builtins.bool: ...
def is_array(a) -> builtins.bool: ...
def is_tuple(t) -> builtins.bool: ...
def scalars_equal(a, b, match_generic: bool = False): ...
def seq_match_ellipsis(a, b, match_generic: bool = False) -> bool: ...
def types_equal(a, b, match_generic: bool = False): ...
def strides_from_shape(shape: tuple, dtype): ...
def check_array_shape(shape: tuple): ...
def array_ctype_from_interface(interface: dict, dtype=None, owner=None): ...

class array(Array[DType]):
    def __new__(cls, *args, **kwargs): ...
    ctype: Incomplete
    is_transposed: bool
    def __init__(self, data: list | tuple | npt.NDArray | None = None, dtype: Any = ..., shape: int | tuple[int, ...] | list[int] | None = None, strides: tuple[int, ...] | None = None, ptr: int | None = None, capacity: int | None = None, device=None, pinned: builtins.bool = False, copy: builtins.bool = True, deleter: Callable[[int, int], None] | None = None, ndim: int | None = None, grad: array | None = None, requires_grad: builtins.bool = False) -> None: ...
    def __del__(self) -> None: ...
    @property
    def __array_interface__(self): ...
    @property
    def __cuda_array_interface__(self): ...
    def __dlpack__(self, stream=None): ...
    def __dlpack_device__(self): ...
    def __len__(self) -> int: ...
    def __getitem__(self, key): ...
    def __ctype__(self): ...
    def __matmul__(self, other): ...
    @property
    def grad(self): ...
    @grad.setter
    def grad(self, grad) -> None: ...
    @property
    def requires_grad(self): ...
    @requires_grad.setter
    def requires_grad(self, value: builtins.bool): ...
    @property
    def vars(self): ...
    def mark_init(self) -> None: ...
    def mark_read(self) -> None: ...
    def mark_write(self, **kwargs) -> None: ...
    def zero_(self) -> None: ...
    def fill_(self, value) -> None: ...
    def assign(self, src) -> None: ...
    def numpy(self): ...
    def cptr(self): ...
    def list(self): ...
    def to(self, device, requires_grad=None): ...
    def flatten(self): ...
    def reshape(self, shape): ...
    def view(self, dtype): ...
    def contiguous(self): ...
    def transpose(self, axes=None): ...
    def ipc_handle(self) -> bytes: ...

def array1d(*args, **kwargs): ...
def array2d(*args, **kwargs): ...
def array3d(*args, **kwargs): ...
def array4d(*args, **kwargs): ...
def from_ptr(ptr, length, dtype=None, shape=None, device=None): ...
def from_ipc_handle(handle: bytes, dtype, shape: tuple[int, ...], strides: tuple[int, ...] | None = None, device=None) -> array: ...

class noncontiguous_array_base(Array[T]):
    type_id: Incomplete
    is_contiguous: bool
    def __init__(self, array_type_id) -> None: ...
    def contiguous(self): ...
    def to(self, device): ...
    def numpy(self): ...
    def list(self): ...
    def assign(self, src) -> None: ...
    def zero_(self) -> None: ...
    def fill_(self, value) -> None: ...

def check_index_array(indices, expected_device) -> None: ...

class indexedarray(noncontiguous_array_base):
    data: Incomplete
    indices: Incomplete
    dtype: Incomplete
    ndim: Incomplete
    device: Incomplete
    pinned: Incomplete
    shape: Incomplete
    size: int
    def __init__(self, data: array | None = None, indices: array | list[array] | None = None, dtype=None, ndim: int | None = None) -> None: ...
    def __len__(self) -> int: ...
    def __ctype__(self): ...
    @property
    def vars(self): ...

def indexedarray1d(*args, **kwargs): ...
def indexedarray2d(*args, **kwargs): ...
def indexedarray3d(*args, **kwargs): ...
def indexedarray4d(*args, **kwargs): ...

array_types: Incomplete

def array_type_id(a): ...

class tile(Tile[DType, Shape]):
    alignment: int
    dtype: Incomplete
    shape: Incomplete
    storage: Incomplete
    layout: Incomplete
    strides: Incomplete
    size: int
    owner: Incomplete
    def __init__(self, dtype: Any, shape: tuple[int, ...] | list[int], storage: str = 'register', layout: str = 'rowmajor', strides: tuple[int, ...] | None = None, owner: builtins.bool = True) -> None: ...
    def ctype(self): ...
    def cinit(self, requires_grad: bool = False): ...
    def size_in_bytes(self): ...
    @staticmethod
    def round_up(bytes): ...
    def align(self, bytes): ...

def is_tile(t): ...

bvh_constructor_values: Incomplete

class Bvh:
    def __new__(cls, *args, **kwargs): ...
    device: Incomplete
    lowers: Incomplete
    uppers: Incomplete
    runtime: Incomplete
    id: Incomplete
    def __init__(self, lowers: array, uppers: array, constructor: str | None = None) -> None: ...
    def __del__(self) -> None: ...
    def refit(self) -> None: ...

class Mesh:
    vars: ClassVar[dict[str, Var]]
    def __new__(cls, *args, **kwargs): ...
    device: Incomplete
    indices: Incomplete
    runtime: Incomplete
    id: Incomplete
    def __init__(self, points: array, indices: array, velocities: array | None = None, support_winding_number: builtins.bool = False, bvh_constructor: str | None = None) -> None: ...
    def __del__(self) -> None: ...
    def refit(self) -> None: ...
    @property
    def points(self): ...
    @points.setter
    def points(self, points_new) -> None: ...
    @property
    def velocities(self): ...
    @velocities.setter
    def velocities(self, velocities_new) -> None: ...

class Volume:
    CLOSEST: Incomplete
    LINEAR: Incomplete
    def __new__(cls, *args, **kwargs): ...
    runtime: Incomplete
    device: Incomplete
    id: Incomplete
    def __init__(self, data: array, copy: builtins.bool = True) -> None: ...
    def __del__(self) -> None: ...
    def array(self) -> array: ...
    def get_tile_count(self) -> int: ...
    def get_tiles(self, out: array | None = None) -> array: ...
    def get_voxel_count(self) -> int: ...
    def get_voxels(self, out: array | None = None) -> array: ...
    def get_voxel_size(self) -> tuple[float, float, float]: ...
    class GridInfo(NamedTuple):
        name: str
        size_in_bytes: int
        grid_index: int
        grid_count: int
        type_str: str
        translation: vec3f
        transform_matrix: mat33f
    def get_grid_info(self) -> Volume.GridInfo: ...
    @property
    def dtype(self) -> type: ...
    @property
    def is_index(self) -> bool: ...
    def get_feature_array_count(self) -> int: ...
    class FeatureArrayInfo(NamedTuple):
        name: str
        ptr: int
        value_size: int
        value_count: int
        type_str: str
    def get_feature_array_info(self, feature_index: int) -> Volume.FeatureArrayInfo: ...
    def feature_array(self, feature_index: int, dtype=None) -> array: ...
    @classmethod
    def load_from_nvdb(cls, file_or_buffer, device=None) -> Volume: ...
    def save_to_nvdb(self, path, codec: Literal['none', 'zip', 'blosc'] = 'none'): ...
    @classmethod
    def load_from_address(cls, grid_ptr: int, buffer_size: int = 0, device=None) -> Volume: ...
    def load_next_grid(self) -> Volume: ...
    @classmethod
    def load_from_numpy(cls, ndarray: np.array, min_world=(0.0, 0.0, 0.0), voxel_size: float = 1.0, bg_value: float = 0.0, device=None) -> Volume: ...
    @classmethod
    def allocate(cls, min: list[int], max: list[int], voxel_size: float, bg_value: float = 0.0, translation=(0.0, 0.0, 0.0), points_in_world_space: bool = False, device=None) -> Volume: ...
    @classmethod
    def allocate_by_tiles(cls, tile_points: array, voxel_size: float | list[float] | None = None, bg_value: float = 0.0, translation=(0.0, 0.0, 0.0), device=None, transform=None) -> Volume: ...
    @classmethod
    def allocate_by_voxels(cls, voxel_points: array, voxel_size: float | list[float] | None = None, translation=(0.0, 0.0, 0.0), device=None, transform=None) -> Volume: ...

class MeshQueryPoint:
    vars: ClassVar[dict[str, Var]]

class MeshQueryRay:
    vars: ClassVar[dict[str, Var]]

def matmul(a: array2d, b: array2d, c: array2d, d: array2d, alpha: float = 1.0, beta: float = 0.0, allow_tf32x3_arith: builtins.bool = False): ...
def adj_matmul(a: array2d, b: array2d, c: array2d, adj_a: array2d, adj_b: array2d, adj_c: array2d, adj_d: array2d, alpha: float = 1.0, beta: float = 0.0, allow_tf32x3_arith: builtins.bool = False): ...
def batched_matmul(a: array3d, b: array3d, c: array3d, d: array3d, alpha: float = 1.0, beta: float = 0.0, allow_tf32x3_arith: builtins.bool = False): ...
def adj_batched_matmul(a: array3d, b: array3d, c: array3d, adj_a: array3d, adj_b: array3d, adj_c: array3d, adj_d: array3d, alpha: float = 1.0, beta: float = 0.0, allow_tf32x3_arith: builtins.bool = False): ...

class HashGrid:
    def __new__(cls, *args, **kwargs): ...
    runtime: Incomplete
    device: Incomplete
    id: Incomplete
    reserved: bool
    def __init__(self, dim_x, dim_y, dim_z, device=None) -> None: ...
    def build(self, points, radius) -> None: ...
    def reserve(self, num_points) -> None: ...
    def __del__(self) -> None: ...

class MarchingCubes:
    def __new__(cls, *args, **kwargs): ...
    id: int
    runtime: Incomplete
    device: Incomplete
    nx: Incomplete
    ny: Incomplete
    nz: Incomplete
    max_verts: Incomplete
    max_tris: Incomplete
    alloc: Incomplete
    free: Incomplete
    verts: Incomplete
    indices: Incomplete
    def __init__(self, nx: int, ny: int, nz: int, max_verts: int, max_tris: int, device=None) -> None: ...
    def __del__(self) -> None: ...
    def resize(self, nx: int, ny: int, nz: int, max_verts: int, max_tris: int) -> None: ...
    def surface(self, field: None, threshold: float) -> None: ...

generic_types: Incomplete

def type_is_generic(t): ...
def type_is_generic_scalar(t): ...
def type_matches_template(arg_type, template_type): ...
def infer_argument_types(args: list[Any], template_types, arg_names: list[str] | None = None) -> list[type]: ...

simple_type_codes: Incomplete

def get_type_code(arg_type: type) -> str: ...
def get_signature(arg_types: list[type], func_name: str | None = None, arg_names: list[str] | None = None) -> str: ...
def is_generic_signature(sig): ...
